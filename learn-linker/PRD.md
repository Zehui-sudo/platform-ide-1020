# Learn-Linker 产品需求文档 v2.0

## 1. 产品定位

### 核心理念
**练中学（Learning by Doing）** - 在实际编码环境中进行实时学习，将理论与实践紧密结合。

### 产品关系
- **独立性**：Learn-linker 是一个完全独立的 VSCode 插件，拥有自己的 AI 服务
- **协同性**：仅在知识点匹配时与 web-learner 平台联动

## 2. 核心功能

### 2.1 独立功能

#### 🤖 流式 AI 代码解释
- **触发方式**：选中代码片段
- **展现形式**：PeekView 内嵌展示（类似查看定义的体验）
- **技术特点**：
  - 独立的 AI 服务组件
  - 智能选区扩展（自动扩展到完整语法单元）
  - 流式输出，即时响应
- **核心要求**：
  - 无缝体验，不干扰编码流程
  - 不挤占视觉空间
  - 支持 ESC 快速关闭

#### 📚 代码集管理
- **功能描述**：保存和管理有价值的代码片段
- **核心特性**：
  - 自动标签归类（基于 AST 分析）
  - 支持搜索和筛选
  - 本地存储
- **展现形式**：WebView 或专用侧边栏（次要功能）

### 2.2 联动功能

#### 🔗 知识点深链
- **技术方案**：
  1. 本地 AST 解析提取代码特征
  2. 发送特征到 web-learner 平台
  3. 平台返回匹配的知识点链接
  4. 在 PeekView 底部展示相关链接
- **成功标准**：匹配准确率 >90%
- **依赖**：需要 web-learner 提供知识点匹配 API

#### ☁️ 代码集同步
- **同步内容**：收藏的代码片段、标签、笔记
- **实现时机**：Phase 3（非核心功能）

## 3. 技术方案

### 3.1 PeekView 实现策略

#### 方案 A：Hover Provider + 自定义触发（推荐）
```typescript
// 使用 Hover Provider 模拟 PeekView 效果
vscode.languages.registerHoverProvider('*', {
    provideHover(document, position) {
        // 检测选中区域
        // 返回 MarkdownString 或 WebView 内容
    }
});
```

#### 方案 B：利用 Code Action + WebView
```typescript
// 通过 Code Action 触发，在编辑器内嵌入 WebView
vscode.languages.registerCodeActionProvider('*', {
    provideCodeActions() {
        // 提供"获取AI解释"的 action
    }
});
```

**技术验证点**：
- PeekView 能否支持流式更新
- 能否自定义样式匹配 VSCode 主题
- 响应速度是否满足要求

### 3.2 智能选区扩展

**目标**：将不完整的选择自动扩展到完整的语法单元

**实现方案**：
```typescript
// 使用 TypeScript Compiler API 或 Tree-sitter
function expandSelection(document: TextDocument, selection: Selection) {
    // 1. 解析当前文件的 AST
    // 2. 找到包含选区的最小完整节点
    // 3. 返回扩展后的范围
}
```

**扩展规则**：
- 部分变量 → 完整声明语句
- 部分函数 → 完整函数定义
- 部分条件 → 完整 if/else 块
- 部分循环 → 完整循环结构

### 3.3 AI 服务架构

```
Learn-linker 插件
├── AI 服务层（独立）
│   ├── 模型配置
│   ├── Prompt 管理
│   └── 流式输出处理
├── AST 分析层
│   ├── 代码解析
│   ├── 特征提取
│   └── 选区扩展
└── API 客户端
    └── 知识点匹配 API（调用 web-learner）
```

## 4. 用户体验设计

### 4.1 核心交互流程

```
1. 用户选中代码（可能不完整）
   ↓
2. 智能扩展到完整语法单元
   ↓
3. CodeLens 显示提示
   ↓
4. 点击或快捷键触发
   ↓
5. PeekView 在代码下方展开
   ├── 顶部：流式 AI 解释
   └── 底部：相关知识点链接
   ↓
6. ESC 关闭，继续编码
```

### 4.2 UI 设计原则
- **最小干扰**：不遮挡代码，不改变布局
- **快速访问**：快捷键直达
- **易于关闭**：ESC 即关，恢复编码

## 5. 开发阶段（更新版）

### Phase 0: 技术验证 ⭐
**目标**：验证核心技术可行性
- [ ] PeekView 自定义内容实现
- [ ] 流式输出在 PeekView 中展示
- [ ] 智能选区扩展算法验证
- [ ] AI 服务响应速度测试

**风险**：如果 PeekView 不可行，降级到 Hover + Modal

### Phase 1: MVP - 核心体验
**目标**：实现基础的 AI 解释功能
- [ ] CodeLens 基础实现
- [ ] 智能选区扩展
- [ ] PeekView AI 解释展示
- [ ] 独立 AI 服务集成
- [ ] 流式输出优化

**验收标准**：
- 选中代码能智能扩展
- PeekView 流畅展示
- AI 解释准确

### Phase 2: 平台优化
**目标**：为知识点匹配做准备
- [ ] Web-learner 知识点 API 开发
- [ ] AST 标签提取优化
- [ ] 知识点匹配算法实现
- [ ] API 性能优化

### Phase 3: 联动功能
**目标**：连接插件与平台
- [ ] AST 特征提取
- [ ] 知识点匹配 API 调用
- [ ] PeekView 中展示知识点链接
- [ ] 点击跳转到 web-learner

### Phase 4: 完善功能
**目标**：代码集管理与优化
- [ ] 代码集管理器实现
- [ ] 自动标签分类
- [ ] UI/UX 优化
- [ ] 错误处理完善

## 6. 技术决策记录

### 为什么选择 PeekView 而非 TreeView？
- **无缝体验**：不需要切换视图
- **空间利用**：临时展开，不占用固定空间
- **符合习惯**：类似查看定义的原生体验

### 为什么需要智能选区扩展？
- **用户友好**：不要求精确选择
- **语义完整**：确保 AI 获得完整上下文
- **减少歧义**：避免片段代码造成误解

### 为什么 AI 服务要独立？
- **降低耦合**：插件可独立运行
- **性能优化**：可以选择更适合的模型
- **隐私安全**：代码不需要发送到平台

## 7. 风险与对策

| 风险 | 影响等级 | 对策 |
|-----|---------|------|
| PeekView 技术限制 | 高 | 备选方案：Hover + Modal 或 Webview Panel |
| 智能扩展不准确 | 中 | 提供手动调整选区的选项 |
| AI 响应延迟 | 中 | 优化 Prompt，使用更快的模型 |
| 知识点匹配 API 延迟 | 低 | 异步加载，先展示 AI 解释 |

## 8. 成功指标

### 核心指标
- ✅ PeekView 展开延迟 <300ms
- ✅ AI 首字输出 <500ms
- ✅ 智能选区准确率 >95%
- ✅ 知识点匹配准确率 >90%

### 体验指标
- ✅ 从选中到查看解释 <3次点击
- ✅ ESC 即可关闭返回编码
- ✅ 不影响正常编码体验

## 9. 待确认问题

1. **PeekView 实现方式**：需要技术验证后确定最终方案
2. **AI 服务选择**：使用哪个 AI 服务商？
3. **知识点 API 格式**：需要与 web-learner 协商接口

## 10. 后续优化方向（Future）

记录但暂不实现：
- 渐进式信息展示（需要本地模型）
- 上下文感知（根据项目类型调整）
- 学习路径追踪（个人知识图谱）
- 团队代码集共享