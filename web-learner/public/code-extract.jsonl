{"id": "js-sec-1-1-1", "title": "变量声明（var/let/const）", "code": "// 1. 使用 let 声明一个名为 message 的变量\n// 2. 将字符串 \"Hello, World!\" 赋值给它\nlet message = \"Hello, World!\";\n\n// 3. 使用 console.log 在控制台打印出 message 变量的内容\nconsole.log(message);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-1-变量声明（var-let-const）.md", "blockIndex": 0}
{"id": "js-sec-1-1-1", "title": "变量声明（var/let/const）", "code": "// 使用 let 声明的变量可以被修改\nlet userAge = 25;\nconsole.log(\"初始年龄:\", userAge);\nuserAge = 26; // 重新赋值\nconsole.log(\"更新后年龄:\", userAge);\n\n// 使用 const 声明的常量不能被修改\nconst birthYear = 1998;\nconsole.log(\"出生年份:\", birthYear);\n// 尝试修改 const 变量会导致错误\n// birthYear = 1999; // 取消这行注释会报错: TypeError: Assignment to constant variable.", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-1-变量声明（var-let-const）.md", "blockIndex": 1}
{"id": "js-sec-1-1-1", "title": "变量声明（var/let/const）", "code": "function checkScope() {\n  // var 声明的变量在整个函数内都有效\n  var functionScopedVar = \"我在函数内部\";\n  \n  if (true) {\n    // let 和 const 声明的变量只在这个 if 代码块内有效\n    let blockScopedLet = \"我只在 if 块内部\";\n    const blockScopedConst = \"我也是\";\n    console.log(functionScopedVar); // 可以访问\n    console.log(blockScopedLet);   // 可以访问\n  }\n\n  console.log(functionScopedVar); // 仍然可以访问\n  // console.log(blockScopedLet); // 在块外部访问会报错: ReferenceError: blockScopedLet is not defined\n}\n\ncheckScope();", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-1-变量声明（var-let-const）.md", "blockIndex": 2}
{"id": "js-sec-1-1-1", "title": "变量声明（var/let/const）", "code": "console.log(\"=== 错误用法 (使用 var) ===\");\n// ❌ var 存在变量提升，可以在声明前访问，值为 undefined，容易造成逻辑混乱\nconsole.log(\"在声明前访问 var 变量:\", oldVar); // 输出: undefined\nvar oldVar = \"这是一个旧的变量\";\n\n// ❌ var 允许在同一作用域内重复声明，可能会无意中覆盖重要变量\nvar oldVar = \"被重新声明并覆盖了！\";\nconsole.log(\"重复声明后:\", oldVar);\n\n\nconsole.log(\"\\n=== 正确用法 (使用 let/const) ===\");\n// ✅ let 在声明前访问会直接报错（暂时性死区 TDZ），让错误更早暴露\n// console.log(newLet); // 取消注释会报错: ReferenceError: Cannot access 'newLet' before initialization\nlet newLet = \"这是一个新的变量\";\nconsole.log(\"在声明后访问 let 变量:\", newLet);\n\n// ✅ let 不允许在同一作用域内重复声明，代码更安全\n// let newLet = \"尝试再次声明\"; // 取消注释会报错: SyntaxError: Identifier 'newLet' has already been declared", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-1-变量声明（var-let-const）.md", "blockIndex": 3}
{"id": "js-sec-1-1-1", "title": "变量声明（var/let/const）", "code": "function calculateOrderTotal(items) {\n  // 税率是固定不变的，使用 const 声明，防止被意外修改\n  const TAX_RATE = 0.08; \n  \n  // 订单总价初始为0，后续需要累加，使用 let 声明\n  let subtotal = 0;\n\n  console.log(\"开始计算总价...\");\n  \n  items.forEach(item => {\n    console.log(`处理商品: ${item.name}, 价格: ${item.price}, 数量: ${item.quantity}`);\n    subtotal += item.price * item.quantity;\n  });\n  \n  console.log(`商品小计: ${subtotal.toFixed(2)}`);\n  \n  const taxAmount = subtotal * TAX_RATE;\n  console.log(`税额 (税率 ${TAX_RATE * 100}%): ${taxAmount.toFixed(2)}`);\n  \n  const finalTotal = subtotal + taxAmount;\n  \n  return finalTotal.toFixed(2);\n}\n\n// 模拟购物车中的商品\nconst cartItems = [\n  { name: \"笔记本\", price: 1200, quantity: 1 },\n  { name: \"鼠标\", price: 80, quantity: 2 }\n];\n\nconst total = calculateOrderTotal(cartItems);\nconsole.log(`最终订单总额: ¥${total}`);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-1-变量声明（var-let-const）.md", "blockIndex": 4}
{"id": "js-sec-1-1-2", "title": "基本数据类型（number/string/boolean）", "code": "// 1. number: 用于表示任何数字，包括整数和浮点数\nconst userAge = 28;\n\n// 2. string: 用于表示文本，必须用引号（单引号' '或双引号\" \"）包裹\nconst userName = \"Alice\";\n\n// 3. boolean: 用于表示逻辑上的“是”或“非”，只有两个值：true 和 false\nconst isLoggedIn = true;\n\nconsole.log(\"姓名:\", userName, \"类型:\", typeof userName); // string\nconsole.log(\"年龄:\", userAge, \"类型:\", typeof userAge); // number\nconsole.log(\"登录状态:\", isLoggedIn, \"类型:\", typeof isLoggedIn); // boolean", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-2-基本数据类型（number-string-boolean）.md", "blockIndex": 0}
{"id": "js-sec-1-1-2", "title": "基本数据类型（number/string/boolean）", "code": "const price = 19.99; // 浮点数\nconst quantity = 3; // 整数\n\n// 执行数学运算\nconst total = price * quantity;\nconsole.log(`商品总价: ${total}`);\n\n// 无效运算会得到 NaN\nconst invalidCalculation = 0 / 0;\nconsole.log(`0除以0的结果是: ${invalidCalculation}`); // NaN\nconsole.log(`NaN的数据类型仍然是: ${typeof invalidCalculation}`); // number", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-2-基本数据类型（number-string-boolean）.md", "blockIndex": 1}
{"id": "js-sec-1-1-2", "title": "基本数据类型（number/string/boolean）", "code": "const platform = 'Web';\nconst course = \"JavaScript\";\nconst welcomeMessage = `欢迎学习 ${platform} ${course} 教程!`; // 使用反引号嵌入变量\n\nconsole.log(\"使用单引号:\", platform);\nconsole.log(\"使用双引号:\", course);\nconsole.log(\"使用反引号（模板字符串）:\", welcomeMessage);\n\n// 使用 + 号进行字符串拼接\nconst traditionalMessage = \"欢迎学习 \" + platform + \" \" + course + \" 教程!\";\nconsole.log(\"使用+号拼接:\", traditionalMessage);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-2-基本数据类型（number-string-boolean）.md", "blockIndex": 2}
{"id": "js-sec-1-1-2", "title": "基本数据类型（number/string/boolean）", "code": "// 完整的对比示例，包含所有必要的变量定义\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误：将数字和字符串数字相加\n// 解释：当 `+` 操作符的一侧是字符串时，它会执行字符串拼接，而不是数学加法。\nconst stringNumber = \"50\";\nconst actualNumber = 100;\nconst wrongSum = stringNumber + actualNumber; \nconsole.log(`\"50\" + 100 的结果是: \"${wrongSum}\"`); // 结果是字符串 \"50100\"\nconsole.log(`错误结果的类型是: ${typeof wrongSum}`);\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确：在计算前将字符串显式转换为数字\n// 解释：使用 `parseInt()` 或 `Number()` 函数将字符串转换为数字，以确保执行数学运算。\nconst stringToConvert = \"50\";\nconst anotherNumber = 100;\n// 使用 parseInt() 将字符串转换为整数\nconst correctSum = parseInt(stringToConvert) + anotherNumber;\nconsole.log(`parseInt(\"50\") + 100 的结果是: ${correctSum}`); // 结果是数字 150\nconsole.log(`正确结果的类型是: ${typeof correctSum}`);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-2-基本数据类型（number-string-boolean）.md", "blockIndex": 3}
{"id": "js-sec-1-1-2", "title": "基本数据类型（number/string/boolean）", "code": "/**\n * 检查用户是否有资格享受折扣\n * @param {string} userName - 用户名\n * @param {string} userAgeString - 用户年龄（通常从输入框获取，为字符串类型）\n * @param {boolean} isMember - 用户是否为会员\n */\nfunction checkDiscountEligibility(userName, userAgeString, isMember) {\n  console.log(`正在检查用户: ${userName}`);\n\n  // 步骤 1: 将字符串类型的年龄转换为 number 类型\n  const age = parseInt(userAgeString);\n\n  // 步骤 2: 使用 boolean 和 number 类型进行逻辑判断\n  // 青年折扣条件：18-24岁 且 是会员\n  const isYouth = age >= 18 && age <= 24;\n  // 长者折扣条件：65岁及以上 且 是会员\n  const isSenior = age >= 65;\n  \n  let finalMessage = \"\";\n\n  // 步骤 3: 根据布尔判断结果，生成不同的字符串消息\n  if (isMember && (isYouth || isSenior)) {\n    finalMessage = `恭喜, ${userName}! 您符合我们的折扣条件。`;\n  } else {\n    finalMessage = `抱歉, ${userName}, 您暂时不符合我们的特别折扣条件。`;\n  }\n  \n  console.log(finalMessage);\n}\n\n// --- 模拟不同用户场景 ---\n// 场景1: 符合青年折扣的会员\ncheckDiscountEligibility(\"Tom\", \"22\", true);\n\nconsole.log(\"---\");\n\n// 场景2: 年龄符合但不是会员，无法享受折扣\ncheckDiscountEligibility(\"Jerry\", \"70\", false);\n\nconsole.log(\"---\");\n\n// 场景3: 不符合年龄条件的会员\ncheckDiscountEligibility(\"Mary\", \"35\", true);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-2-基本数据类型（number-string-boolean）.md", "blockIndex": 4}
{"id": "js-sec-1-1-3", "title": "特殊值（null/undefined/NaN）", "code": "// 1. 变量声明了但没有赋值，它的值就是 undefined\nlet uninitializedValue;\nconsole.log(\"未赋值的变量:\", uninitializedValue);\n\n// 2. 当我们想明确表示一个变量是“空”的，可以赋值为 null\nlet emptyValue = null;\nconsole.log(\"明确设置的空值:\", emptyValue);\n\n// 3. 当进行无效的数学运算时，会得到 NaN (Not-a-Number)\nlet notANumber = 0 / 0;\nconsole.log(\"无效数学运算的结果:\", notANumber);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-3-特殊值（null-undefined-NaN）.md", "blockIndex": 0}
{"id": "js-sec-1-1-3", "title": "特殊值（null/undefined/NaN）", "code": "// 场景1: 变量声明后未赋值，默认为 undefined\nlet name;\nconsole.log(\"变量'name'的值:\", name); // undefined\n\n// 场景2: 函数没有明确返回值，默认返回 undefined\nfunction doNothing() {\n  // 没有 return 语句\n}\nlet functionResult = doNothing();\nconsole.log(\"函数'doNothing'的返回值:\", functionResult); // undefined\n\n// 场景3: 手动将一个变量设置为空，比如释放一个对象引用\nlet user = { name: \"Alice\" };\nconsole.log(\"user对象:\", user);\n// 假设用户登出，我们可以将 user 设置为 null\nuser = null;\nconsole.log(\"登出后的user:\", user); // null", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-3-特殊值（null-undefined-NaN）.md", "blockIndex": 1}
{"id": "js-sec-1-1-3", "title": "特殊值（null/undefined/NaN）", "code": "// 任何涉及NaN的数学运算，结果都是NaN\nlet result = 10 + NaN;\nconsole.log(\"10 + NaN =\", result);\n\n// NaN 不等于任何东西，包括它自己\nlet isEqualToItself = (NaN === NaN);\nconsole.log(\"NaN === NaN ?\", isEqualToItself); // false\n\n// 正确检查NaN的方法是使用 Number.isNaN()\nlet invalidCalculation = \"hello\" * 5;\nconsole.log(\"'hello' * 5 =\", invalidCalculation);\nconsole.log(\"使用 Number.isNaN() 检查:\", Number.isNaN(invalidCalculation)); // true", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-3-特殊值（null-undefined-NaN）.md", "blockIndex": 2}
{"id": "js-sec-1-1-3", "title": "特殊值（null/undefined/NaN）", "code": "// 准备测试变量\nlet a; // undefined\nlet b = null;\nlet c = \"hello\" - 1; // NaN\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误1: 试图用 === 检查 NaN\n// 这永远不会为 true，因为 NaN 不等于任何东西。\nif (c === NaN) {\n  console.log(\"错误检查：c 是 NaN\");\n} else {\n  console.log(\"错误检查：c 不是 NaN (结果不符合预期)\");\n}\n// ❌ 错误2: 使用 == 检查 null，虽然能同时匹配到 undefined，但可能导致逻辑模糊\n// `b == null` (true) 和 `a == null` (true) 都为真，有时这并非我们想要的精确判断\nif (a == null) {\n    console.log(`使用 '=='，undefined 被视为了 null`);\n}\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确1: 使用 Number.isNaN() 来检查 NaN\nif (Number.isNaN(c)) {\n  console.log(\"正确检查：c 是 NaN\");\n}\n// ✅ 正确2: 使用严格相等运算符 === 来精确判断 null 或 undefined\nif (a === undefined) {\n  console.log(\"精确检查：a 是 undefined\");\n}\nif (b === null) {\n  console.log(\"精确检查：b 是 null\");\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-3-特殊值（null-undefined-NaN）.md", "blockIndex": 3}
{"id": "js-sec-1-1-3", "title": "特殊值（null/undefined/NaN）", "code": "/**\n * 处理从API获取的用户数据，并返回一个友好的欢迎信息。\n * API返回的数据可能不完整。\n * @param {object} userData - 可能包含 name 和 age 的用户数据对象\n * @returns {string} 欢迎信息\n */\nfunction generateWelcomeMessage(userData) {\n  // 检查 userData 是否存在，如果为 null 或 undefined，则提供默认信息\n  if (userData === null || userData === undefined) {\n    return \"欢迎，游客！\";\n  }\n\n  // 获取用户名，如果不存在(undefined)，则使用默认值 '神秘用户'\n  const name = userData.name || '神秘用户';\n  \n  // 尝试将 age 转换为数字。如果 age 字段不存在或格式错误，parseInt 会返回 NaN\n  const age = parseInt(userData.age, 10);\n  \n  let ageInfo = \"\";\n  // 使用 Number.isNaN() 来判断年龄是否有效\n  if (!Number.isNaN(age)) {\n    ageInfo = `，你的年龄是 ${age} 岁。`;\n  } else {\n    ageInfo = \"，你的年龄未知。\";\n  }\n\n  return `你好，${name}${ageInfo}`;\n}\n\n// 模拟各种API返回情况\nconst user1 = { name: \"张三\", age: \"30\" };\nconst user2 = { name: \"李四\", age: \"不是数字\" };\nconst user3 = { age: \"25\" }; // name 字段缺失 (undefined)\nconst user4 = null; // API可能返回null表示用户不存在\n\nconsole.log(generateWelcomeMessage(user1));\nconsole.log(generateWelcomeMessage(user2));\nconsole.log(generateWelcomeMessage(user3));\nconsole.log(generateWelcomeMessage(user4));\nconsole.log(generateWelcomeMessage(undefined));", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-3-特殊值（null-undefined-NaN）.md", "blockIndex": 4}
{"id": "js-sec-1-1-4", "title": "类型检测与转换", "code": "// Level 1: 隐式类型转换\nlet score = 99;\nlet unit = \"分\";\n\n// 当数字和字符串相加时，数字 `score` 会被自动转换为字符串 \"99\"\nlet message = \"你的分数是：\" + score + unit;\n\nconsole.log(message);\nconsole.log(\"message 的类型是:\", typeof message); // 'string'\nconsole.log(\"score 的原始类型是:\", typeof score); // 'number'", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-4-类型检测与转换.md", "blockIndex": 0}
{"id": "js-sec-1-1-4", "title": "类型检测与转换", "code": "// Level 2, Feature 1: `typeof` operator\nlet age = 25;              // 数字\nlet name = \"Alice\";        // 字符串\nlet isLoggedIn = false;    // 布尔\nlet user;                  // 未定义\nlet settings = null;       // null (空对象指针)\nlet profile = { id: 1 };   // 对象\n\nconsole.log(`typeof 25:`, typeof age);\nconsole.log(`typeof \"Alice\":`, typeof name);\nconsole.log(`typeof false:`, typeof isLoggedIn);\nconsole.log(`typeof user:`, typeof user);\nconsole.log(`typeof { id: 1 }`, typeof profile);\n\n// 注意一个著名的JavaScript怪异之处：\nconsole.log(`typeof null:`, typeof settings); // 输出 \"object\"，这是一个历史遗留问题", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-4-类型检测与转换.md", "blockIndex": 1}
{"id": "js-sec-1-1-4", "title": "类型检测与转换", "code": "// Level 2, Feature 2: Explicit Conversion\n\n// 1. 转换为数字 (Number)\nlet pageStr = \"10\";\nlet pageNum = Number(pageStr);\nconsole.log(`Number(\"10\") ->`, pageNum, `类型:`, typeof pageNum);\n\nlet invalidStr = \"hello\";\nlet invalidNum = Number(invalidStr);\nconsole.log(`Number(\"hello\") ->`, invalidNum, `类型:`, typeof invalidNum); // NaN (Not-a-Number)\n\n// 2. 转换为字符串 (String)\nlet status = 200;\nlet statusStr = String(status);\nconsole.log(`String(200) ->`, `\"${statusStr}\"`, `类型:`, typeof statusStr);\n\n// 3. 转换为布尔 (Boolean)\n// 只有 0, -0, \"\", null, undefined, NaN 会转为 false，其他都为 true\nlet zero = 0;\nlet emptyStr = \"\";\nlet hasValue = \"text\";\nconsole.log(`Boolean(0) ->`, Boolean(zero));\nconsole.log(`Boolean(\"\") ->`, Boolean(emptyStr));\nconsole.log(`Boolean(\"text\") ->`, Boolean(hasValue));", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-4-类型检测与转换.md", "blockIndex": 2}
{"id": "js-sec-1-1-4", "title": "类型检测与转换", "code": "// Level 3: Loose vs. Strict Equality\nlet numberValue = 10;\nlet stringValue = \"10\";\n\nconsole.log(\"=== 错误用法 (可能导致意外行为) ===\");\n// ❌ 使用 `==` (宽松相等) 会进行隐式类型转换，可能隐藏bug\nif (numberValue == stringValue) {\n  console.log(`'10 == \"10\"' is TRUE. 因为 \"10\" 被自动转换成了数字 10。`);\n} else {\n  console.log(`'10 == \"10\"' is FALSE.`);\n}\n// 解释: '==' 在比较前会尝试将两个操作数转换为相同类型。这在需要严格区分数字和字符串的场景下非常危险。\n\nconsole.log(\"\\n=== 正确用法 (推荐) ===\");\n// ✅ 使用 `===` (严格相等) 不会进行类型转换，类型和值都必须相等\nif (numberValue === stringValue) {\n  console.log(`'10 === \"10\"' is TRUE.`);\n} else {\n  console.log(`'10 === \"10\"' is FALSE. 因为它们的类型不同 (number vs string)。`);\n}\n// 解释: '===' 要求值和类型都完全相同，因此是更安全、更可预测的比较方式。", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-4-类型检测与转换.md", "blockIndex": 3}
{"id": "js-sec-1-1-4", "title": "类型检测与转换", "code": "// Level 4: Real-world scenario - processing form input\n\n/**\n * 模拟一个检查商品库存的函数\n * @param {string} quantityInput - 从输入框获取的购买数量，总是字符串\n * @param {number} stockAvailable - 当前的库存数量，是数字\n */\nfunction checkStock(quantityInput, stockAvailable) {\n  console.log(`用户想购买: \"${quantityInput}\" (类型: ${typeof quantityInput})`);\n  console.log(`当前库存: ${stockAvailable} (类型: ${typeof stockAvailable})`);\n\n  // 1. 将输入的字符串转换为数字\n  const quantityToBuy = Number(quantityInput);\n\n  // 2. 验证转换后的值是否是一个有效的数字\n  if (isNaN(quantityToBuy)) {\n    console.log(\"错误：请输入有效的购买数量！\");\n    return;\n  }\n  \n  // 3. 验证数量是否为正数\n  if (quantityToBuy <= 0) {\n    console.log(\"错误：购买数量必须大于0！\");\n    return;\n  }\n\n  // 4. 现在可以安全地进行数字比较\n  if (quantityToBuy <= stockAvailable) {\n    console.log(`成功！库存充足，可以购买 ${quantityToBuy} 件。`);\n  } else {\n    console.log(`抱歉，库存不足。仅剩 ${stockAvailable} 件。`);\n  }\n}\n\n// 场景1: 用户输入有效的数字字符串\ncheckStock(\"5\", 10);\n\nconsole.log(\"\\n------------------\\n\");\n\n// 场景2: 用户输入了无效的字符串\ncheckStock(\"五个\", 10);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-4-类型检测与转换.md", "blockIndex": 4}
{"id": "js-sec-1-1-5", "title": "作用域与提升", "code": "// 1. 我们先调用函数，就像我们知道它已经存在一样\nsayHello();\n\n// 2. 然后我们才在代码的下方真正地声明这个函数\nfunction sayHello() {\n  console.log(\"你好，提升！我被成功调用了，即使我的声明在后面。\");\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-5-作用域与提升.md", "blockIndex": 0}
{"id": "js-sec-1-1-5", "title": "作用域与提升", "code": "// 函数声明被完整提升\nconsole.log(\"函数 magician:\", typeof magician); // 输出: 'function'\nmagician(); // 输出: \"🎩✨ Abra Kadabra!\"\n\n// var 变量声明被提升，但赋值没有\nconsole.log(\"变量 assistant:\", assistant); // 输出: undefined\n// 下一行如果取消注释会报错 TypeError: assistant is not a function\n// assistant(); \n\nfunction magician() {\n  console.log(\"🎩✨ Abra Kadabra!\");\n}\n\nvar assistant = function() {\n  console.log(\"🐰 我是一只从帽子里出来的兔子！\");\n};\n\nconsole.log(\"赋值后的 assistant:\", typeof assistant); // 输出: 'function'\nassistant(); // 输出: \"🐰 我是一只从帽子里出来的兔子！\"", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-5-作用域与提升.md", "blockIndex": 1}
{"id": "js-sec-1-1-5", "title": "作用域与提升", "code": "{ // 创建一个块级作用域\n  // console.log(secretCode); // 取消此行注释将抛出 ReferenceError\n  // 👆 这里是 secretCode 的“暂时性死区”\n\n  let secretCode = \"1337\"; // 声明并初始化\n  \n  console.log(\"成功访问密码:\", secretCode); // 输出: \"成功访问密码: 1337\"\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-5-作用域与提升.md", "blockIndex": 2}
{"id": "js-sec-1-1-5", "title": "作用域与提升", "code": "// 完整的对比示例，包含所有必要的变量定义\nfunction checkInventory() {\n  console.log(\"=== 错误用法 (使用 var) ===\");\n  // ❌ 错误：我们以为 potion 是存在的，但它只是一个 undefined 的“幽灵”\n  // 这可能导致程序在后续逻辑中出现意想不到的错误。\n  console.log(\"检查药水库存:\", potion); // 输出: undefined\n  if (potion) {\n    console.log(\"库存充足！\");\n  } else {\n    console.log(\"库存为空或未定义！\"); // 这行会被执行\n  }\n  var potion = \"生命药水\";\n  console.log(\"药水已入库:\", potion); // 输出: \"生命药水\"\n}\n\ncheckInventory();\n\nconsole.log(\"\\n\");\n\nfunction checkInventorySecure() {\n  console.log(\"=== 正确用法 (使用 let) ===\");\n  // ✅ 正确：尝试在声明前访问，会立即得到一个清晰的错误。\n  // 这强制我们必须先声明再使用，代码更健壮。\n  try {\n    console.log(elixir); \n  } catch (error) {\n    console.error(\"💥 错误! 'elixir' 在声明前无法访问。\");\n    console.error(\"这是暂时性死区(TDZ)在保护我们！\");\n  }\n  \n  let elixir = \"法力药剂\";\n  console.log(\"药剂已入库:\", elixir); // 输出: \"法力药剂\"\n}\n\ncheckInventorySecure();", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-5-作用域与提升.md", "blockIndex": 3}
{"id": "js-sec-1-1-5", "title": "作用域与提升", "code": "// 🚀 时间旅行控制台 🚀\n\n// 我们的主时间跳跃程序，由于函数提升，它在整个“时间线”（我们的代码）中都是可知的。\n// 即使我们在代码底部定义它，我们也可以在顶部调用它。\ninitiateTimeJump();\n\n// --- 时间旅行参数设定区 ---\n// 警告：targetYear 存在于“暂时性死区”中，直到它被声明！\n// 这模拟了我们必须先设定目标，才能进行计算的物理定律。\nconst currentYear = 2024;\nconst targetYear = 1985; // 目标：《回到未来》的年份！\n\n/**\n * @description 启动时间跳跃的核心函数\n * 这个函数声明被“提升”了，所以我们可以在文件顶部调用它。\n */\nfunction initiateTimeJump() {\n  console.log(\"⏳ 正在初始化时间机器...\");\n  \n  // 检查目标年份是否已在当前时间点被定义。\n  // 由于我们的代码结构是正确的（先声明再调用），这里可以安全访问 targetYear。\n  // 如果我们把 targetYear 的声明放到 initiateTimeJump() 调用之后，就会触发 ReferenceError。\n  try {\n    const timeDifference = targetYear - currentYear;\n    console.log(`✅ 时间坐标锁定：${targetYear}`);\n    console.log(`⏱️ 计算时间跨度... ${Math.abs(timeDifference)} 年。`);\n    \n    if (timeDifference > 0) {\n      console.log(`🚀 准备进行未来跳跃！`);\n    } else {\n      console.log(`⏪ 准备回到过去！`);\n    }\n    console.log(\"⚡️ 时间引擎启动... 跳跃成功！\");\n\n  } catch (error) {\n    // 这个 catch 块是为了演示如果 targetYear 在 TDZ 中会发生什么。\n    // 在当前这个可运行的例子中，因为我们正确地先声明了 targetYear，所以不会触发 error。\n    console.error(\"💥 时空悖论警告! 无法在设定目标年份之前进行计算。\");\n    console.error(\"错误详情:\", error.message);\n  }\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-1-5-作用域与提升.md", "blockIndex": 4}
{"id": "js-sec-1-2-1", "title": "算术运算符", "code": "// Level 1: 基础算术运算\n\nlet apples = 10;\nlet oranges = 5;\n\n// 加法 (+)\nlet totalFruits = apples + oranges;\nconsole.log(\"水果总数:\", totalFruits); // 输出: 15\n\n// 减法 (-)\nlet difference = apples - oranges;\nconsole.log(\"苹果比橘子多的数量:\", difference); // 输出: 5\n\n// 乘法 (*)\nlet applePrice = 3;\nlet totalCost = apples * applePrice;\nconsole.log(\"买10个苹果需要:\", totalCost); // 输出: 30\n\n// 除法 (/)\nlet friends = 2;\nlet applesPerFriend = apples / friends;\nconsole.log(\"每个朋友分到几个苹果:\", applesPerFriend); // 输出: 5", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-1-算术运算符.md", "blockIndex": 0}
{"id": "js-sec-1-2-1", "title": "算术运算符", "code": "// Level 2, 特性1: 取模、自增、自减\n\n// --- 取模 % ---\nlet totalCandies = 25;\nlet kids = 4;\nlet remainingCandies = totalCandies % kids;\nconsole.log(`25颗糖分给4个孩子，每人分6颗后，还剩下 ${remainingCandies} 颗。`); // 输出: 1\n\nlet number = 10;\nconsole.log(`10是偶数吗? (10 % 2 === 0):`, number % 2 === 0); // 输出: true\n\n// --- 自增 ++ 与 自减 -- ---\nlet playerLevel = 5;\nconsole.log(\"初始等级:\", playerLevel); // 输出: 5\n\nplayerLevel++; // 等级提升\nconsole.log(\"升级后:\", playerLevel); // 输出: 6\n\nlet bombsRemaining = 3;\nconsole.log(\"初始炸弹数:\", bombsRemaining); // 输出: 3\n\nbombsRemaining--; // 使用一个炸弹\nconsole.log(\"使用后:\", bombsRemaining); // 输出: 2", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-1-算术运算符.md", "blockIndex": 1}
{"id": "js-sec-1-2-1", "title": "算术运算符", "code": "// Level 2, 特性2: 运算符优先级\n\n// --- 默认优先级 ---\n// 乘法 (*) 的优先级高于加法 (+)\nlet score = 10 + 5 * 2; // 会先计算 5 * 2\nconsole.log(\"默认优先级计算结果:\", score); // 输出: 20 (而不是30)\n\n// --- 使用括号 () 控制优先级 ---\n// 括号内的表达式会最先计算\nlet correctScore = (10 + 5) * 2; // 先计算 10 + 5\nconsole.log(\"使用括号控制优先级:\", correctScore); // 输出: 30", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-1-算术运算符.md", "blockIndex": 2}
{"id": "js-sec-1-2-1", "title": "算术运算符", "code": "// Level 3: 对比学习 - 加法 vs. 字符串拼接\n\nconsole.log(\"=== 错误用法 ❌ ===\");\nlet scoreString = \"100\"; // 这是一个字符串，不是数字\nlet bonus = 50;\nlet wrongTotal = scoreString + bonus;\nconsole.log(\"错误的结果:\", wrongTotal); // 输出: \"10050\"\nconsole.log(\"错误结果的类型:\", typeof wrongTotal); // 输出: \"string\"\n// 解释: 当 '+' 的任意一边是字符串时，它会执行拼接操作，\n// 把数字 50 也转换成字符串 \"50\"，然后将它们连接起来。\n\nconsole.log(\"\\n=== 正确用法 ✅ ===\");\nlet scoreNumber = Number(\"100\"); // 使用 Number() 将字符串转为数字\nlet correctTotal = scoreNumber + bonus;\nconsole.log(\"正确的结果:\", correctTotal); // 输出: 150\nconsole.log(\"正确结果的类型:\", typeof correctTotal); // 输出: \"number\"\n// 解释: 在进行数学运算前，确保所有操作数都是数字类型。\n// Number() 是一个将其他类型转换为数字的常用函数。", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-1-算术运算符.md", "blockIndex": 3}
{"id": "js-sec-1-2-1", "title": "算术运算符", "code": "// Level 4: 游戏角色升级系统\n\n// 1. 角色初始状态\nlet player = {\n  name: \"代码勇者\",\n  level: 1,\n  xp: 0,\n  health: 100,\n  attack: 10,\n  xpToNextLevel: 150 // 升到下一级需要的总经验\n};\n\nconsole.log(`冒险开始！${player.name} Lv.${player.level} 踏上了征程！`);\nconsole.log(\"--- 初始状态 ---\", player);\n\n// 2. 击败怪物，获得经验值\nlet monsterXP = 85;\nconsole.log(`\\n💥 ${player.name} 击败了一只史莱姆，获得了 ${monsterXP} 点经验值!`);\nplayer.xp = player.xp + monsterXP; // 使用加法增加经验值\n\n// 3. 检查是否可以升级\n// 使用除法和取模来计算升级后的状态\nif (player.xp >= player.xpToNextLevel) {\n  console.log(\"\\n🎉 经验值满了！叮！升级！🎉\");\n  \n  // 计算溢出的经验值\n  let remainingXP = player.xp % player.xpToNextLevel;\n  \n  // 升级\n  player.level++; // 使用自增运算符提升等级\n  player.xp = remainingXP;\n  \n  // 升级后属性提升，使用乘法和加法\n  player.health = player.health + 20;\n  player.attack = player.attack + 5;\n  player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.5); // 下一级所需经验增加50%\n\n  console.log(\"--- 升级后状态 ---\", player);\n} else {\n  let xpNeeded = player.xpToNextLevel - player.xp; // 使用减法计算还差多少经验\n  console.log(`\\n距离下一级还差 ${xpNeeded} 点经验值，继续努力！`);\n  console.log(\"--- 当前状态 ---\", player);\n}\n\n// 4. 再次击败怪物\nlet bossXP = 120;\nconsole.log(`\\n💥 ${player.name} 奋力击败了哥布林首领，获得了 ${bossXP} 点经验值!`);\nplayer.xp += bossXP; // += 是 player.xp = player.xp + bossXP 的简写\n\nif (player.xp >= player.xpToNextLevel) {\n    console.log(\"\\n🎉 再次升级！你变得更强了！🎉\");\n    player.level++;\n    player.xp %= player.xpToNextLevel;\n    player.health += 25;\n    player.attack += 7;\n    player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.5);\n    console.log(\"--- 最新状态 ---\", player);\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-1-算术运算符.md", "blockIndex": 4}
{"id": "js-sec-1-2-2", "title": "比较运算符（==/===）", "code": "// Level 1: 基础认知\n\nlet appleCount = 5;\nlet orangeCount = 5;\nlet pearCount = 10;\n\n// 使用严格相等 ===\nconsole.log(\"苹果和橘子的数量相等吗？\", appleCount === orangeCount); // true, 因为值和类型都相同 (5 === 5)\nconsole.log(\"苹果和梨的数量相等吗？\", appleCount === pearCount);   // false, 因为值不同 (5 === 10)", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-2-比较运算符（==-===）.md", "blockIndex": 0}
{"id": "js-sec-1-2-2", "title": "比较运算符（==/===）", "code": "// Level 2, 特性1: 宽松相等 (==)\n\nlet ticketNumber = 123; // 数字类型\nlet ticketId = '123';   // 字符串类型\n\n// 使用宽松相等 ==\n// JavaScript发现类型不同，会尝试将字符串 '123' 转换为数字 123，然后再比较。\nconsole.log(\"票号和票ID匹配吗? (使用 ==)\");\nconsole.log(ticketNumber == ticketId); // true, 因为 '123' 被转换成了 123\n\nlet hasItem = 1; // 1 通常代表 \"有\"\nlet userConfirmed = true; // true 也代表 \"有\"\n\n// 1 会被认为是 \"truthy\"，在比较时被转换为 true\nconsole.log(\"物品存在与用户确认状态一致吗? (使用 ==)\");\nconsole.log(hasItem == userConfirmed); // true", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-2-比较运算符（==-===）.md", "blockIndex": 1}
{"id": "js-sec-1-2-2", "title": "比较运算符（==/===）", "code": "// Level 2, 特性2: 严格相等 (===)\n\nlet securityCodeNumber = 404; // 数字类型\nlet errorCodeString = '404';  // 字符串类型\n\n// 使用严格相等 ===\n// JavaScript发现一个是 number，一个是 string，类型不同，直接返回 false，不会尝试转换。\nconsole.log(\"安全码和错误码一致吗? (使用 ===)\");\nconsole.log(securityCodeNumber === errorCodeString); // false, 因为类型不同\n\nlet itemsInCart = 0; // 购物车里有0件商品\nlet cartIsEmpty = false; // 购物车不是空的\n\n// 0 和 false 在类型上完全不同\nconsole.log(\"商品数量为0等同于购物车为空吗? (使用 ===)\");\nconsole.log(itemsInCart === cartIsEmpty); // false", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-2-比较运算符（==-===）.md", "blockIndex": 2}
{"id": "js-sec-1-2-2", "title": "比较运算符（==/===）", "code": "// Level 3: 对比学习\n\nlet userInput = ''; // 用户没有输入任何内容\nlet score = 0;      // 玩家得分为0\n\nconsole.log(\"=== 错误用法 (使用 ==) ===\");\n// ❌ 陷阱: 使用 == 时，空字符串 '' 和数字 0 都会被转换为 false\nconsole.log(`'' == false  ->  ${'' == false}`); // true, 意料之外！\nconsole.log(`0 == false   ->  ${0 == false}`);  // true, 意料之外！\n\n// 如果你想检查用户的输入是否真的是布尔值 false，用 == 会产生误判\nif (userInput == false) {\n    console.log(\"❌ 错误：程序误以为用户输入了'false'，但其实用户只是没输入内容。\");\n}\n\nconsole.log(\"\\n=== 正确用法 (使用 ===) ===\");\n// ✅ 最佳实践: 使用 === 进行精确比较，避免类型转换带来的不确定性\nconsole.log(`'' === false ->  ${'' === false}`); // false, 类型不同\nconsole.log(`0 === false  ->  ${0 === false}`);  // false, 类型不同\n\n// 这样，只有当变量的值确实是布尔值 false 时，条件才会成立\nlet explicitlyFalse = false;\nif (explicitlyFalse === false) {\n    console.log(\"✅ 正确：只有当值严格等于 false 时，这里的代码才会执行。\");\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-2-比较运算符（==-===）.md", "blockIndex": 3}
{"id": "js-sec-1-2-2", "title": "比较运算符（==/===）", "code": "// Level 4: 星际解码器\n\nconst ANCIENT_KEY = 777; // 遗迹的正确能量密钥是数字777\n\nfunction activateDevice(receivedSignal) {\n    console.log(`\\n--- 接收到信号: ${receivedSignal} (类型: ${typeof receivedSignal}) ---`);\n\n    // 协议1: \"宽容模式\" (使用 ==)\n    // 这个模式下，系统会尝试理解信号，即使格式不完全正确。\n    if (receivedSignal == ANCIENT_KEY) {\n        console.log(\"✅ [宽容模式]：信号能量值匹配！遗迹大门缓缓打开... ✨\");\n    } else {\n        console.log(\"❌ [宽容模式]：信号无法识别。\");\n    }\n\n    // 协议2: \"高安全模式\" (使用 ===)\n    // 这个模式要求信号的格式和值都必须完美匹配，防止任何意外的激活。\n    if (receivedSignal === ANCIENT_KEY) {\n        console.log(\"✅ [高安全模式]：精确匹配！纯净的能量信号！系统已激活！🚀\");\n    } else {\n        console.log(\"❌ [高安全模式]：信号类型或值不匹配！安全系统拒绝访问。🚨\");\n    }\n}\n\n// 模拟接收到纯数字信号\nlet pureSignal = 777;\nactivateDevice(pureSignal);\n\n// 模拟接收到因宇宙射线干扰而变成的文本信号\nlet corruptedSignal = '777';\nactivateDevice(corruptedSignal);\n\n// 模拟接收到完全错误的信号\nlet wrongSignal = 123;\nactivateDevice(wrongSignal);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-2-比较运算符（==-===）.md", "blockIndex": 4}
{"id": "js-sec-1-2-3", "title": "逻辑运算符（&&/||/!）", "code": "// Level 1: 基础认知\n\n// && (与): 两个都为 true, 结果才是 true\nconst isSunny = true;\nconst haveTime = true;\nconst canGoOut = isSunny && haveTime;\nconsole.log(`天气晴朗并且我有空吗? ${canGoOut}`); // 输出: true\n\n// || (或): 只要有一个为 true, 结果就是 true\nconst isRaining = false;\nconst wantToStayHome = true;\nconst willStayHome = isRaining || wantToStayHome;\nconsole.log(`下雨了或者我想宅家吗? ${willStayHome}`); // 输出: true\n\n// ! (非): 取反\nconst isStudent = false;\nconst isNotStudent = !isStudent;\nconsole.log(`我不是学生吗? ${isNotStudent}`); // 输出: true", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-3-逻辑运算符（&&-||-!）.md", "blockIndex": 0}
{"id": "js-sec-1-2-3", "title": "逻辑运算符（&&/||/!）", "code": "// 特性1: 短路求值\n\nconsole.log(\"--- && 短路演示 ---\");\n// 因为 false 是第一个操作数，JS 知道结果必为 false，\n// 所以根本不会去执行后面的 console.log('我不会被打印')\nconst resultAnd = false && console.log('我不会被打印');\nconsole.log(\"&& 的结果:\", resultAnd); // 输出: false\n\nconsole.log(\"\\n--- || 短路演示 ---\");\n// 因为 \"你好\" 是一个“真值”，JS 知道结果必为 true，\n// 所以它立刻返回 \"你好\"，后面的代码同样不会执行。\nconst resultOr = \"你好\" || console.log('我也不会被打印');\nconsole.log(\"|| 的结果:\", resultOr); // 输出: \"你好\"", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-3-逻辑运算符（&&-||-!）.md", "blockIndex": 1}
{"id": "js-sec-1-2-3", "title": "逻辑运算符（&&/||/!）", "code": "// 特性2: 返回值不一定是布尔值\n\n// 场景: 用户名可能为空，如果为空，我们提供一个默认值\nlet userName = \"\"; // 用户名为空字符串，这是一个“假值”\nlet defaultName = \"游客\";\n// userName 是假值，所以 || 运算会继续，并返回后面的 \"游客\"\nlet displayName = userName || defaultName;\nconsole.log(`欢迎你, ${displayName}!`); // 输出: 欢迎你, 游客!\n\n// 如果用户名不为空\nlet realUserName = \"Alice\"; // 这是一个“真值”\n// realUserName 是真值，|| 运算发生“短路”，直接返回 \"Alice\"\nlet welcomeMessage = realUserName || defaultName;\nconsole.log(`欢迎你, ${welcomeMessage}!`); // 输出: 欢迎你, Alice!\n\n// && 的例子：只有当用户已登录，才显示欢迎信息\nconst isLoggedIn = true;\nconst userProfile = { name: \"Bob\" };\n// isLoggedIn 是真值，所以 && 运算继续，并返回后面的 userProfile.name\nconst greeting = isLoggedIn && userProfile.name;\nconsole.log(`问候语: ${greeting}`); // 输出: 问候语: Bob", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-3-逻辑运算符（&&-||-!）.md", "blockIndex": 2}
{"id": "js-sec-1-2-3", "title": "逻辑运算符（&&/||/!）", "code": "// Level 3: 对比学习\n\nconst score = 75;\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误: 这种写法在 JavaScript 中不会按预期工作\n// 它会先计算 60 < score (结果是 true)，然后计算 true < 90。\n// 在比较中，true会被转换为1，所以表达式变成了 1 < 90，结果是 true。\n// 即使 score 是 100，60 < 100 (true)，true < 90 (true)，结果依然是 true，这显然是错的。\nconst isGoodScoreWrong = 60 < score < 90;\nconsole.log(`分数 ${score} 在 60 到 90 之间吗? (错误方式): ${isGoodScoreWrong}`);\n// 让我们用一个边界外的分数测试\nconst anotherScore = 120;\nconst isGoodScoreWrong2 = 60 < anotherScore < 90;\nconsole.log(`分数 ${120} 在 60 到 90 之间吗? (错误方式): ${isGoodScoreWrong2}`); // 结果仍然是 true!\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确: 必须使用逻辑与 && 将两个独立的比较连接起来\n// 检查 score > 60 AND score < 90\nconst isGoodScoreCorrect = score > 60 && score < 90;\nconsole.log(`分数 ${score} 在 60 到 90 之间吗? (正确方式): ${isGoodScoreCorrect}`);\n// 用边界外的分数再次测试\nconst anotherScoreCorrect = 120;\nconst isGoodScoreCorrect2 = anotherScoreCorrect > 60 && anotherScoreCorrect < 90;\nconsole.log(`分数 ${120} 在 60 到 90 之间吗? (正确方式): ${isGoodScoreCorrect2}`); // 结果是 false，正确！", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-3-逻辑运算符（&&-||-!）.md", "blockIndex": 3}
{"id": "js-sec-1-2-3", "title": "逻辑运算符（&&/||/!）", "code": "// Level 4: 飞船跳跃安全检查\n\nfunction checkHyperspaceJump(engineStatus, navComputerOnline, shieldLevel, asteroidsNear, isDocked) {\n  console.log(\"--- 开始进行超光速跳跃前置检查 ---\");\n  console.log(`引擎状态: ${engineStatus} | 导航系统: ${navComputerOnline ? '在线' : '离线'} | 护盾: ${shieldLevel}% | 附近有小行星: ${asteroidsNear ? '是' : '否'} | 是否已停靠: ${isDocked ? '是' : '否'}`);\n\n  // 核心安全条件：引擎必须'stable'，并且导航电脑必须在线\n  const coreSystemsOK = engineStatus === 'stable' && navComputerOnline;\n  if (!coreSystemsOK) {\n    console.log(\"❌ 跳跃取消！核心系统未就绪（引擎或导航问题）。\");\n    return;\n  }\n  \n  // 危险规避条件：护盾必须是满的(100) 或者 附近没有小行星\n  const hazardAvoidanceOK = shieldLevel === 100 || !asteroidsNear;\n  if (!hazardAvoidanceOK) {\n    console.log(\"❌ 跳跃取消！危险规避系统警告（护盾未满且附近有小行星）。\");\n    return;\n  }\n  \n  // 最终状态检查：飞船不能处于停靠状态\n  const finalStateOK = !isDocked;\n  if (!finalStateOK) {\n    console.log(\"❌ 跳跃取消！飞船仍在空间站停靠，请先脱离。\");\n    return;\n  }\n  \n  // 综合所有条件进行最终判断\n  if (coreSystemsOK && hazardAvoidanceOK && finalStateOK) {\n    console.log(\"✅ 所有检查通过！引力驱动器正在充能...准备进行超光速跳跃！🚀✨\");\n  } else {\n    // 理论上，上面的if判断已经覆盖了所有失败情况，但作为保险措施\n    console.log(\"❌ 未知错误，跳跃程序中止。\");\n  }\n}\n\n// 场景1: 一切完美，准备出发！\ncheckHyperspaceJump('stable', true, 100, false, false);\n\nconsole.log(\"\\n========================================\\n\");\n\n// 场景2: 护盾不满，但周围安全，也可以跳跃\ncheckHyperspaceJump('stable', true, 80, false, false);\n\nconsole.log(\"\\n========================================\\n\");\n\n// 场景3: 导航系统离线，跳跃失败\ncheckHyperspaceJump('stable', false, 100, false, false);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-3-逻辑运算符（&&-||-!）.md", "blockIndex": 4}
{"id": "js-sec-1-2-4", "title": "赋值运算符", "code": "// 声明一个名为 playerScore 的变量，并使用赋值运算符 = 将值 0 赋给它\nlet playerScore = 0;\nconsole.log(\"玩家初始分数:\", playerScore);\n\n// 更新 playerScore 的值\nplayerScore = 100;\nconsole.log(\"玩家获得奖励后分数:\", playerScore);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-4-赋值运算符.md", "blockIndex": 0}
{"id": "js-sec-1-2-4", "title": "赋值运算符", "code": "// 场景：一个简单的游戏角色生命值管理\nlet health = 100;\nconsole.log(\"初始生命值:\", health);\n\n// 角色喝了治疗药水，生命值增加 20\n// health = health + 20; 的简写形式\nhealth += 20;\nconsole.log(\"喝了药水后:\", health); // 输出 120\n\n// 角色被怪物攻击，生命值减少 30\n// health = health - 30; 的简写形式\nhealth -= 30;\nconsole.log(\"被攻击后:\", health); // 输出 90\n\n// 角色触发了“双倍伤害”状态，攻击力翻倍\nlet attackPower = 15;\nconsole.log(\"初始攻击力:\", attackPower);\nattackPower *= 2; // attackPower = attackPower * 2;\nconsole.log(\"双倍伤害后:\", attackPower); // 输出 30", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-4-赋值运算符.md", "blockIndex": 1}
{"id": "js-sec-1-2-4", "title": "赋值运算符", "code": "// 场景：初始化多个游戏计数器\nlet score, kills, assists;\n\n// 将 0 同时赋值给 assists, kills, 和 score\n// 过程：首先 0 赋给 assists，然后 assists 的值(0)赋给 kills，最后 kills 的值(0)赋给 score\nscore = kills = assists = 0;\n\nconsole.log(\"初始分数:\", score);      // 输出: 0\nconsole.log(\"初始击杀数:\", kills);    // 输出: 0\nconsole.log(\"初始助攻数:\", assists);  // 输出: 0", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-4-赋值运算符.md", "blockIndex": 2}
{"id": "js-sec-1-2-4", "title": "赋值运算符", "code": "// 假设我们需要检查玩家等级是否为 10\nlet playerLevel = 5;\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误：在 if 条件中使用了赋值运算符 =\n// 这行代码的意思是“将 10 赋值给 playerLevel”，这个赋值表达式本身的结果是 10，\n// 在 JavaScript 中，非零数字会被转换为 true，所以这个 if 条件永远为真！\nif (playerLevel = 10) {\n  console.log(\"❌ 错误地进入了判断，现在玩家等级变成了:\", playerLevel);\n}\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确：使用严格相等运算符 === 进行比较\nlet correctPlayerLevel = 5;\nif (correctPlayerLevel === 10) {\n  console.log(\"✅ 玩家等级是 10，可以学习新技能！\");\n} else {\n  console.log(\"✅ 玩家等级不是 10 (当前是 \" + correctPlayerLevel + \")，还不能学习新技能。\");\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-4-赋值运算符.md", "blockIndex": 3}
{"id": "js-sec-1-2-4", "title": "赋值运算符", "code": "// 角色初始状态\nlet heroName = \"Code勇者\";\nlet level = 1;\nlet experience = 0;\nlet gold = 50;\nlet mana = 100;\n\nconsole.log(`🌟 ${heroName} 开始了他的冒险之旅！等级: ${level}, 经验: ${experience}, 金币: ${gold}, 法力: ${mana}`);\nconsole.log(\"----------------------------------------\");\n\n// --- 战斗 1: 遭遇史莱姆 ---\nconsole.log(\"战斗开始！遭遇了一只软弱的史莱姆！\");\nlet slimeExp = 15;\nlet slimeGold = 3;\nexperience += slimeExp; // 获得经验 (experience = experience + 15)\ngold += slimeGold;     // 获得金币 (gold = gold + 3)\nconsole.log(`战斗胜利！获得 ${slimeExp} 点经验和 ${slimeGold} 个金币。`);\nconsole.log(`当前状态 - 经验: ${experience}, 金币: ${gold}`);\nconsole.log(\"----------------------------------------\");\n\n// --- 战斗 2: 遭遇哥布林 ---\nconsole.log(\"战斗继续！遭遇了一只狡猾的哥布林！\");\nconsole.log(`勇者决定使用火球术！当前法力: ${mana}`);\nlet fireballCost = 30;\nmana -= fireballCost; // 消耗法力 (mana = mana - 30)\nconsole.log(`🔥 释放火球术！消耗 ${fireballCost} 点法力。剩余法力: ${mana}`);\n\nlet goblinExp = 40;\nlet goblinGold = 10;\nexperience += goblinExp;\ngold += goblinGold;\nconsole.log(`哥布林被击败！获得 ${goblinExp} 点经验和 ${goblinGold} 个金币。`);\nconsole.log(`当前状态 - 经验: ${experience}, 金币: ${gold}`);\nconsole.log(\"----------------------------------------\");\n\n// --- 检查是否升级 ---\nlet expToNextLevel = 50;\nif (experience >= expToNextLevel) {\n  level++; // 等级提升 (level = level + 1)\n  experience -= expToNextLevel; // 扣除升级所需经验\n  console.log(`🎉 恭喜！${heroName} 升级了！当前等级: ${level}`);\n  console.log(`升级后剩余经验: ${experience}`);\n} else {\n  console.log(`还差 ${expToNextLevel - experience} 点经验才能升级。`);\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-4-赋值运算符.md", "blockIndex": 4}
{"id": "js-sec-1-2-5", "title": "条件运算符（三元）", "code": "// 检查天气是否下雨\nconst isRaining = true;\n\n// 如果 isRaining 是 true，则带上 'umbrella'\n// 否则，带上 'sunglasses'\nconst itemToBring = isRaining ? 'umbrella' : 'sunglasses';\n\nconsole.log(`天气状况: ${isRaining ? '下雨' : '晴天'}`);\nconsole.log(`我应该带上: ${itemToBring}`);\n// 输出:\n// 天气状况: 下雨\n// 我应该带上: umbrella", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-5-条件运算符（三元）.md", "blockIndex": 0}
{"id": "js-sec-1-2-5", "title": "条件运算符（三元）", "code": "// 场景：根据用户年龄判断电影票价\nconst userAge = 15;\n\n// 如果年龄小于18岁，票价为5美元；否则为10美元\nconst ticketPrice = userAge < 18 ? 5 : 10;\n\nconsole.log(`你的年龄是 ${userAge} 岁，票价是 ${ticketPrice} 美元。`);\n\n// 另一个例子\nconst anotherUserAge = 25;\nconst anotherTicketPrice = anotherUserAge < 18 ? 5 : 10;\nconsole.log(`你的年龄是 ${anotherUserAge} 岁，票价是 ${anotherTicketPrice} 美元。`);\n// 输出:\n// 你的年龄是 15 岁，票价是 5 美元。\n// 你的年龄是 25 岁，票价是 10 美元。", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-5-条件运算符（三元）.md", "blockIndex": 1}
{"id": "js-sec-1-2-5", "title": "条件运算符（三元）", "code": "// 场景：生成一条欢迎消息\nfunction welcomeMessage(isLoggedIn) {\n  // 直接在 return 语句中使用三元运算符\n  return `你好, ${isLoggedIn ? '尊贵的用户' : '游客'}!`;\n}\n\n// 模拟用户已登录\nconst userIsLoggedIn = true;\nconsole.log(welcomeMessage(userIsLoggedIn));\n\n// 模拟用户未登录\nconst guestIsLoggedIn = false;\nconsole.log(welcomeMessage(guestIsLoggedIn));\n// 输出:\n// 你好, 尊贵的用户!\n// 你好, 游客!", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-5-条件运算符（三元）.md", "blockIndex": 2}
{"id": "js-sec-1-2-5", "title": "条件运算符（三元）", "code": "// 场景：根据分数给出评价\nconst score = 85;\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误：过度嵌套，可读性极差\n// 试图用三元运算符取代复杂的 if-else if-else 结构\nconst complexResult = score > 90 ? '优秀' : (score > 75 ? '良好' : (score > 60 ? '及格' : '不及格'));\nconsole.log(`你的评价是: ${complexResult}`); // 虽然能工作，但难以阅读和维护\n// 解释：当条件超过一个时，嵌套的三元运算符会像俄罗斯套娃一样，让代码变得混乱不堪，一眼很难看出逻辑分支。\n\nconsole.log(\"=== 正确用法 ===\");\n// ✅ 正确：对于复杂的逻辑分支，使用 if...else if...else 语句\nlet simpleResult;\nif (score > 90) {\n  simpleResult = '优秀';\n} else if (score > 75) {\n  simpleResult = '良好';\n} else if (score > 60) {\n  simpleResult = '及格';\n} else {\n  simpleResult = '不及格';\n}\nconsole.log(`你的评价是: ${simpleResult}`);\n// 解释：代码更长，但结构清晰，逻辑一目了然，更易于未来的修改和调试。对于简单二选一，才推荐使用三元运算符。", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-5-条件运算符（三元）.md", "blockIndex": 3}
{"id": "js-sec-1-2-5", "title": "条件运算符（三元）", "code": "// 你的虚拟宠物\nconst pet = {\n  name: \"代码猫\",\n  species: \"🐱\"\n};\n\n// 函数：检查宠物状态\nfunction checkPetStatus(isFed) {\n  console.log(`你来看望你的宠物 ${pet.name} ${pet.species} 了...`);\n\n  // 使用三元运算符决定宠物的心情\n  const mood = isFed ? \"心满意足\" : \"饥肠辘辘\";\n  \n  // 使用三元运算符决定宠物的叫声\n  const sound = isFed ? \"喵~ ❤️ (满足地打呼噜)\" : \"喵呜... 肚子咕咕叫 😢\";\n\n  // 使用三元运算符决定宠物的行为\n  const action = isFed ? \"蹭了蹭你的腿\" : \"可怜巴巴地看着空食盆\";\n\n  console.log(`它的心情: ${mood}`);\n  console.log(`它发出了声音: ${sound}`);\n  console.log(`它的行为: ${action}`);\n  console.log(\"--------------------\");\n}\n\n// 场景1: 你喂了你的宠物\nconsole.log(\"--- 场景1: 你记得喂食 ---\");\ncheckPetStatus(true);\n\n// 场景2: 你忘记喂宠物了\nconsole.log(\"--- 场景2: 你忘记喂食了 ---\");\ncheckPetStatus(false);\n// 输出:\n// --- 场景1: 你记得喂食 ---\n// 你来看望你的宠物 代码猫 🐱 了...\n// 它的心情: 心满意足\n// 它发出了声音: 喵~ ❤️ (满足地打呼噜)\n// 它的行为: 蹭了蹭你的腿\n// --------------------\n// --- 场景2: 你忘记喂食了 ---\n// 你来看望你的宠物 代码猫 🐱 了...\n// 它的心情: 饥肠辘辘\n// 它发出了声音: 喵呜... 肚子咕咕叫 😢\n// 它的行为: 可怜巴巴地看着空食盆\n// --------------------", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-5-条件运算符（三元）.md", "blockIndex": 4}
{"id": "js-sec-1-2-6", "title": "运算符优先级", "code": "// 声明两个变量\nlet a = 10;\nlet b = 5;\n\n// 猜猜结果是多少？\n// JavaScript会先计算 3 * b (3 * 5 = 15)\n// 然后再计算 a + 15 (10 + 15 = 25)\nlet result = a + 3 * b;\n\nconsole.log(`计算 10 + 3 * 5 的结果是: ${result}`); // 输出: 25", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-6-运算符优先级.md", "blockIndex": 0}
{"id": "js-sec-1-2-6", "title": "运算符优先级", "code": "// 定义一些数字\nlet initialValue = 100;\nlet divisor = 10;\nlet multiplier = 2;\n\n// 1. 先从左到右计算 100 / 10，得到 10\n// 2. 然后计算 10 * 2，得到 20\nlet result = initialValue / divisor * multiplier;\n\nconsole.log(`100 / 10 * 2 的计算顺序是从左到右，结果是: ${result}`); // 输出: 20", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-6-运算符优先级.md", "blockIndex": 1}
{"id": "js-sec-1-2-6", "title": "运算符优先级", "code": "// 同样的数字，不同的结果\nlet apples = 5;\nlet oranges = 10;\nlet friends = 2;\n\n// 不使用括号，会先算 oranges * friends\nlet wrongCalculation = apples + oranges * friends;\nconsole.log(`不加括号：5 + 10 * 2 = ${wrongCalculation}`); // 输出: 25\n\n// 使用括号，会先算 apples + oranges\nlet correctCalculation = (apples + oranges) * friends;\nconsole.log(`加了括号：(5 + 10) * 2 = ${correctCalculation}`); // 输出: 30\nconsole.log(\"场景：你想计算苹果和橘子的总数，然后分给2个朋友，每人一份。显然，30才是正确答案。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-6-运算符优先级.md", "blockIndex": 2}
{"id": "js-sec-1-2-6", "title": "运算符优先级", "code": "// 场景：计算三个科目的平均分\nlet mathScore = 90;\nlet englishScore = 85;\nlet scienceScore = 92;\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误：由于 / 的优先级高于 +，这里实际上是计算 90 + 85 + (92 / 3)\nlet wrongAverage = mathScore + englishScore + scienceScore / 3;\nconsole.log(`错误的平均分计算: ${wrongAverage.toFixed(2)}`);\nconsole.log(\"解释：这相当于只给科学打了折扣，而不是求三科的平均分。\");\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确：使用括号先计算总分，再除以科目数量\nlet correctAverage = (mathScore + englishScore + scienceScore) / 3;\nconsole.log(`正确的平均分计算: ${correctAverage.toFixed(2)}`);\nconsole.log(\"解释：括号确保了先求和，再求平均，这才是我们想要的逻辑。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-6-运算符优先级.md", "blockIndex": 3}
{"id": "js-sec-1-2-6", "title": "运算符优先级", "code": "// 角色属性设定\nconst characterName = \"屠龙者·阿尔法\";\nlet baseAttack = 100; // 基础攻击力\nlet weaponBonus = 1.5; // 史诗长剑提供50%的攻击力加成 (1 + 0.5)\nlet potionEffect = 20; // 喝下了一瓶力量药水，临时增加20点攻击力\n\nconsole.log(`💥 英雄【${characterName}】准备战斗！`);\nconsole.log(`基础攻击: ${baseAttack}, 武器加成: ${weaponBonus}, 药水效果: +${potionEffect}`);\nconsole.log(\"-------------------------------------\");\n\n// 错误的计算方式：没有使用括号\n// 运算顺序：potionEffect * weaponBonus 先被计算 (20 * 1.5 = 30)，然后再加上 baseAttack (100 + 30 = 130)\nlet wrongFinalAttack = baseAttack + potionEffect * weaponBonus;\nconsole.log(`❌ 计算失误！最终攻击力: ${wrongFinalAttack}`);\nconsole.log(\"😱 “糟糕！我的力量药水好像没起作用！” 阿尔法大喊。这点伤害连史莱姆的皮都破不了！\");\n\nconsole.log(\"-------------------------------------\");\n\n// 正确的计算方式：使用括号确保逻辑正确\n// 运算顺序：(baseAttack + potionEffect) 先被计算 (100 + 20 = 120)，然后再乘以 weaponBonus (120 * 1.5 = 180)\nlet correctFinalAttack = (baseAttack + potionEffect) * weaponBonus;\nconsole.log(`✅ 正确计算！最终攻击力: ${correctFinalAttack}`);\nconsole.log(`🐲 “感受我的愤怒吧！” 阿尔法一剑挥出，对巨龙造成了 ${correctFinalAttack} 点毁灭性伤害！`);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-2-6-运算符优先级.md", "blockIndex": 4}
{"id": "js-sec-1-3-1", "title": "if-else 条件判断", "code": "// 场景：检查今天是否是周末\nconst day = \"周日\";\n\nif (day === \"周六\" || day === \"周日\") {\n  console.log(\"太棒了！今天是周末，可以好好休息一下！🎉\");\n}\n\n// 输出:\n// 太棒了！今天是周末，可以好好休息一下！🎉", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-1-if-else-条件判断.md", "blockIndex": 0}
{"id": "js-sec-1-3-1", "title": "if-else 条件判断", "code": "// 场景：根据天气决定出门是否带伞\nconst weather = \"下雨\";\n\nif (weather === \"晴天\") {\n  console.log(\"天气真好，带上太阳镜出门吧！😎\");\n} else {\n  console.log(\"天有不测风云，出门记得带伞！☔️\");\n}\n\n// 输出:\n// 天有不测风云，出门记得带伞！☔️", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-1-if-else-条件判断.md", "blockIndex": 1}
{"id": "js-sec-1-3-1", "title": "if-else 条件判断", "code": "// 场景：根据分数评定等级\nconst score = 85;\n\nif (score >= 90) {\n  console.log(\"你的等级是：优秀 (A) 🌟\");\n} else if (score >= 80) {\n  console.log(\"你的等级是：良好 (B) 👍\");\n} else if (score >= 60) {\n  console.log(\"你的等级是：及格 (C) 😊\");\n} else {\n  console.log(\"你的等级是：不及格 (F) 😥，要加油哦！\");\n}\n\n// 输出:\n// 你的等级是：良好 (B) 👍", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-1-if-else-条件判断.md", "blockIndex": 2}
{"id": "js-sec-1-3-1", "title": "if-else 条件判断", "code": "// 场景：检查用户是否已登录\nlet isLoggedIn = false;\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误：在 if 条件中使用了赋值符 =\n// 这会将 isLoggedIn 的值赋为 false，然后整个表达式的结果是 false，\n// 所以 if 代码块永远不会执行。这是一个非常隐蔽的 bug！\nif (isLoggedIn = true) {\n  console.log(\"错误判断：用户已登录！\");\n} else {\n  console.log(\"错误判断：用户未登录！\");\n}\nconsole.log(`操作后 isLoggedIn 的值变为: ${isLoggedIn}`); // 值被意外修改了！\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确：使用严格相等运算符 === 进行比较\nisLoggedIn = false; // 重置变量\nif (isLoggedIn === true) {\n  console.log(\"正确判断：用户已登录！\");\n} else {\n  console.log(\"正确判断：用户未登录！\");\n}\nconsole.log(`操作后 isLoggedIn 的值保持为: ${isLoggedIn}`); // 值没有被修改\n\n// 输出:\n// === 错误用法 ===\n// 错误判断：用户已登录！\n// 操作后 isLoggedIn 的值变为: true\n//\n// === 正确用法 ===\n// 正确判断：用户未登录！\n// 操作后 isLoggedIn 的值保持为: false", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-1-if-else-条件判断.md", "blockIndex": 3}
{"id": "js-sec-1-3-1", "title": "if-else 条件判断", "code": "// 飞船能量核心诊断系统\n// 随机生成一个核心温度，模拟真实环境波动\nconst coreTemperature = Math.floor(Math.random() * 200); // 温度范围 0-199\n\nconsole.log(`--- 开拓者号舰桥日志 ---`);\nconsole.log(`🛰️ 当前能量核心温度: ${coreTemperature}°C`);\nconsole.log(\"启动诊断程序...\");\n\nif (coreTemperature > 150) {\n  // 危险情况\n  console.log(\"🚨🚨🚨 警报! 核心温度过高! 危险! 危险! 🚨🚨🚨\");\n  console.log(\"建议操作：立即启动冷却系统，并降低引擎功率！\");\n} else if (coreTemperature > 100) {\n  // 警告情况\n  console.log(\"🟡 警告：核心温度偏高，已超出安全工作范围。\");\n  console.log(\"建议操作：请密切监控，准备启动备用冷却系统。\");\n} else if (coreTemperature > 50) {\n  // 理想情况\n  console.log(\"✅ 状态正常：核心温度稳定，一切系统运行良好。\");\n  console.log(\"舰长，我们可以继续加速，探索未知的宇宙！🚀\");\n} else {\n  // 温度过低\n  console.log(\"🔵 提示：核心温度过低，能量转换效率下降。\");\n  console.log(\"建议操作：启动预热程序，将核心温度提升至最佳工作范围。\");\n}\n\nconsole.log(\"--- 诊断程序结束 ---\");\n\n// 尝试多次运行此代码块，你会看到因为随机温度的不同，会产生完全不同的输出！", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-1-if-else-条件判断.md", "blockIndex": 4}
{"id": "js-sec-1-3-2", "title": "switch-case 分支", "code": "// 假设这是自动售货机的按钮编号\nconst drinkId = 2;\nlet drinkName;\n\nswitch (drinkId) {\n  case 1:\n    drinkName = \"可乐\";\n    break;\n  case 2:\n    drinkName = \"橙汁\";\n    break;\n  case 3:\n    drinkName = \"矿泉水\";\n    break;\n  default:\n    drinkName = \"未知饮料\";\n    break;\n}\n\nconsole.log(`你选择了 ${drinkId} 号按钮，获得了: ${drinkName}`);\n// 输出: 你选择了 2 号按钮，获得了: 橙汁", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-2-switch-case-分支.md", "blockIndex": 0}
{"id": "js-sec-1-3-2", "title": "switch-case 分支", "code": "// 角色选择系统\nconst selectedRole = \"mage\"; // 尝试改成 \"warrior\" 或 \"healer\"\nlet roleDescription;\n\nswitch (selectedRole) {\n  case \"warrior\":\n    roleDescription = \"勇猛的战士，擅长近战！\";\n    break;\n\n  case \"mage\":\n    roleDescription = \"神秘的法师，掌控元素之力！\";\n    break;\n\n  default:\n    roleDescription = \"你选择了一个不存在的神秘职业，请重新选择！\";\n    break;\n}\n\nconsole.log(`角色: ${selectedRole}`);\nconsole.log(`描述: ${roleDescription}`);\n// 当 selectedRole = \"mage\" 时输出:\n// 角色: mage\n// 描述: 神秘的法师，掌控元素之力！", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-2-switch-case-分支.md", "blockIndex": 1}
{"id": "js-sec-1-3-2", "title": "switch-case 分支", "code": "// 判断今天是工作日还是周末\nconst day = \"Sunday\"; // 尝试改成 \"Monday\" 或 \"Saturday\"\nlet dayType;\n\nswitch (day) {\n  case \"Monday\":\n  case \"Tuesday\":\n  case \"Wednesday\":\n  case \"Thursday\":\n  case \"Friday\":\n    dayType = \"工作日，加油打工人！💪\";\n    break;\n  \n  case \"Saturday\":\n  case \"Sunday\":\n    dayType = \"周末，好好休息一下！🎉\";\n    break;\n  \n  default:\n    dayType = \"这是一个无效的日期...\";\n    break;\n}\n\nconsole.log(`${day} 是: ${dayType}`);\n// 当 day = \"Sunday\" 时输出:\n// Sunday 是: 周末，好好休息一下！🎉", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-2-switch-case-分支.md", "blockIndex": 2}
{"id": "js-sec-1-3-2", "title": "switch-case 分支", "code": "// 场景：根据用户等级授予权限\nconst userLevel = \"admin\"; // 设定用户等级\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误：忘记在每个 case 后写 break\nlet permissions_wrong = [];\nswitch (userLevel) {\n  case \"admin\":\n    permissions_wrong.push(\"删除用户\"); // admin应该只有这个权限\n  case \"editor\":\n    permissions_wrong.push(\"编辑文章\"); // editor应该只有这个权限\n  case \"viewer\":\n    permissions_wrong.push(\"查看内容\"); // viewer应该只有这个权限\n}\nconsole.log(`[错误] admin 的权限: ${permissions_wrong.join(', ')}`);\n// 输出: [错误] admin 的权限: 删除用户, 编辑文章, 查看内容\n// 解释：因为没有 break，代码从 case \"admin\" 开始，一直执行到 switch 结束，导致 admin 意外获得了所有权限。\n\nconsole.log(\"=== 正确用法 ===\");\n// ✅ 正确：在每个 case 结束时使用 break\nlet permissions_right = [];\nswitch (userLevel) {\n  case \"admin\":\n    permissions_right.push(\"删除用户\");\n    break; // 阻止代码继续向下执行\n  case \"editor\":\n    permissions_right.push(\"编辑文章\");\n    break;\n  case \"viewer\":\n    permissions_right.push(\"查看内容\");\n    break;\n}\nconsole.log(`[正确] admin 的权限: ${permissions_right.join(', ')}`);\n// 输出: [正确] admin 的权限: 删除用户\n// 解释：break 像一道闸门，执行完当前 case 的代码后立即跳出 switch 结构，确保了权限的正确分配。", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-2-switch-case-分支.md", "blockIndex": 3}
{"id": "js-sec-1-3-2", "title": "switch-case 分支", "code": "/**\n * 虚拟宠物心情模拟器函数\n * @param {string} mood - 宠物当前的心情关键词 ('happy', 'hungry', 'sleepy', 'bored')\n * @returns {string} - 代表宠物状态和心情的字符串\n */\nfunction getPetStatus(mood) {\n  let petResponse = \"\";\n\n  console.log(`主人，你感知到宠物的最新心情是: \"${mood}\"`);\n\n  switch (mood) {\n    case 'happy':\n      petResponse = \"(ﾉ◕ヮ◕)ﾉ*:･ﾟ✧ 摇着尾巴，蹭了蹭你，开心到冒泡！\";\n      break;\n    \n    case 'hungry':\n      petResponse = \"( T _ T ) 肚子咕咕叫，可怜巴巴地看着你，好像在说“我饿了”。\";\n      break;\n      \n    case 'sleepy':\n      petResponse = \"(=￣ ρ￣=) ..zzZZ 打了个大大的哈欠，眼睛都快睁不开了。\";\n      break;\n      \n    case 'bored':\n      petResponse = \"(︶︹︺) 无聊地趴在地上画圈圈，需要你的关注！\";\n      break;\n      \n    case 'playful':\n      petResponse = \"٩(ˊᗜˋ*)و 叼着玩具球跑到你脚边，眼神充满期待！\";\n      break;\n\n    default:\n      petResponse = \"(⊙_⊙)? 歪着头，不明白你说的“\" + mood + \"”是什么意思。\";\n      break;\n  }\n  \n  return `【宠物状态更新】 -> ${petResponse}`;\n}\n\n// --- 让我们和宠物互动吧！ ---\n// 尝试改变 currentMood 的值，看看宠物的不同反应\nlet currentMood = 'hungry'; \nconsole.log(getPetStatus(currentMood));\n\ncurrentMood = 'happy';\nconsole.log(getPetStatus(currentMood));\n\ncurrentMood = 'confused'; // 一个它听不懂的词\nconsole.log(getPetStatus(currentMood));", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-2-switch-case-分支.md", "blockIndex": 4}
{"id": "js-sec-1-3-3", "title": "for 循环", "code": "// Level 1: 基础认知\n// 这是一个简单的 for 循环，它会执行5次。\nconsole.log(\"循环开始！\");\n\nfor (let i = 0; i < 5; i++) {\n  // 这部分代码会被重复执行\n  console.log(`这是第 ${i + 1} 次问好：你好！`);\n}\n\nconsole.log(\"循环结束！\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-3-for-循环.md", "blockIndex": 0}
{"id": "js-sec-1-3-3", "title": "for 循环", "code": "// Level 2, 特性1: 自定义循环控制\n\nconsole.log(\"--- 倒数计时 ---\");\n// 从 5 倒数到 1\nfor (let i = 5; i > 0; i--) {\n  console.log(`倒计时: ${i}`);\n}\nconsole.log(\"发射！🚀\");\n\n\nconsole.log(\"\\n--- 打印偶数 ---\");\n// 从 0 到 10，只打印偶数 (每次 i 增加 2)\nfor (let i = 0; i <= 10; i = i + 2) {\n  console.log(`这是一个偶数: ${i}`);\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-3-for-循环.md", "blockIndex": 1}
{"id": "js-sec-1-3-3", "title": "for 循环", "code": "// Level 2, 特性2: 遍历数组\n\nconst fruits = [\"🍎 苹果\", \"🍌 香蕉\", \"🍊 橘子\", \"🍇 葡萄\"];\nconsole.log(\"我喜欢的水果有：\");\n\n// 使用 for 循环遍历 fruits 数组\n// 数组的索引从 0 开始，所以循环条件是 i < fruits.length\nfor (let i = 0; i < fruits.length; i++) {\n  const fruit = fruits[i];\n  console.log(`- ${fruit}`);\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-3-for-循环.md", "blockIndex": 2}
{"id": "js-sec-1-3-3", "title": "for 循环", "code": "// Level 3: 对比学习\n\nconst pets = [\"🐶 狗\", \"🐱 猫\", \"🐰 兔\"];\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误：循环条件使用了 <= array.length\n// 数组索引是从 0 到 2 (length - 1)。当 i 等于 3 (pets.length) 时，\n// pets[3] 是 undefined，因为那个位置没有元素。\nfor (let i = 0; i <= pets.length; i++) {\n  console.log(`索引 ${i}:`, pets[i]);\n}\nconsole.log(\"注意：最后一次输出了 undefined，这是个bug！\");\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确：循环条件使用 < array.length\n// 这样循环会在 i 等于 3 时停止，不会尝试访问不存在的 pets[3]。\n// 循环的最后一次是 i = 2，访问的是 pets[2]，完全正确。\nfor (let i = 0; i < pets.length; i++) {\n  console.log(`索引 ${i}:`, pets[i]);\n}\nconsole.log(\"完美！所有宠物都正确打印了。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-3-for-循环.md", "blockIndex": 3}
{"id": "js-sec-1-3-3", "title": "for 循环", "code": "// Level 4: 游戏场景 - 菜鸟勇者的升级之路\n\n// 1. 定义我们的勇者\nlet hero = {\n  name: \"菜鸟勇者\",\n  level: 1,\n  xp: 0,\n  hp: 100\n};\n\n// 2. 定义升级所需经验\nconst xpToLevelUp = 100;\nconst monstersToFight = 5;\n\nconsole.log(`冒险开始！${hero.name} (等级 ${hero.level}, 经验 ${hero.xp}) 踏上了征程！`);\nconsole.log(`前方出现了 ${monstersToFight} 只史莱姆！`);\n\n// 3. 使用 for 循环模拟连续战斗\nfor (let i = 1; i <= monstersToFight; i++) {\n  const xpGained = Math.floor(Math.random() * 10) + 15; // 每只史莱姆提供15-24点经验\n  hero.xp += xpGained;\n\n  console.log(`💥 第 ${i} 场战斗：击败史莱姆！获得 ${xpGained} 点经验。当前总经验: ${hero.xp}`);\n\n  // 4. 检查是否可以升级\n  if (hero.xp >= xpToLevelUp) {\n    hero.level++;\n    hero.xp -= xpToLevelUp; // 减去升级消耗的经验\n    hero.hp += 50; // 升级奖励：生命值增加\n    console.log(`🎉 叮！光芒闪耀！${hero.name} 升到了 ${hero.level} 级！生命值恢复并提升！`);\n  }\n}\n\nconsole.log(`\\n战斗结束！${hero.name} 的最终状态：等级 ${hero.level}, 经验 ${hero.xp}, 生命值 ${hero.hp}`);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-3-for-循环.md", "blockIndex": 4}
{"id": "js-sec-1-3-4", "title": "while/do-while 循环", "code": "// 场景：一个机器人需要充电，直到电量达到3格\nlet batteryLevel = 0;\nconsole.log(\"🔋 机器人开始充电...\");\n\n// 当电量小于3时，继续循环\nwhile (batteryLevel < 3) {\n  batteryLevel = batteryLevel + 1; // 充一格电\n  console.log(\"充电中... 当前电量:\", batteryLevel, \"格\");\n}\n\nconsole.log(\"✅ 充电完成！机器人满血复活！\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-4-while-do-while-循环.md", "blockIndex": 0}
{"id": "js-sec-1-3-4", "title": "while/do-while 循环", "code": "console.log(\"--- 场景: 门口有保安的派对 ---\");\n\n// (1) 使用 while 循环：先检查邀请函\nlet hasInvitation = false; // 你没有邀请函\nconsole.log(\"你走向派对门口，保安拦住了你...\");\n\nwhile (hasInvitation) {\n  // 这个代码块永远不会执行，因为 hasInvitation 一开始就是 false\n  console.log(\"进入派对，开始狂欢！\");\n}\nconsole.log(\"保安：'抱歉，没有邀请函不能进入。' -> while 循环体未执行。\");\n\n\n// (2) 使用 do-while 循环：先进场再查票\nlet isInsideClub = false;\nconsole.log(\"\\n你走向另一个俱乐部，这里的规矩是先进场...\");\n\ndo {\n  // 这个代码块会先执行一次\n  console.log(\"你溜进了俱乐部，感受了一下气氛！\");\n  isInsideClub = true; // 假设你进去了\n} while (isInsideClub === false); // 然后保安发现你没票，条件为 false，循环结束\n\nconsole.log(\"保安：'嘿！你没票！' -> do-while 循环体至少执行了一次。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-4-while-do-while-循环.md", "blockIndex": 1}
{"id": "js-sec-1-3-4", "title": "while/do-while 循环", "code": "// 场景：在一堆箱子里寻找神秘宝藏\nlet boxesToSearch = 10;\nlet currentBox = 1;\nconst treasureBox = 5; // 宝藏在第5个箱子里\n\nconsole.log(\"开始寻宝！一共有\", boxesToSearch, \"个箱子。\");\n\nwhile (currentBox <= boxesToSearch) {\n  console.log(\"正在打开第\", currentBox, \"个箱子...\");\n  \n  if (currentBox === treasureBox) {\n    console.log(\"💎 找到了！宝藏就在这个箱子里！停止搜索！\");\n    break; // 找到宝藏，立即跳出 while 循环\n  }\n  \n  currentBox++; // 继续检查下一个箱子\n}\n\nconsole.log(\"寻宝结束。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-4-while-do-while-循环.md", "blockIndex": 2}
{"id": "js-sec-1-3-4", "title": "while/do-while 循环", "code": "console.log(\"=== 错误用法 ===\");\n// ❌ 错误: 忘记更新循环条件变量\n// 这会导致 i 永远是 0， i < 3 永远为 true，循环永不停止。\n// 为了防止你的浏览器崩溃，我们用一个“安全阀”来强制退出。\nlet i = 0;\nlet safetyCounter = 0;\nwhile (i < 3) {\n  console.log(\"这是一个无限循环的警告！i 的值是:\", i);\n  // 错误点：没有 i++ 或任何改变 i 值的代码\n  \n  safetyCounter++;\n  if (safetyCounter > 5) {\n    console.log(\"!!! 安全阀启动，强制退出无限循环！\");\n    break;\n  }\n}\nconsole.log(\"如果没有安全阀，程序会一直卡在这里。\");\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确: 在循环体内确保更新条件变量\nlet j = 0;\nwhile (j < 3) {\n  console.log(\"循环正常进行中, j 的值是:\", j);\n  j++; // 关键步骤：每次循环都让 j 增加，确保循环最终会结束\n}\nconsole.log(\"循环正常结束。j 的最终值是:\", j);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-4-while-do-while-循环.md", "blockIndex": 3}
{"id": "js-sec-1-3-4", "title": "while/do-while 循环", "code": "// 场景：你是一位勇敢的冒险者，遇到了一只史莱姆！\nconsole.log(\"⚔️ 一场战斗开始！你遇到了一只黏糊糊的史莱姆！\");\n\n// 1. 初始化角色和怪物状态\nlet heroHP = 100;\nlet slimeHP = 50;\nlet round = 0;\n\n// 2. 使用 do-while 保证战斗至少进行一回合\ndo {\n  round++;\n  console.log(`\\n--- 第 ${round} 回合 ---`);\n\n  // 英雄攻击\n  const heroAttack = Math.floor(Math.random() * 20) + 10; // 造成 10-29 点伤害\n  slimeHP -= heroAttack;\n  console.log(`你对史莱姆造成了 ${heroAttack} 点伤害！史莱姆剩余 HP: ${Math.max(0, slimeHP)}`);\n\n  // 检查史莱姆是否存活\n  if (slimeHP <= 0) {\n    console.log(\"史莱姆被击败了！\");\n    break; // 怪物死亡，跳出循环\n  }\n\n  // 史莱姆攻击\n  const slimeAttack = Math.floor(Math.random() * 15) + 5; // 造成 5-19 点伤害\n  heroHP -= slimeAttack;\n  console.log(`史莱姆反击，对你造成了 ${slimeAttack} 点伤害！你的剩余 HP: ${Math.max(0, heroHP)}`);\n  \n  // 检查英雄是否存活\n  if (heroHP <= 0) {\n    console.log(\"你被史莱姆击败了...\");\n    break; // 英雄死亡，跳出循环\n  }\n\n// 3. 循环条件：只要双方都还活着，战斗就继续\n} while (heroHP > 0 && slimeHP > 0);\n\nconsole.log(\"\\n--- 战斗结束 ---\");\nif (heroHP > 0) {\n  console.log(\"🏆 胜利！你获得了战斗的胜利！\");\n} else {\n  console.log(\"☠️ 失败... 请再接再厉。\");\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-4-while-do-while-循环.md", "blockIndex": 4}
{"id": "js-sec-1-3-5", "title": "break/continue 控制", "code": "// 游戏规则：从1数到10，但数到5时就停止游戏\nconsole.log(\"数数游戏开始！\");\n\nfor (let i = 1; i <= 10; i++) {\n  console.log(\"当前数字是: \" + i);\n  if (i === 5) {\n    console.log(\"啊哈！找到5了，游戏结束！\");\n    break; // 立刻跳出整个 for 循环\n  }\n}\n\nconsole.log(\"游戏已停止。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-5-break-continue-控制.md", "blockIndex": 0}
{"id": "js-sec-1-3-5", "title": "break/continue 控制", "code": "// 在一堆宝箱里寻找传说中的“JS圣杯”\nconst treasureChests = [\"木箱\", \"铁箱\", \"金箱\", \"JS圣杯\", \"银箱\"];\nlet found = false;\n\nconsole.log(\"开始寻宝！\");\nfor (let i = 0; i < treasureChests.length; i++) {\n  console.log(`正在打开第 ${i + 1} 个宝箱: ${treasureChests[i]}`);\n  if (treasureChests[i] === \"JS圣杯\") {\n    found = true;\n    console.log(\"找到了！就是它！不用再找了！\");\n    break; // 找到目标，立刻停止搜索，提高效率\n  }\n}\n\nif (found) {\n  console.log(\"任务完成，带着圣杯回家！\");\n} else {\n  console.log(\"很遗憾，没有找到圣杯。\");\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-5-break-continue-控制.md", "blockIndex": 1}
{"id": "js-sec-1-3-5", "title": "break/continue 控制", "code": "// 加工水果，但跳过所有“烂苹果”\nconst fruits = [\"好苹果\", \"香蕉\", \"烂苹果\", \"橘子\", \"好苹果\"];\nconst processedFruits = [];\n\nconsole.log(\"开始加工水果...\");\nfor (let i = 0; i < fruits.length; i++) {\n  const currentFruit = fruits[i];\n  if (currentFruit === \"烂苹果\") {\n    console.log(`发现一个 ${currentFruit}，扔掉！不加工！`);\n    continue; // 跳过本次循环，不执行下面的 push 操作\n  }\n  \n  console.log(`正在加工: ${currentFruit}`);\n  processedFruits.push(currentFruit);\n}\n\nconsole.log(\"加工完成！最终得到的水果:\", processedFruits);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-5-break-continue-控制.md", "blockIndex": 2}
{"id": "js-sec-1-3-5", "title": "break/continue 控制", "code": "// 完整的对比示例，包含所有必要的变量定义\nfunction findItem(items, target) {\n  console.log(\"=== 错误用法 ===\");\n  // ❌ 错误: 'break' statement not in an iteration or switch statement\n  // 下面的代码会直接导致语法错误，无法运行。\n  // 我们用注释来解释这个错误。\n  /*\n    if (items[0] === target) {\n      break; // 语法错误！这里没有循环\n    }\n    console.log(\"这将永远不会被执行\");\n  */\n  console.log(\"❌ 错误演示：不能在没有循环的地方直接使用 break。这会导致 SyntaxError。\");\n\n\n  console.log(\"\\n=== 正确用法 ===\");\n  // ✅ 正确: 在 for 循环内部使用 break\n  let found = false;\n  for (let i = 0; i < items.length; i++) {\n    console.log(`检查物品: ${items[i]}`);\n    if (items[i] === target) {\n      found = true;\n      console.log(`✅ 找到了！目标是 ${target}`);\n      break; // 正确！在循环内部，可以安全地跳出\n    }\n  }\n  if (!found) {\n    console.log(`✅ 循环结束，未找到 ${target}`);\n  }\n}\n\nconst inventory = [\"剑\", \"盾牌\", \"药水\", \"魔法书\"];\nfindItem(inventory, \"药水\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-5-break-continue-控制.md", "blockIndex": 3}
{"id": "js-sec-1-3-5", "title": "break/continue 控制", "code": "// 场景：星际矿工机器人扫描小行星带\nconst asteroidBelt = [\n  \"普通石头\",\n  \"铁矿石\",\n  \"辐射区\", // 危险！\n  \"铜矿石\",\n  \"氪晶\",   // 目标！\n  \"冰块\",\n  \"金矿石\"\n];\n\nfunction startMining(belt) {\n  console.log(\"🤖 挖挖-E 启动，开始扫描小行星带...\");\n  let foundKryptonite = false;\n\n  for (let i = 0; i < belt.length; i++) {\n    const zone = belt[i];\n    \n    // 检查是否是辐射区\n    if (zone === \"辐射区\") {\n      console.log(`💥 警告！进入 [${zone}]，能量护盾启动，立刻跳过！`);\n      continue; // 跳过当前危险区域，继续下一次扫描\n    }\n    \n    console.log(`扫描中... 发现 [${zone}]，正在分析...`);\n    \n    // 检查是否是目标矿物\n    if (zone === \"氪晶\") {\n      console.log(`🌟 哇！是 [${zone}]！任务目标达成！停止扫描，返航！`);\n      foundKryptonite = true;\n      break; // 找到目标，终止整个扫描任务\n    }\n\n    // 模拟分析耗时\n    // (这里用一个简单的log代替)\n    console.log(`[${zone}] 分析完毕，无特殊发现。`);\n    console.log(\"---------------------------------\");\n  }\n\n  if (foundKryptonite) {\n    console.log(\"\\n✅ 任务成功：已采集到氪晶。\");\n  } else {\n    console.log(\"\\n🟡 任务结束：扫描完整个区域，未发现氪晶。\");\n  }\n}\n\nstartMining(asteroidBelt);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-5-break-continue-控制.md", "blockIndex": 4}
{"id": "js-sec-1-3-6", "title": "循环性能与优化", "code": "// 准备一个大数据集\nconst largeArray = new Array(1000000).fill(0);\nlet sum = 0;\n\nconsole.time(\"优化前\");\n// 每次循环都会重新计算 largeArray.length\nfor (let i = 0; i < largeArray.length; i++) {\n  sum += i;\n}\nconsole.timeEnd(\"优化前\");\nconsole.log(\"优化前计算的总和:\", sum);\n\n// 重置 sum\nsum = 0;\n\nconsole.time(\"优化后\");\n// 提前缓存数组长度\nconst len = largeArray.length;\nfor (let i = 0; i < len; i++) {\n  sum += i;\n}\nconsole.timeEnd(\"优化后\");\nconsole.log(\"优化后计算的总和:\", sum);\n// 提示：在现代浏览器中，JS引擎会自动优化.length的访问，性能差异可能不明显，但这是一个经典的优化思想。", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-6-循环性能与优化.md", "blockIndex": 0}
{"id": "js-sec-1-3-6", "title": "循环性能与优化", "code": "const items = ['火箭', '飞船', '空间站', '探测器'];\nconst launchSequence = [];\n\nconsole.log(\"--- 正序循环 ---\");\nconst len = items.length;\nfor (let i = 0; i < len; i++) {\n  console.log(`准备发射: ${items[i]}`);\n}\n\nconsole.log(\"\\n--- 倒序循环 (发射倒计时!) ---\");\n// 倒序循环更符合“倒计时”的语境\nfor (let i = items.length - 1; i >= 0; i--) {\n  console.log(`发射倒计时: ${i + 1}... ${items[i]} 已准备!`);\n  launchSequence.push(items[i]);\n}\nconsole.log(\"\\n🚀 发射!\", launchSequence);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-6-循环性能与优化.md", "blockIndex": 1}
{"id": "js-sec-1-3-6", "title": "循环性能与优化", "code": "const player = {\n  name: \"Cosmo\",\n  inventory: {\n    items: new Array(50000).fill('星尘'),\n    capacity: 50000\n  },\n  stats: {\n    level: 99\n  }\n};\nlet totalItems = 0;\n\nconsole.time(\"低效的循环\");\n// 每次循环都深入访问 player.inventory.items.length\n// 这种深层属性访问比访问局部变量要慢\nfor (let i = 0; i < player.inventory.items.length; i++) {\n  totalItems++;\n}\nconsole.timeEnd(\"低效的循环\");\nconsole.log(`低效循环统计的物品数量: ${totalItems}`);\n\n\ntotalItems = 0;\nconsole.time(\"高效的循环\");\n// 将长度和需要访问的数组都缓存到局部变量中\nconst items = player.inventory.items;\nconst len = items.length;\nfor (let i = 0; i < len; i++) {\n  totalItems++;\n}\nconsole.timeEnd(\"高效的循环\");\nconsole.log(`高效循环统计的物品数量: ${totalItems}`);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-6-循环性能与优化.md", "blockIndex": 2}
{"id": "js-sec-1-3-6", "title": "循环性能与优化", "code": "// 创建一个包含一百万个玩家分数的大数组\nconst scores = new Array(1000000).fill(0).map((_, i) => i * 10);\n\nconsole.log(\"=== 错误用法 (性能敏感场景) ===\");\n// ❌ 在需要极致性能的场景下使用 forEach\n// forEach 对于每个元素都会产生一次函数调用，当数据量巨大时，这会累积成可观的开销。\n// 对于日常开发，它的可读性很好，但不是性能最优解。\nlet totalScoreForEach = 0;\nconsole.time(\"forEach 循环\");\nscores.forEach(score => {\n  totalScoreForEach += score;\n});\nconsole.timeEnd(\"forEach 循环\");\nconsole.log(`[forEach] 总分: ${totalScoreForEach}`);\n\n\nconsole.log(\"\\n=== 正确用法 (追求极致性能) ===\");\n// ✅ 使用原生 for 循环\n// for 循环没有额外的函数调用开销，是处理大量数据时最快的循环方式。\nlet totalScoreFor = 0;\nconst len = scores.length;\nconsole.time(\"原生 for 循环\");\nfor (let i = 0; i < len; i++) {\n  totalScoreFor += scores[i];\n}\nconsole.timeEnd(\"原生 for 循环\");\nconsole.log(`[for] 总分: ${totalScoreFor}`);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-6-循环性能与优化.md", "blockIndex": 3}
{"id": "js-sec-1-3-6", "title": "循环性能与优化", "code": "// 场景：为一个复古游戏渲染一个像素风格的宇宙飞船\n// 0: 空白, 1: 船体, 2: 窗口, 3: 火焰\nconst spaceshipCanvas = [\n  [0, 0, 1, 0, 0],\n  [0, 1, 1, 1, 0],\n  [0, 1, 2, 1, 0],\n  [1, 1, 1, 1, 1],\n  [0, 1, 1, 1, 0],\n  [0, 0, 3, 0, 0],\n  [0, 3, 3, 3, 0],\n];\n\nconst pixelMap = {\n  0: '  ',   // 空格\n  1: '██',   // 船体 (使用全角块字符)\n  2: '👁️ ',  // 窗口 (用Emoji更有趣)\n  3: '🔥',   // 火焰\n};\n\n/**\n * 高效的像素渲染函数\n * @param {number[][]} canvas - 二维数组表示的画布\n * @param {object} mapping - 像素值到字符的映射\n */\nfunction renderAsciiArt(canvas, mapping) {\n  console.log(\"--- 启动高效ASCII渲染引擎 ---\");\n  let screenOutput = '\\n';\n  \n  // 优化1: 缓存外部数组的长度 (行数)\n  const height = canvas.length;\n  if (height === 0) {\n    console.log(\"画布是空的！\");\n    return;\n  }\n  \n  // 优化2: 缓存内部数组的长度 (宽度)，假设所有行等宽\n  const width = canvas[0].length;\n\n  // 使用倒序循环来模拟从上到下的“打印”过程\n  for (let y = 0; y < height; y++) {\n    let currentLine = '';\n    for (let x = 0; x < width; x++) {\n      // 优化3: 减少循环体内的计算，直接从映射中取值\n      const pixelValue = canvas[y][x];\n      currentLine += mapping[pixelValue] || '??'; // 如果找不到映射，显示问号\n    }\n    screenOutput += currentLine + '\\n';\n  }\n  \n  console.log(screenOutput);\n  console.log(\"--- 渲染完成！飞船已出现在控制台！ ---\");\n}\n\n// 执行渲染\nrenderAsciiArt(spaceshipCanvas, pixelMap);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-3-6-循环性能与优化.md", "blockIndex": 4}
{"id": "js-sec-1-4-1", "title": "函数声明与表达式", "code": "// 方式一：函数声明 (Function Declaration)\n// 就像给一个行为起了个正式的名字\nfunction greetDeclaration() {\n  console.log(\"你好，我来自函数声明！\");\n}\n\n// 方式二：函数表达式 (Function Expression)\n// 就像创建一个函数，然后把它装进一个叫 greetExpression 的盒子里（变量）\nconst greetExpression = function() {\n  console.log(\"你好，我来自函数表达式！\");\n};\n\n// 调用它们\nconsole.log(\"调用函数声明:\");\ngreetDeclaration();\n\nconsole.log(\"调用函数表达式:\");\ngreetExpression();", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-1-函数声明与表达式.md", "blockIndex": 0}
{"id": "js-sec-1-4-1", "title": "函数声明与表达式", "code": "// 在函数定义之前调用\nsayHello(); // 输出: \"你好呀！我被提升了！\"\n\n// 函数声明\nfunction sayHello() {\n  console.log(\"你好呀！我被提升了！\");\n}\n\nconsole.log(\"即使在定义之前调用，函数声明也能正常工作。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-1-函数声明与表达式.md", "blockIndex": 1}
{"id": "js-sec-1-4-1", "title": "函数声明与表达式", "code": "// 尝试在赋值之前调用函数表达式\ntry {\n  sayHi(); // 这会引发一个错误！\n} catch (error) {\n  console.log(\"出错了:\", error.message);\n}\n\n// 函数表达式：将一个匿名函数赋值给一个常量\nconst sayHi = function() {\n  console.log(\"嗨！我是一个函数表达式，不能被提前调用。\");\n};\n\nconsole.log(\"现在，在定义之后调用就没问题了：\");\nsayHi();", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-1-函数声明与表达式.md", "blockIndex": 2}
{"id": "js-sec-1-4-1", "title": "函数声明与表达式", "code": "// 完整的对比示例，展示提升行为的区别\n\nconsole.log(\"=== 错误用法 ❌ ===\");\n// 尝试调用一个尚未被赋值的函数表达式\ntry {\n  // `wizardSpell` 这个变量存在（被提升），但它还没有被赋值为一个函数\n  // 所以此时调用它会失败\n  wizardSpell(\"火焰\");\n} catch (e) {\n  console.log(\"施法失败:\", e.message);\n  console.log(\"原因：函数表达式和普通变量一样，必须在赋值后才能使用。\");\n}\n\nconst wizardSpell = function(spellName) {\n  console.log(`🧙‍♂️ 释放咒语: ${spellName}!`);\n};\n\n\nconsole.log(\"\\n=== 正确用法 ✅ ===\");\n// 函数声明可以在任意位置被调用，因为它被完整地提升了\ngodsBlessing(\"圣光\"); // 正常工作\n\nfunction godsBlessing(blessingName) {\n  console.log(`✨ 降下神恩: ${blessingName}!`);\n}\nconsole.log(\"原因：函数声明在代码执行前就被完整加载，所以可以随处调用。\");\n\n// 对于函数表达式，在定义后调用是完全正确的\nwizardSpell(\"冰霜\"); // 正常工作", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-1-函数声明与表达式.md", "blockIndex": 3}
{"id": "js-sec-1-4-1", "title": "函数声明与表达式", "code": "// 核心功能：使用函数声明，因为它总是存在的\nfunction revealDestiny(name, divinationMethod) {\n  console.log(`\\n欢迎你，勇敢的探险家 ${name}！`);\n  console.log(\"我将为你揭示命运的丝线...\");\n\n  // 检查是否提供了有效的占卜方法（一个函数）\n  if (typeof divinationMethod === 'function') {\n    const fate = divinationMethod(); // 调用作为参数传入的函数\n    console.log(`🌟 命运的启示: ${fate}`);\n  } else {\n    console.log(\"看来你没有选择占卜工具，命运今天保持了沉默。\");\n  }\n  console.log(\"--------------------\");\n}\n\n// 占卜工具：使用函数表达式，它们是可替换的“插件”\nconst useCrystalBall = function() {\n  const outcomes = [\"你的财富将如繁星般增长。\", \"一次意想不到的旅程在等着你。\", \"小心一个戴着红色帽子的陌生人。\"];\n  return outcomes[Math.floor(Math.random() * outcomes.length)];\n};\n\nconst readTarotCards = function() {\n  const cards = [\"【愚者】：新的开始，无限可能。\", \"【魔术师】：创造力与机遇。\", \"【高塔】：突如其来的变革。\"];\n  return cards[Math.floor(Math.random() * cards.length)];\n};\n\nconst interpretStars = function() {\n    return \"星象显示，今晚适合吃一顿大餐来犒劳自己！\";\n}\n\n\n// --- 开始占卜！---\n// 探险家 Alice 选择用水晶球\nrevealDestiny(\"Alice\", useCrystalBall);\n\n// 探险家 Bob 选择了塔罗牌\nrevealDestiny(\"Bob\", readTarotCards);\n\n// 探险家 Charlie 对星象感兴趣\nrevealDestiny(\"Charlie\", interpretStars);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-1-函数声明与表达式.md", "blockIndex": 4}
{"id": "js-sec-1-4-2", "title": "参数与返回值", "code": "/**\n * 创建一个问候语的函数\n * @param {string} name - 这是参数，就像你要告诉机器你的名字\n * @returns {string} - 这是返回值，是机器根据你的名字生成的一句话\n */\nfunction createGreeting(name) {\n  const greetingText = \"你好, \" + name + \"！欢迎来到JavaScript的世界！\";\n  return greetingText; // 使用 return 关键字将结果“吐”出来\n}\n\n// 调用函数，并传入 \"探险家\" 作为参数\nconst message = createGreeting(\"探险家\");\n\n// 打印函数返回的结果\nconsole.log(message);\n// 输出: 你好, 探险家！欢迎来到JavaScript的世界！", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-2-参数与返回值.md", "blockIndex": 0}
{"id": "js-sec-1-4-2", "title": "参数与返回值", "code": "/**\n * 创建一个角色信息\n * @param {string} name - 角色名 (必需)\n * @param {string} job - 角色职业 (必需)\n * @param {number} level - 角色等级 (可选, 默认为 1)\n */\nfunction createCharacter(name, job, level = 1) {\n  return `角色创建成功！\\n姓名: ${name}\\n职业: ${job}\\n等级: LV.${level}`;\n}\n\n// 1. 提供所有参数\nconst warrior = createCharacter(\"格罗姆·地狱咆哮\", \"战士\", 85);\nconsole.log(warrior);\n// 输出:\n// 角色创建成功！\n// 姓名: 格罗姆·地狱咆哮\n// 职业: 战士\n// 等级: LV.85\n\nconsole.log(\"--------------------\");\n\n// 2. 不提供 level 参数，它将使用默认值 1\nconst mage = createCharacter(\"吉安娜·普罗德摩尔\", \"法师\");\nconsole.log(mage);\n// 输出:\n// 角色创建成功！\n// 姓名: 吉安娜·普罗德摩尔\n// 职业: 法师\n// 等级: LV.1", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-2-参数与返回值.md", "blockIndex": 1}
{"id": "js-sec-1-4-2", "title": "参数与返回值", "code": "/**\n * 一个只负责在控制台显示警告信息的函数\n * 它执行一个动作，但不需要返回任何计算结果。\n */\nfunction showAlert(message) {\n  console.log(\"🚨 警告! 警告! \" + message);\n  // 这个函数没有 return 语句\n}\n\n// 调用函数，它会在控制台打印消息\nshowAlert(\"发现未知能量源！\");\n\n// 尝试接收这个函数的返回值\nconst functionResult = showAlert(\"系统过载！\");\n\n// 检查返回值\nconsole.log(\"showAlert函数的返回值是:\", functionResult);\n// 输出: showAlert函数的返回值是: undefined", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-2-参数与返回值.md", "blockIndex": 2}
{"id": "js-sec-1-4-2", "title": "参数与返回值", "code": "// === 错误用法 ===\nconsole.log(\"=== 错误用法 ===\");\n\nfunction sumAndLog(num1, num2) {\n  const result = num1 + num2;\n  // ❌ 只是在函数内部打印了结果，并没有把结果“交出去”\n  console.log(\"函数内部打印的结果是: \" + result);\n}\n\nconst mySum_bad = sumAndLog(10, 5);\nconsole.log(\"尝试使用函数的结果:\", mySum_bad); // 得到 undefined\n// ❌ 无法对结果进行后续操作，因为 mySum_bad 是 undefined\nconsole.log(\"尝试对结果进行计算: \" + (mySum_bad + 5)); // 输出: NaN (undefined + 5 = Not a Number)\n// 解释: sumAndLog 函数没有 return 语句，所以它隐式返回了 undefined。变量 mySum_bad 接收到的就是 undefined，而不是计算结果 15。\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 将计算结果通过 return 返回\n\nfunction sumAndReturn(num1, num2) {\n  const result = num1 + num2;\n  // ✅ 使用 return 关键字将结果“交出去”\n  return result;\n}\n\nconst mySum_good = sumAndReturn(10, 5);\nconsole.log(\"成功获取到函数返回的结果:\", mySum_good); // 得到 15\n// ✅ 可以对返回的结果进行任何后续操作\nconsole.log(\"成功对结果进行计算: \" + (mySum_good + 5)); // 输出: 20\n// 解释: sumAndReturn 函数明确地返回了计算结果。变量 mySum_good 成功地接收到了值 15，可以像任何普通数字一样使用它。", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-2-参数与返回值.md", "blockIndex": 3}
{"id": "js-sec-1-4-2", "title": "参数与返回值", "code": "/**\n * 随机从一个数组中选择一个元素并返回\n * @param {Array} arr - 任何类型的数组\n * @returns {*} - 数组中的一个随机元素\n */\nfunction getRandomElement(arr) {\n  const randomIndex = Math.floor(Math.random() * arr.length);\n  return arr[randomIndex];\n}\n\n/**\n * 创建一个自定义的表情符号\n * @param {string} eyes - 代表眼睛的字符 (参数1)\n * @param {string} mouth - 代表嘴巴的字符 (参数2)\n * @param {string} face - 代表脸颊或装饰的字符 (参数3)\n * @returns {string} - 组合好的表情符号字符串 (返回值)\n */\nfunction createEmoji(eyes, mouth, face) {\n  // 使用参数来构建最终的字符串\n  return `${face[0]} ${eyes} ${mouth} ${eyes} ${face[1]}`;\n}\n\n// --- 开始我们的创意工坊！ ---\n\n// 1. 创建一个完全自定义的表情\nconst happyEmoji = createEmoji(\"o\", \"v\", \"()\");\nconsole.log(\"我的自定义开心表情:\", happyEmoji); // ( o v o )\n\nconst surprisedEmoji = createEmoji(\"O\", \"o\", \"[]\");\nconsole.log(\"我的自定义惊讶表情:\", surprisedEmoji); // [ O o O ]\n\n\n// 2. 让我们来点随机的！\nconsole.log(\"\\n--- 随机生成时间！ ---\");\nconst eyeOptions = [\"-\", \"^\", \"o\", \"*\", \"O\"];\nconst mouthOptions = [\"_\", \"w\", \"u\", \".\", \"3\"];\nconst faceOptions = [ \"{}\", \"()\", \"[]\", \"<>\" ];\n\nfor (let i = 0; i < 3; i++) {\n  // 将 getRandomElement 的返回值作为 createEmoji 的参数\n  const randomEyes = getRandomElement(eyeOptions);\n  const randomMouth = getRandomElement(mouthOptions);\n  const randomFace = getRandomElement(faceOptions);\n  \n  const randomGeneratedEmoji = createEmoji(randomEyes, randomMouth, randomFace.split(''));\n  console.log(`第 ${i + 1} 个随机表情: ${randomGeneratedEmoji}`);\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-2-参数与返回值.md", "blockIndex": 4}
{"id": "js-sec-1-4-3", "title": "箭头函数", "code": "// 传统函数表达式\nconst addTraditional = function(a, b) {\n  return a + b;\n};\n\n// 使用箭头函数\nconst addArrow = (a, b) => a + b;\n\nconsole.log(\"传统函数计算结果:\", addTraditional(5, 3));\nconsole.log(\"箭头函数计算结果:\", addArrow(5, 3));", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-3-箭头函数.md", "blockIndex": 0}
{"id": "js-sec-1-4-3", "title": "箭头函数", "code": "// 传统函数：给数字翻倍\nconst doubleTraditional = function(n) {\n  return n * 2;\n};\n\n// 箭头函数：单个参数，可以省略括号\nconst doubleArrow = n => n * 2;\n\n// 箭头函数：创建对象需要用括号包裹\nconst createPerson = (name, age) => ({ name: name, age: age });\n\nconsole.log(\"传统方式翻倍:\", doubleTraditional(10));\nconsole.log(\"箭头函数翻倍:\", doubleArrow(10));\nconsole.log(\"箭头函数创建对象:\", createPerson(\"Alice\", 30));", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-3-箭头函数.md", "blockIndex": 1}
{"id": "js-sec-1-4-3", "title": "箭头函数", "code": "// 创建一个玩家对象\nconst player = {\n  name: \"闪电侠\",\n  speed: 100,\n  \n  // 使用传统函数，`this` 会丢失\n  boostWrong: function() {\n    setTimeout(function() {\n      // 这里的 `this` 指向全局对象 (window) 或在严格模式下是 undefined\n      // 因此 this.name 是 undefined\n      console.log(`[错误演示] 1秒后，${this.name} 试图加速，但失败了！`);\n    }, 1000);\n  },\n\n  // 使用箭头函数，`this` 被正确捕获\n  boostCorrect: function() {\n    setTimeout(() => {\n      // 这里的 `this` 继承自 boostCorrect 方法，指向 player 对象\n      this.speed += 50;\n      console.log(`[正确演示] 1秒后，${this.name} 成功加速！当前速度: ${this.speed}`);\n    }, 1000);\n  }\n};\n\nplayer.boostWrong();\nplayer.boostCorrect();", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-3-箭头函数.md", "blockIndex": 2}
{"id": "js-sec-1-4-3", "title": "箭头函数", "code": "// 定义一个简单的宠物对象\nconst pet = {\n  name: \"旺财\",\n  age: 2,\n\n  // ❌ 错误用法：使用箭头函数作为对象的方法\n  // 箭头函数会捕获全局作用域的 `this`，在这里通常是 `undefined` 或 `window`\n  // 导致 `this.name` 无法正确获取到 \"旺财\"\n  sayHelloWrong: () => {\n    // 这里的 this 指向全局作用域，而不是 pet 对象\n    console.log(\"=== 错误用法 ===\");\n    console.log(`你好，我是 ${this.name}，我 ${this.age} 岁了。 (哦不，我找不到自己的名字!)`);\n  },\n\n  // ✅ 正确用法：使用传统函数定义方法\n  // 这样 `this` 就会在调用时动态绑定到 pet 对象上\n  sayHelloCorrect: function() {\n    console.log(\"=== 正确用法 ===\");\n    console.log(`你好，我是 ${this.name}，我 ${this.age} 岁了。`);\n  }\n};\n\npet.sayHelloWrong(); // 输出: 你好，我是 undefined，我 undefined 岁了。 (...)\npet.sayHelloCorrect(); // 输出: 你好，我是 旺财，我 2 岁了。", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-3-箭头函数.md", "blockIndex": 3}
{"id": "js-sec-1-4-3", "title": "箭头函数", "code": "// 创建一个英雄角色\nconst hero = {\n  name: \"屠龙者\",\n  level: 1,\n  health: 100,\n  maxHealth: 100,\n\n  // 英雄状态报告\n  reportStatus: function() {\n    console.log(`--- ${this.name} | 等级: ${this.level} | 生命值: ${this.health}/${this.maxHealth} ---`);\n  },\n\n  // 升级方法，需要延迟一段时间\n  levelUpAfterDelay: function(delayInSeconds) {\n    console.log(`[系统] ${this.name} 击败了远古巨龙！升级仪式将在 ${delayInSeconds} 秒后开始...`);\n    \n    // 使用 setTimeout 模拟延迟\n    setTimeout(() => {\n      // ✨ 魔法发生在这里！✨\n      // 因为这是箭头函数，`this` 正确地指向了 `hero` 对象。\n      // 如果用普通函数，`this` 就会丢失，升级就会失败！\n      this.level++;\n      this.maxHealth += 20;\n      this.health = this.maxHealth; // 升级后满血复活！\n\n      console.log(`\\n🎉 叮！金光一闪，${this.name} 升级了！ 🎉`);\n      this.reportStatus();\n      console.log(\"[系统] 你的力量变强了，准备好迎接新的挑战吧！\");\n\n    }, delayInSeconds * 1000);\n  }\n};\n\n// 游戏开始，展示英雄初始状态\nconsole.log(\"====== 游戏开始 ======\");\nhero.reportStatus();\n\n// 触发升级事件，延迟3秒\nhero.levelUpAfterDelay(3);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-3-箭头函数.md", "blockIndex": 4}
{"id": "js-sec-1-4-4", "title": "默认参数与剩余参数", "code": "// === 默认参数 (Default Parameters) ===\n// 当调用函数时没有提供某个参数，它会使用默认值\nfunction greet(name = '神秘的朋友') {\n  console.log(`你好, ${name}!`);\n}\n\ngreet('爱丽丝'); // 输出: 你好, 爱丽丝!\ngreet();       // 输出: 你好, 神秘的朋友!\n\n\n// === 剩余参数 (Rest Parameters) ===\n// 使用 ... 将多个独立的参数“打包”成一个数组\nfunction sumAll(...numbers) {\n  // `numbers` 是一个真正的数组，可以使用数组方法\n  let total = numbers.reduce((acc, current) => acc + current, 0);\n  console.log(`传入的数字是: [${numbers}]`);\n  console.log(`它们的总和是: ${total}`);\n}\n\nsumAll(1, 2, 3);       // 输出: 传入的数字是: [1,2,3]  它们的总和是: 6\nsumAll(10, 20, 30, 40); // 输出: 传入的数字是: [10,20,30,40]  它们的总和是: 100", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-4-默认参数与剩余参数.md", "blockIndex": 0}
{"id": "js-sec-1-4-4", "title": "默认参数与剩余参数", "code": "// 一个简单的函数，用来返回当前时间戳\nfunction getDefaultTimestamp() {\n  console.log('正在获取默认时间...');\n  return Date.now();\n}\n\n// `createdAt` 的默认值是一个函数调用\nfunction createLogEntry(message, createdAt = getDefaultTimestamp()) {\n  console.log(`日志: \"${message}\" 创建于 ${createdAt}`);\n}\n\n// 第一次调用，提供了第二个参数，所以默认函数不会执行\ncreateLogEntry('用户登录成功', 1678886400000);\n// -> 日志: \"用户登录成功\" 创建于 1678886400000\n\nconsole.log('--- 分割线 ---');\n\n// 第二次调用，未提供第二个参数，默认函数被执行\n// 为了看到效果，我们等一秒再调用\nsetTimeout(() => {\n  createLogEntry('用户上传了文件');\n  // -> 正在获取默认时间...\n  // -> 日志: \"用户上传了文件\" 创建于 [当前的时间戳]\n}, 1000);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-4-默认参数与剩余参数.md", "blockIndex": 1}
{"id": "js-sec-1-4-4", "title": "默认参数与剩余参数", "code": "// 正确用法：...players 是最后一个参数\nfunction createTeam(captain, coach, ...players) {\n  console.log(`队长: ${captain}`);\n  console.log(`教练: ${coach}`);\n  console.log(`队员名单: ${players.join(', ')}`);\n  console.log(`队员人数: ${players.length}`);\n}\n\ncreateTeam('梅西', '斯卡洛尼', '马丁内斯', '迪马利亚', '阿尔瓦雷斯');\n// 输出:\n// 队长: 梅西\n// 教练: 斯卡洛尼\n// 队员名单: 马丁内斯, 迪马利亚, 阿尔瓦雷斯\n// 队员人数: 3\n\n// 如果尝试将剩余参数放在前面，会直接导致语法错误 (SyntaxError)。\n// 下面的代码无法运行，仅作展示：\n// function createTeamWrong(...players, captain, coach) {\n//   // Uncaught SyntaxError: Rest parameter must be last formal parameter\n// }", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-4-默认参数与剩余参数.md", "blockIndex": 2}
{"id": "js-sec-1-4-4", "title": "默认参数与剩余参数", "code": "// 假设我们要为一个游戏角色设置音量\n// 音量可以是 0 到 100 之间的数字\n\nconsole.log(\"=== 错误用法 (使用 ||) ===\");\n// ❌ 这种老方法会把有效的“假值”当作未提供\nfunction setVolumeOld(level) {\n  const finalLevel = level || 50; // 如果 level 是 0, '' or false, 就会变成 50\n  console.log(`[旧方法] 当前音量: ${finalLevel}`);\n}\n\nsetVolumeOld(80); // 正常工作 -> [旧方法] 当前音量: 80\nsetVolumeOld();   // 正常工作 -> [旧方法] 当前音量: 50\nsetVolumeOld(0);  // ❌ 错误！我们想设置音量为0，但它变成了50！\nsetVolumeOld(''); // ❌ 错误！空字符串也被当成了50！\n\n\nconsole.log(\"\\n=== 正确用法 (使用 ES6 默认参数) ===\");\n// ✅ ES6 默认参数只在参数值为 `undefined` 时生效\nfunction setVolumeNew(level = 50) {\n  console.log(`[新方法] 当前音量: ${level}`);\n}\n\nsetVolumeNew(80); // 正常工作 -> [新方法] 当前音量: 80\nsetVolumeNew();   // 正常工作 -> [新方法] 当前音量: 50\nsetVolumeNew(0);  // ✅ 正确！音量被成功设置为 0\nsetVolumeNew(''); // ✅ 正确！音量被成功设置为空字符串", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-4-默认参数与剩余参数.md", "blockIndex": 3}
{"id": "js-sec-1-4-4", "title": "默认参数与剩余参数", "code": "/**\n * 表情符号生成器\n * @param {string} eyes - 眼睛样式，默认为 'o o'\n * @param {string} mouth - 嘴巴样式，默认为 '-'\n * @param {...string} decorations - 任意数量的装饰品，如帽子、胡子等\n */\nfunction createEmoji(eyes = 'o o', mouth = '-', ...decorations) {\n  console.log(`🎨 开始制作表情...`);\n  console.log(`眼睛: ${eyes}, 嘴巴: ${mouth}`);\n\n  // 检查是否有装饰品\n  if (decorations.length === 0) {\n    console.log('没有添加任何装饰品。');\n  } else {\n    console.log(`收到了 ${decorations.length} 个装饰品: ${decorations.join(', ')}`);\n  }\n\n  // 组装最终的表情符号\n  // 将所有装饰品放在表情的上方和下方\n  const topDecorations = decorations.slice(0, Math.ceil(decorations.length / 2)).join(' ');\n  const bottomDecorations = decorations.slice(Math.ceil(decorations.length / 2)).join(' ');\n\n  const emoji = `\n    ${topDecorations}\n   ( ${eyes} )\n      ${mouth}\n    ${bottomDecorations}\n  `;\n\n  console.log('✨ 你的专属表情符号诞生了！✨');\n  console.log(emoji);\n  return emoji;\n}\n\n// 1. 使用所有默认参数\nconsole.log('--- 案例1: 基础款 ---');\ncreateEmoji();\n\n// 2. 自定义眼睛和嘴巴，不加装饰\nconsole.log('\\n--- 案例2: 开心款 ---');\ncreateEmoji('^ ^', 'U');\n\n// 3. 使用默认五官，但加上一堆装饰品\nconsole.log('\\n--- 案例3: 派对款 ---');\ncreateEmoji(undefined, undefined, '🎉', '🎩', '🥳', '✨'); // 使用 undefined 来跳过并使用默认值\n\n// 4. 完全自定义\nconsole.log('\\n--- 案例4: 海盗款 ---');\ncreateEmoji('@ o', 'J', '🏴‍☠️', '⚔️');", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-4-默认参数与剩余参数.md", "blockIndex": 4}
{"id": "js-sec-1-4-5", "title": "函数作用域", "code": "function showSecret() {\n  // 这个变量只存在于 showSecret 函数的“房间”里\n  let secretMessage = \"🤫 我是一个秘密！\";\n  console.log(\"在函数内部，我可以看到:\", secretMessage);\n}\n\n// 调用函数，执行内部的 console.log\nshowSecret();\n\n// 尝试在函数外部访问这个变量\ntry {\n  console.log(secretMessage); // 这里会抛出错误\n} catch (error) {\n  console.error(\"在函数外部，访问失败了:\", error.message);\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-5-函数作用域.md", "blockIndex": 0}
{"id": "js-sec-1-4-5", "title": "函数作用域", "code": "let character = \"外部世界的英雄\";\n\nfunction enterDungeon() {\n  // 这个 'character' 变量遮蔽了外部的同名变量\n  let character = \"地牢探险家\"; \n  console.log(`欢迎, ${character}! 你已进入地牢。`);\n}\n\nconsole.log(`在进入地牢之前, 我是: ${character}`);\nenterDungeon();\nconsole.log(`离开地牢之后, 我还是: ${character}`); // 外部变量未受影响", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-5-函数作用域.md", "blockIndex": 1}
{"id": "js-sec-1-4-5", "title": "函数作用域", "code": "function castle() {\n  let king = \"亚瑟王\";\n  let treasure = \"圣杯\";\n\n  function throneRoom() {\n    let guard = \"兰斯洛特\";\n    // 内部函数可以访问外部函数的变量 king 和 treasure\n    console.log(`在王座室，守卫 ${guard} 保护着 ${king} 和 ${treasure}。`);\n  }\n\n  // 调用内部函数\n  throneRoom();\n\n  try {\n    // 外部函数无法访问内部函数的变量 guard\n    console.log(guard); \n  } catch (error) {\n    console.error(`在城堡大厅，无法直接看到王座室的守卫: ${error.message}`);\n  }\n}\n\ncastle();", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-5-函数作用域.md", "blockIndex": 2}
{"id": "js-sec-1-4-5", "title": "函数作用域", "code": "// === 错误用法 ===\nconsole.log(\"=== 错误用法 ===\");\nfunction createWarriors_Bad() {\n  var warriors = [];\n  // 'var' 声明的 'i' 属于整个函数作用域\n  for (var i = 0; i < 3; i++) {\n    warriors.push(function() {\n      // 当这些函数最终被调用时，循环早已结束，此时 i 的值是 3\n      console.log(\"我的编号是:\", i);\n    });\n  }\n  return warriors;\n}\n\nconst badWarriors = createWarriors_Bad();\nconsole.log(\"召唤一群克隆战士...\");\nbadWarriors[0](); // 输出: 我的编号是: 3\nbadWarriors[1](); // 输出: 我的编号是: 3\nbadWarriors[2](); // 输出: 我的编号是: 3\nconsole.log(\"❌ 解释: 所有函数共享同一个函数作用域下的 'i'，它们引用的都是 'i' 的最终值。\");\n\n\n// === 正确用法 ===\nconsole.log(\"\\n=== 正确用法 ===\");\nfunction createWarriors_Good() {\n  let warriors = [];\n  // 'let' 具有块级作用域，为循环的每次迭代都创建了一个新的 'i'\n  for (let i = 0; i < 3; i++) { \n    warriors.push(function() {\n      // 每个函数都捕获了它自己那次循环的 'i' 的值\n      console.log(\"我的编号是:\", i);\n    });\n  }\n  return warriors;\n}\n\nconst goodWarriors = createWarriors_Good();\nconsole.log(\"召唤训练有素的独立战士们...\");\ngoodWarriors[0](); // 输出: 我的编号是: 0\ngoodWarriors[1](); // 输出: 我的编号是: 1\ngoodWarriors[2](); // 输出: 我的编号是: 2\nconsole.log(\"✅ 解释: 'let' 为循环的每次迭代创建了独立的块级作用域，每个函数都拥有自己专属的 'i'。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-5-函数作用域.md", "blockIndex": 3}
{"id": "js-sec-1-4-5", "title": "函数作用域", "code": "// 场景：创建一个RPG游戏角色生成器\nfunction createRPGCharacter(name) {\n  // --- 角色的私有属性 (封装在函数作用域内) ---\n  let level = 1;\n  let health = 100;\n  let experience = 0;\n  const EXP_TO_LEVEL_UP = 100;\n\n  console.log(`🌟 冒险家 \"${name}\" 诞生了！`);\n\n  // --- 内部私有函数，外部无法调用 ---\n  function gainLevel() {\n    level++;\n    health += 50; // 升级回血并增加生命上限\n    experience = 0; // 经验值重置\n    console.log(`🎉 升级！ ${name} 现在是 ${level} 级！生命值 +50！`);\n  }\n\n  // --- 返回一个公共接口对象，它能访问和操作上面的私有属性 ---\n  return {\n    // 方法：展示状态\n    showStatus: function() {\n      console.log(\n        `--- 角色状态 ---\\n` +\n        `  名字: ${name}\\n` +\n        `  等级: ${level}\\n` +\n        `  生命: ${health}\\n` +\n        `  经验: ${experience}/${EXP_TO_LEVEL_UP}\\n` +\n        `------------------`\n      );\n    },\n    // 方法：战斗获得经验\n    gainExperience: function(amount) {\n      console.log(`💪 ${name} 获得了 ${amount} 点经验！`);\n      experience += amount;\n      if (experience >= EXP_TO_LEVEL_UP) {\n        gainLevel(); // 调用内部的私有函数\n      }\n    },\n    // 方法：受到伤害\n    takeDamage: function(damage) {\n        health -= damage;\n        console.log(`💥 ${name} 受到了 ${damage} 点伤害，剩余生命 ${health}。`);\n        if (health <= 0) {\n            console.log(`💀 ${name} 被击败了... 游戏结束！`);\n        }\n    }\n  };\n}\n\n// --- 游戏开始 ---\nconst player1 = createRPGCharacter(\"闪电侠客\");\nplayer1.showStatus();\n\n// 模拟游戏过程\nplayer1.gainExperience(70);\nplayer1.showStatus();\nplayer1.takeDamage(20);\nplayer1.gainExperience(40); // 这次会升级\nplayer1.showStatus();\n\n// 尝试从外部直接修改“私有”属性\nconsole.log(\"\\n😈 一个邪恶的巫师尝试直接修改角色等级...\");\nplayer1.level = 99; // 这只是给 player1 对象添加了一个新属性，并不会影响函数作用域内的 level\nconsole.log(`尝试后，player1 对象的 level 属性是: ${player1.level}`);\nconsole.log(\"...但是，角色的核心属性被函数作用域保护得很好！\");\nplayer1.showStatus(); // 等级依然是2，没有被改变！", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-5-函数作用域.md", "blockIndex": 4}
{"id": "js-sec-1-4-6", "title": "递归基础", "code": "// 一个简单的倒计时函数\nfunction countdown(number) {\n  // 如果数字大于0，就继续\n  if (number > 0) {\n    console.log(`倒计时: ${number}`);\n    // 调用自身，但数字减1\n    countdown(number - 1);\n  } else {\n    // 当数字为0时，停止并打印发射\n    console.log(\"🚀 发射!\");\n  }\n}\n\n// 从3开始倒计时\ncountdown(3);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-6-递归基础.md", "blockIndex": 0}
{"id": "js-sec-1-4-6", "title": "递归基础", "code": "// 计算阶乘的函数：n! = n * (n-1) * ... * 1\nfunction factorial(n) {\n  // 基本情况：当n为1或0时，阶乘就是1，停止递归\n  if (n <= 1) {\n    console.log(`基本情况达成: n = ${n}，返回 1`);\n    return 1;\n  }\n  \n  // 递归步骤（将在下一个特性中详细说明）\n  console.log(`递归步骤: n = ${n}, 计算 ${n} * factorial(${n - 1})`);\n  return n * factorial(n - 1);\n}\n\nconst result = factorial(4); // 4 * 3 * 2 * 1 = 24\nconsole.log(\"4的阶乘是:\", result);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-6-递归基础.md", "blockIndex": 1}
{"id": "js-sec-1-4-6", "title": "递归基础", "code": "// 计算数组中所有数字的和\nfunction sumArray(arr) {\n  // 基本情况：如果数组为空，和为0\n  if (arr.length === 0) {\n    console.log(\"基本情况：数组为空，返回 0\");\n    return 0;\n  }\n\n  // 递归步骤：\n  // 取出第一个元素\n  const firstElement = arr[0];\n  // 对剩余的数组部分调用自身\n  const restOfArray = arr.slice(1);\n  \n  console.log(`递归步骤: 取出 ${firstElement}, 递归计算 [${restOfArray}] 的和`);\n  \n  return firstElement + sumArray(restOfArray);\n}\n\nconst numbers = [5, 2, 8];\nconst total = sumArray(numbers);\nconsole.log(`数组 [${numbers.join(', ')}] 的总和是:`, total);", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-6-递归基础.md", "blockIndex": 2}
{"id": "js-sec-1-4-6", "title": "递归基础", "code": "// 完整的对比示例\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误：没有基本情况的递归函数\nfunction infiniteGreeting(count) {\n  // 这个函数缺少一个停止条件\n  console.log(`Hello, this is greeting #${count}!`);\n  // 它会无休止地调用自己，直到程序崩溃\n  // infiniteGreeting(count + 1); // 为了防止浏览器卡死，这里注释掉了\n}\nconsole.log(\"❌ 错误示例：如果取消注释，`infiniteGreeting(1)` 将导致'Maximum call stack size exceeded'错误。\");\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确：有明确基本情况的递归函数\nfunction controlledGreeting(count, maxGreetings) {\n  // 基本情况：当问候次数达到上限时，停止\n  if (count > maxGreetings) {\n    console.log(\"✅ 达到问候上限，停止递归！\");\n    return;\n  }\n\n  // 递归步骤：打印问候语并调用自身，同时向基本情况靠近\n  console.log(`Hello, this is greeting #${count}!`);\n  controlledGreeting(count + 1, maxGreetings);\n}\n\nconsole.log(\"✅ 正确示例：开始有限次数的问候...\");\ncontrolledGreeting(1, 3); // 最多问候3次", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-6-递归基础.md", "blockIndex": 3}
{"id": "js-sec-1-4-6", "title": "递归基础", "code": "// 定义宝箱的结构，一个嵌套的对象\nconst alienTreasureChest = {\n  color: '银色',\n  content: {\n    type: 'box',\n    color: '蓝色',\n    content: {\n      type: 'box',\n      color: '金色',\n      content: {\n        type: 'treasure',\n        name: '宇宙之心'\n      }\n    }\n  }\n};\n\n// 递归函数，用来探索宝箱\nfunction exploreChest(chest) {\n  console.log(`🕵️‍ 正在打开一个【${chest.color}】的宝箱...`);\n\n  // 检查宝箱里的内容\n  const content = chest.content;\n\n  // 基本情况：如果内容是宝藏，就找到了！\n  if (content.type === 'treasure') {\n    console.log(`🎉 哇！找到了终极宝藏：【${content.name}】！任务完成！`);\n    return;\n  }\n\n  // 递归步骤：如果内容是另一个箱子，就继续探索\n  if (content.type === 'box') {\n    console.log(`...发现里面还有一个更小的【${content.color}】宝箱。继续深入！`);\n    exploreChest(content); // 对内部的宝箱调用自身\n  }\n}\n\nconsole.log(\"--- 星际探险开始！---\");\nexploreChest(alienTreasureChest);\nconsole.log(\"--- 探险结束！---\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-1-4-6-递归基础.md", "blockIndex": 4}
{"id": "js-sec-2-1-1", "title": "数组创建与访问", "code": "// 创建一个包含三种水果的数组，就像列一个购物清单\nconst fruits = [\"苹果\", \"香蕉\", \"樱桃\"];\n\n// 访问数组中的第一个元素（注意：编号从0开始）\nconst firstFruit = fruits[0];\n\n// 打印出我们选中的水果\nconsole.log(\"购物清单的第一个水果是:\", firstFruit);\nconsole.log(\"完整的购物清单:\", fruits);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-1-数组创建与访问.md", "blockIndex": 0}
{"id": "js-sec-2-1-1", "title": "数组创建与访问", "code": "const treasureMap = [\"金币\", \"藏宝图\", \"指南针\", \"宝石\"];\n\n// 索引0代表第一个元素\nconsole.log(\"在位置0找到了:\", treasureMap[0]); // 输出: 金币\n\n// 索引2代表第三个元素\nconsole.log(\"在位置2找到了:\", treasureMap[2]); // 输出: 指南针\n\n// 我们可以用 `array.length - 1` 来获取最后一个元素\nconst lastItemIndex = treasureMap.length - 1;\nconsole.log(\"在最后一个位置找到了:\", treasureMap[lastItemIndex]); // 输出: 宝石", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-1-数组创建与访问.md", "blockIndex": 1}
{"id": "js-sec-2-1-1", "title": "数组创建与访问", "code": "// 创建一个描述英雄角色的混合类型数组\n// 格式: [名字, 等级, 是否是法师, 技能列表]\nconst heroProfile = [\n  \"大法师安东尼\", // 字符串 (String)\n  99,              // 数字 (Number)\n  true,            // 布尔值 (Boolean)\n  [\"火球术\", \"寒冰箭\"] // 另一个数组 (Array)\n];\n\nconsole.log(\"英雄名字:\", heroProfile[0]);\nconsole.log(\"英雄等级:\", heroProfile[1]);\nconsole.log(\"是法师吗?:\", heroProfile[2]);\nconsole.log(\"他的第一个技能是:\", heroProfile[3][0]); // 访问嵌套数组的元素", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-1-数组创建与访问.md", "blockIndex": 2}
{"id": "js-sec-2-1-1", "title": "数组创建与访问", "code": "// 假设我们的派对只有3位客人\nconst partyGuests = [\"爱丽丝\", \"鲍勃\", \"查理\"];\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 尝试访问索引为 5 的客人。这个位置是空的！\nconst nonExistentGuest = partyGuests[5];\nconsole.log(\"第五位客人是谁?\", nonExistentGuest);\n// 解释: 因为数组中只有3个元素（索引0, 1, 2），所以访问索引5会得到 undefined，\n// 意思是“这个地方什么都没有”。\n\nconsole.log(\"=== 正确用法 ===\");\n// ✅ 访问一个存在的索引\nconst secondGuest = partyGuests[1];\nconsole.log(\"第二位客人是谁?\", secondGuest);\n// 解释: 索引1是有效的，它正确地指向了数组中的第二个元素 \"鲍勃\"。\n// 检查数组长度可以避免访问不存在的索引。\nconsole.log(\"派对总共有\", partyGuests.length, \"位客人。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-1-数组创建与访问.md", "blockIndex": 3}
{"id": "js-sec-2-1-1", "title": "数组创建与访问", "code": "// 🐾 虚拟宠物心情系统 🐾\n\n// 1. 创建一个心情列表，包含各种可能的心情和可爱的表情符号\nconst petMoods = [\n  { mood: \"开心\", emoji: \"😄\" },\n  { mood: \"困倦\", emoji: \"😴\" },\n  { mood: \"饥饿\", emoji: \"🍖\" },\n  { mood: \"想玩耍\", emoji: \"🎾\" },\n  { mood: \"好奇\", emoji: \"🤔\" },\n  { mood: \"有点淘气\", emoji: \"😈\" }\n];\n\n// 2. 生成一个随机索引，用来从心情列表中选择一个心情\n// Math.random() 生成 0 到 1 之间的随机数\n// 乘以数组长度，得到 0 到 数组长度-1 之间的范围\n// Math.floor() 向下取整，得到一个整数索引\nconst randomIndex = Math.floor(Math.random() * petMoods.length);\n\n// 3. 使用随机索引访问数组，获取宠物当前的心情\nconst currentPetState = petMoods[randomIndex];\n\n// 4. 显示结果，让互动更有趣！\nconsole.log(\"--- 你的虚拟宠物状态更新 ---\");\nconsole.log(`你的宠物现在感觉... ${currentPetState.mood}!`);\nconsole.log(`它的表情是: ${currentPetState.emoji}`);\nconsole.log(\"----------------------------\");\nconsole.log(\"快去和它互动吧！也许它想吃点东西或者玩个球？\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-1-数组创建与访问.md", "blockIndex": 4}
{"id": "js-sec-2-1-2", "title": "数组基础方法（push/pop/shift/unshift）", "code": "// 创建一个水果篮子数组\nlet fruits = ['苹果', '香蕉'];\nconsole.log('初始篮子:', fruits);\n\n// 1. push: 在末尾添加一个水果\nfruits.push('橙子');\nconsole.log('push \"橙子\" 后:', fruits);\n\n// 2. pop: 从末尾拿走一个水果\nlet lastFruit = fruits.pop();\nconsole.log('pop 拿走了:', lastFruit);\nconsole.log('pop 之后:', fruits);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-2-数组基础方法（push-pop-shift-unshift）.md", "blockIndex": 0}
{"id": "js-sec-2-1-2", "title": "数组基础方法（push/pop/shift/unshift）", "code": "let playlist = ['歌曲A', '歌曲B', '歌曲C'];\nconsole.log('原始播放列表:', playlist, '长度:', playlist.length);\n\n// unshift: 在开头添加\nplaylist.unshift('歌曲D');\nconsole.log('unshift后，原数组被改变:', playlist, '长度:', playlist.length);\n\n// shift: 从开头移除\nplaylist.shift();\nconsole.log('shift后，原数组再次被改变:', playlist, '长度:', playlist.length);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-2-数组基础方法（push-pop-shift-unshift）.md", "blockIndex": 1}
{"id": "js-sec-2-1-2", "title": "数组基础方法（push/pop/shift/unshift）", "code": "let team = ['队员1', '队员2'];\nconsole.log('初始队伍:', team);\n\n// push 返回新长度\nlet newLengthAfterPush = team.push('队员3');\nconsole.log('push 操作的返回值 (新长度):', newLengthAfterPush);\nconsole.log('push 后的队伍:', team);\n\n// pop 返回被移除的元素\nlet removedMember = team.pop();\nconsole.log('pop 操作的返回值 (被移除的队员):', removedMember);\nconsole.log('pop 后的队伍:', team);\n\n// shift 返回被移除的元素\nlet firstMember = team.shift();\nconsole.log('shift 操作的返回值 (被移除的队员):', firstMember);\nconsole.log('shift 后的队伍:', team);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-2-数组基础方法（push-pop-shift-unshift）.md", "blockIndex": 2}
{"id": "js-sec-2-1-2", "title": "数组基础方法（push/pop/shift/unshift）", "code": "// 假设我们有一个任务列表，想添加新任务并得到更新后的列表\nlet tasks = ['学习', '锻炼'];\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误地以为 push 会返回修改后的数组\nlet wrongTasks = tasks.push('购物');\nconsole.log('错误的变量 wrongTasks 的值:', wrongTasks); // 打印的是数字 3，而不是数组！\nconsole.log('此刻 tasks 数组本身:', tasks); // 数组本身其实已经变了\n// 解释: 这是一个非常常见的错误。开发者将 push 的返回值（新长度）赋给了一个新变量，\n// 期望得到新数组，结果却得到了一个数字，导致后续操作失败。\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确的做法是直接操作原数组，因为它已经被修改了\nlet correctTasks = ['学习', '锻炼'];\ncorrectTasks.push('购物'); // 直接调用方法修改数组\nconsole.log('直接使用原数组 correctTasks:', correctTasks); // 这才是我们想要的结果\n// 解释: 正确的模式是：调用方法，然后继续使用原来的数组变量，因为它已经被更新了。", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-2-数组基础方法（push-pop-shift-unshift）.md", "blockIndex": 3}
{"id": "js-sec-2-1-2", "title": "数组基础方法（push/pop/shift/unshift）", "code": "// 太空探险小队登船队列\nlet missionQueue = ['👩‍🚀 宇航员-爱丽丝', '👨‍🚀 宇航员-鲍勃'];\n\nfunction displayQueue(queue) {\n  console.log(\"----------------------------------------\");\n  if (queue.length === 0) {\n    console.log(\"🚀 队列为空，飞船准备起飞！\");\n  } else {\n    console.log(\"🛰️ 当前登船队列: \", queue.join(' <-- '));\n    console.log(`总共有 ${queue.length} 位宇航员在等待。`);\n  }\n  console.log(\"----------------------------------------\\n\");\n}\n\nconsole.log(\"📢 登船系统启动！\");\ndisplayQueue(missionQueue);\n\n// 场景1: 新宇航员卡萝尔到达，正常排队\nconsole.log(\"✨ 新宇航员卡萝尔到达，加入队尾...\");\nmissionQueue.push('👩‍🚀 宇航员-卡萝尔');\ndisplayQueue(missionQueue);\n\n// 场景2: 舰长戴夫有紧急任务，需要排在最前面！\nconsole.log(\"🔥 紧急情况！舰长戴夫需要优先登船！\");\nmissionQueue.unshift('⭐ 舰长-戴夫');\ndisplayQueue(missionQueue);\n\n// 场景3: 队首的宇航员登船\nconsole.log(`✅ 轮到你了！'${missionQueue[0]}' 正在登船...`);\nlet onboardAstronaut = missionQueue.shift();\nconsole.log(`'${onboardAstronaut}' 已成功登上飞船！`);\ndisplayQueue(missionQueue);\n\n// 场景4: 队尾的宇航员因装备问题暂时离队\nconsole.log(\"❗ 啊哦，队尾的宇航员装备出了一点问题...\");\nlet leavingAstronaut = missionQueue.pop();\nconsole.log(`'${leavingAstronaut}' 暂时离开队列去检查装备了。`);\ndisplayQueue(missionQueue);\n\n// 最终队列\nconsole.log(\"所有操作完成，这是最终的登船队列。\");\ndisplayQueue(missionQueue);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-2-数组基础方法（push-pop-shift-unshift）.md", "blockIndex": 4}
{"id": "js-sec-2-1-3", "title": "数组遍历（for/forEach）", "code": "// 水果篮里有三种水果\nconst fruits = ['🍎 苹果', '🍌 香蕉', '🍊 橘子'];\n\nconsole.log(\"水果篮里有什么？\");\n\n// 使用 for 循环，从索引 0 开始，逐个访问\nfor (let i = 0; i < fruits.length; i++) {\n  // fruits[i] 可以获取到当前循环到的水果\n  console.log(`找到了: ${fruits[i]}`);\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-3-数组遍历（for-forEach）.md", "blockIndex": 0}
{"id": "js-sec-2-1-3", "title": "数组遍历（for/forEach）", "code": "const heroes = ['孙悟空', '猪八戒', '沙悟净'];\n\nconsole.log(\"--- 西天取经团队点名 ---\");\n\n// forEach 接收一个函数，该函数有三个可选参数：\n// 1. element: 当前元素的值\n// 2. index: 当前元素的索引\n// 3. array: 正在遍历的数组本身\nheroes.forEach(function(hero, index, arr) {\n  console.log(`队员${index + 1}: ${hero}`);\n  // 在最后一次迭代时，打印整个团队信息\n  if (index === arr.length - 1) {\n    console.log(`\\n团队全员 (${arr.length}人) 已到齐!`);\n  }\n});", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-3-数组遍历（for-forEach）.md", "blockIndex": 1}
{"id": "js-sec-2-1-3", "title": "数组遍历（for/forEach）", "code": "const treasureMapClues = ['往东走', '找到大树', '危险！有妖怪！', '挖三尺', '找到宝藏'];\n\nconsole.log(\"--- 开始寻宝！---\");\n\nfor (let i = 0; i < treasureMapClues.length; i++) {\n  const clue = treasureMapClues[i];\n  \n  if (clue.includes('危险')) {\n    console.log(`发现线索: \"${clue}\"。太危险了，我们得停下来！`);\n    break; // 遇到危险，立刻停止寻宝（跳出循环）\n  }\n\n  console.log(`执行线索: \"${clue}\"`);\n}\n\nconsole.log(\"--- 寻宝结束 ---\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-3-数组遍历（for-forEach）.md", "blockIndex": 2}
{"id": "js-sec-2-1-3", "title": "数组遍历（for/forEach）", "code": "// 假设我们只想找到第一个偶数就停止\nconst numbers = [1, 3, 5, 4, 7, 8];\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 尝试在 forEach 中使用 break 是无效的，甚至会直接导致语法错误。\n//    我们用 return 来模拟“跳过”或“停止”的意图，但它只会结束当前这次函数调用，循环会继续。\nlet foundNumber_wrong;\nnumbers.forEach(num => {\n  if (foundNumber_wrong) {\n    return; // 以为可以停止，但其实只是结束了本次回调，循环仍在继续\n  }\n  if (num % 2 === 0) {\n    console.log(`(错误的方式) 找到了偶数: ${num}`);\n    foundNumber_wrong = num;\n  }\n});\nconsole.log(`最终找到的数字是: ${foundNumber_wrong}。但注意，循环其实没有停下！`);\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 当需要提前中断循环时，应该使用传统的 for 循环。\nlet foundNumber_correct;\nfor (let i = 0; i < numbers.length; i++) {\n  const num = numbers[i];\n  if (num % 2 === 0) {\n    console.log(`(正确的方式) 找到了偶数: ${num}，停止搜索。`);\n    foundNumber_correct = num;\n    break; // 使用 break 立刻终止整个循环\n  }\n}\nconsole.log(`最终找到的数字是: ${foundNumber_correct}`);\n", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-3-数组遍历（for-forEach）.md", "blockIndex": 3}
{"id": "js-sec-2-1-3", "title": "数组遍历（for/forEach）", "code": "// 定义飞船的关键系统列表\nconst shipSystems = [\n  { name: '🚀 主引擎', status: 'offline' },\n  { name: '🧭 导航系统', status: 'offline' },\n  { name: '🛡️ 能量护盾', status: 'offline' },\n  { name: '🌡️ 生命维持', status: 'offline' },\n  { name: '🤖 AI助手', status: 'error' } // 噢不，有个系统出错了！\n];\n\nlet allSystemsGo = true; // 启动标志，默认为true\n\nconsole.log(\"--- “开拓者号” 启动前自检程序 ---\");\n\n// 使用 forEach 遍历所有系统\nshipSystems.forEach((system, index) => {\n  console.log(`\\n[${index + 1}/${shipSystems.length}] 正在检查: ${system.name}...`);\n  \n  // 模拟一个随机的检测结果\n  const isOk = Math.random() > 0.2 && system.status !== 'error'; // 80%的几率正常，除非本身就是error状态\n  \n  if (isOk) {\n    system.status = 'online';\n    console.log(`✅ ${system.name}... 状态正常，已上线！`);\n  } else {\n    system.status = 'critical_error';\n    allSystemsGo = false; // 任何一个系统出错，都不能起飞\n    console.log(`❌ 警告! ${system.name} 出现严重故障！`);\n  }\n});\n\nconsole.log(\"\\n--- 自检程序结束 ---\");\n\nif (allSystemsGo) {\n  console.log(\"🎉 所有系统准备就绪！引擎点火，准备起飞！\");\n} else {\n  console.log(\"🚨 检测到关键系统故障！起飞程序已中止！请立即联系工程师！\");\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-3-数组遍历（for-forEach）.md", "blockIndex": 4}
{"id": "js-sec-2-1-4", "title": "数组转换方法（map/filter/reduce）", "code": "// 有一个数字数组，代表每个苹果的重量（克）\nconst appleWeights = [150, 180, 210, 165];\n\n// 使用 map 方法，将每个苹果的重量转换为苹果汁的毫升数（假设 1g = 0.7ml）\nconst juiceVolumes = appleWeights.map(weight => weight * 0.7);\n\nconsole.log(\"苹果重量数组:\", appleWeights);\nconsole.log(\"榨出的果汁量数组:\", juiceVolumes);\n// 注意：原始的 appleWeights 数组没有被改变", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-4-数组转换方法（map-filter-reduce）.md", "blockIndex": 0}
{"id": "js-sec-2-1-4", "title": "数组转换方法（map/filter/reduce）", "code": "// 游戏角色数据\nconst characters = [\n  { name: '英雄A', level: 10 },\n  { name: '法师B', level: 20 },\n  { name: '刺客C', level: 15 }\n];\n\n// 需求：我们不关心等级，只想得到一个包含所有角色名字的列表\nconst characterNames = characters.map(char => char.name);\n\nconsole.log(\"原始角色对象数组:\", characters);\nconsole.log(\"转换后的角色名数组:\", characterNames);\n\n// 另一个例子：给每个角色增加一个'title'属性\nconst charactersWithTitle = characters.map(char => {\n  return {\n    name: char.name,\n    level: char.level,\n    title: `Lv.${char.level} 的勇者` // 基于原始数据创建新属性\n  };\n});\n\nconsole.log(\"添加了称号的新角色数组:\", charactersWithTitle);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-4-数组转换方法（map-filter-reduce）.md", "blockIndex": 1}
{"id": "js-sec-2-1-4", "title": "数组转换方法（map/filter/reduce）", "code": "// 一队冒险者，他们的生命值(hp)各不相同\nconst party = [\n  { name: '战士', hp: 150 },\n  { name: '弓箭手', hp: 80 },\n  { name: '牧师', hp: 95 },\n  { name: '坦克', hp: 200 }\n];\n\n// 需求：找出所有生命值低于100，需要治疗的队员\nconst needsHealing = party.filter(member => member.hp < 100);\n\nconsole.log(\"完整的冒险队伍:\", party);\nconsole.log(\"需要治疗的队员:\", needsHealing);\n\n// 另一个例子：找出名字长度大于2的队员\nconst longNameMembers = party.filter(member => member.name.length > 2);\nconsole.log(\"名字较长的队员:\", longNameMembers);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-4-数组转换方法（map-filter-reduce）.md", "blockIndex": 2}
{"id": "js-sec-2-1-4", "title": "数组转换方法（map/filter/reduce）", "code": "// 背包里有一堆战利品，每个都有价值\nconst loot = [\n  { item: '金币', value: 50 },\n  { item: '宝石', value: 200 },\n  { item: '草药', value: 5 },\n  { item: '金币', value: 25 }\n];\n\n// 需求：计算背包里所有物品的总价值\n// reduce 回调函数接收两个主要参数：(accumulator, currentValue)\n// accumulator 是上一次迭代返回的值，currentValue 是当前处理的元素\n// 第二个参数 0 是 accumulator 的初始值\nconst totalValue = loot.reduce((sum, currentItem) => {\n  console.log(`当前总和: ${sum}, 正在加上: ${currentItem.item} (价值 ${currentItem.value})`);\n  return sum + currentItem.value;\n}, 0);\n\nconsole.log(\"背包里的战利品:\", loot);\nconsole.log(\"战利品总价值:\", totalValue);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-4-数组转换方法（map-filter-reduce）.md", "blockIndex": 3}
{"id": "js-sec-2-1-4", "title": "数组转换方法（map/filter/reduce）", "code": "const numbers = [1, 2, 3];\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误: map 的回调函数使用了大括号但没有显式 return\nconst wrongMapResult = numbers.map(num => {\n  // 只是执行了操作，但没有返回任何值\n  num * 2;\n});\nconsole.log(\"错误 map 结果:\", wrongMapResult);\nconsole.log(\"解释: 当使用 `{}` 定义函数体时，必须使用 `return` 关键字返回值。否则，函数默认返回 `undefined`，新数组的每个元素都会是 `undefined`。\");\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确: 使用显式 return\nconst correctMapResult1 = numbers.map(num => {\n  return num * 2;\n});\nconsole.log(\"正确 map 结果 (带 return):\", correctMapResult1);\n\n// ✅ 正确: 使用箭头函数的隐式 return (当函数体只有一行时)\nconst correctMapResult2 = numbers.map(num => num * 2);\nconsole.log(\"正确 map 结果 (隐式 return):\", correctMapResult2);\nconsole.log(\"解释: 两种正确方式都确保了回调函数为每个元素返回了一个计算后的新值，从而正确地构建了新数组。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-4-数组转换方法（map-filter-reduce）.md", "blockIndex": 4}
{"id": "js-sec-2-1-4", "title": "数组转换方法（map/filter/reduce）", "code": "// 烹饪原料库：每个原料都有名字、表情符号、类型和“风味值”\nconst ingredients = [\n  { name: '番茄', emoji: '🍅', type: 'vegetable', flavor: 5 },\n  { name: '奶酪', emoji: '🧀', type: 'dairy', flavor: 8 },\n  { name: '面包', emoji: '🍞', type: 'grain', flavor: 3 },\n  { name: '生菜', emoji: '🥬', type: 'vegetable', flavor: 2 },\n  { name: '牛排', emoji: '🥩', type: 'meat', flavor: 10 },\n  { name: '冰淇淋', emoji: '🍦', type: 'dessert', flavor: 9 },\n];\n\n// 玩家选择的菜谱（原料名称列表）\nconst recipe = ['番茄', '奶酪', '面包', '牛排'];\nconsole.log(`📜 玩家的神秘菜谱: ${recipe.join(' + ')}`);\nconsole.log(\"---\");\n\n// 第1步: 筛选出菜谱中包含的原料对象 (使用 filter 和 includes)\nconst selectedIngredients = ingredients.filter(ingredient => recipe.includes(ingredient.name));\nconsole.log(\"✅ 已选出的原料对象:\", selectedIngredients);\nconsole.log(\"---\");\n\n// 第2步: 将选出的原料“摆盘”，只提取它们的表情符号 (使用 map)\nconst dishEmojis = selectedIngredients.map(ingredient => ingredient.emoji);\nconsole.log(`🍽️ 正在摆盘... 盘子里现在有: ${dishEmojis.join(' ')}`);\nconsole.log(\"---\");\n\n// 第3步: 计算这道菜的总“风味值” (使用 reduce)\nconst totalFlavor = selectedIngredients.reduce((sum, ingredient) => {\n  return sum + ingredient.flavor;\n}, 0);\nconsole.log(`😋 正在品尝... 这道菜的风味值为: ${totalFlavor}`);\nconsole.log(\"---\");\n\n// 最后，根据风味值给出一个有趣的评价\nlet finalDish;\nif (totalFlavor > 20) {\n  finalDish = `[${dishEmojis.join('')}] = 🍕 神级美味！`;\n} else if (totalFlavor > 10) {\n  finalDish = `[${dishEmojis.join('')}] = 🍔 相当不错！`;\n} else {\n  finalDish = `[${dishEmojis.join('')}] = 🥪 嗯...还行吧。`;\n}\n\nconsole.log(\"🎉 铛铛铛！你的表情符号料理完成了！\");\nconsole.log(finalDish);\n\n// 链式操作一步到位！\nconst finalDishChained = ingredients\n    .filter(i => recipe.includes(i.name)) // 筛选\n    .map(i => i.emoji) // 转换\n    .join(''); // 组合成字符串\n\nconsole.log(`\\n🚀 链式操作也能快速上菜: [${finalDishChained}]`);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-4-数组转换方法（map-filter-reduce）.md", "blockIndex": 5}
{"id": "js-sec-2-1-5", "title": "数组查找与判断（find/some/every）", "code": "// 假设我们有一个数字宝箱\nconst treasureChest = [5, 12, 8, 130, 44];\n\n// 1. find: 找到第一个大于10的数字\nconst found = treasureChest.find(num => num > 10);\nconsole.log(`找到了第一个大于10的宝藏: ${found}`); // 输出: 12\n\n// 2. some: 是否有任何一个数字大于100？ (是/否)\nconst hasLargeTreasure = treasureChest.some(num => num > 100);\nconsole.log(`宝箱里有大于100的宝藏吗? ${hasLargeTreasure}`); // 输出: true\n\n// 3. every: 是否每一个数字都小于200？ (是/否)\nconst allAreSmallTreasures = treasureChest.every(num => num < 200);\nconsole.log(`所有宝藏都小于200吗? ${allAreSmallTreasures}`); // 输出: true", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-5-数组查找与判断（find-some-every）.md", "blockIndex": 0}
{"id": "js-sec-2-1-5", "title": "数组查找与判断（find/some/every）", "code": "const adventurers = [\n  { name: 'Alice', class: 'Warrior', level: 15 },\n  { name: 'Bob', class: 'Mage', level: 12 },\n  { name: 'Charlie', class: 'Rogue', level: 18 }\n];\n\n// find 返回符合条件的整个对象\nconst mage = adventurers.find(adventurer => adventurer.class === 'Mage');\nconsole.log('找到的法师:', mage); // 输出: { name: 'Bob', class: 'Mage', level: 12 }\n\n// 如果找不到，返回 undefined\nconst cleric = adventurers.find(adventurer => adventurer.class === 'Cleric');\nconsole.log('找到的牧师:', cleric); // 输出: undefined\n\n// some 只关心“有没有”，返回布尔值\nconst hasHighLevelPlayer = adventurers.some(adventurer => adventurer.level > 15);\nconsole.log('队伍里有高等级玩家吗?', hasHighLevelPlayer); // 输出: true", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-5-数组查找与判断（find-some-every）.md", "blockIndex": 1}
{"id": "js-sec-2-1-5", "title": "数组查找与判断（find/some/every）", "code": "const numbers = [1, 5, 10, 15, 20];\n\nconsole.log('--- some 的短路演示 ---');\n// some 找到 10 > 8 后，就不会再检查 15 和 20\nconst hasNumberGreaterThan8 = numbers.some(num => {\n  console.log(`正在检查: ${num}`);\n  return num > 8;\n});\nconsole.log('结果:', hasNumberGreaterThan8); // 输出: true\n\nconsole.log('\\n--- every 的短路演示 ---');\n// every 检查到 10 > 8 不成立后，就不会再检查 15 和 20\nconst allNumbersLessThan8 = numbers.every(num => {\n  console.log(`正在检查: ${num}`);\n  return num < 8;\n});\nconsole.log('结果:', allNumbersLessThan8); // 输出: false", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-5-数组查找与判断（find-some-every）.md", "blockIndex": 2}
{"id": "js-sec-2-1-5", "title": "数组查找与判断（find/some/every）", "code": "// 假设这是我们的英雄名册\nconst heroes = [\n  { name: 'Iron Man', team: 'Avengers' },\n  { name: 'Captain America', team: 'Avengers' },\n  { name: 'Wonder Woman', team: 'Justice League' },\n  { name: 'Thor', team: 'Avengers' }\n];\n\nconsole.log(\"=== 错误用法：只想找一个，却用了 filter ===\");\n// ❌ 错误：我只想找一个复仇者，但 filter 返回了一个数组\nconst foundAvengerArray = heroes.filter(hero => hero.team === 'Avengers');\nconsole.log(foundAvengerArray); // 输出: [{...}, {...}, {...}]\n// 这导致你需要额外处理数组，比如 `foundAvengerArray[0]`，如果数组为空还会出错。\nconsole.log(\"这样用起来很麻烦，我还要从数组里取第一个元素！\");\n\n\nconsole.log(\"\\n=== 正确用法：只想找一个，就用 find ===\");\n// ✅ 正确：使用 find 直接获取第一个匹配的对象\nconst firstAvenger = heroes.find(hero => hero.team === 'Avengers');\nconsole.log(firstAvenger); // 输出: { name: 'Iron Man', team: 'Avengers' }\n// 这样代码更简洁，意图也更清晰：我只关心第一个符合条件的英雄。\nconsole.log(\"这样就对了，直接拿到我想要的对象！\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-5-数组查找与判断（find-some-every）.md", "blockIndex": 3}
{"id": "js-sec-2-1-5", "title": "数组查找与判断（find/some/every）", "code": "const party = [\n  { name: 'Gandalf', class: 'Mage', hp: 80, inventory: ['Staff', 'Spellbook'] },\n  { name: 'Aragorn', class: 'Warrior', hp: 120, inventory: ['Sword', 'Shield', 'Key'] },\n  { name: 'Legolas', class: 'Archer', hp: 95, inventory: ['Bow', 'Arrows'] },\n  { name: 'Gimli', class: 'Dwarf', hp: 45, inventory: ['Axe', 'Helmet'] }\n];\n\nconsole.log(\"🏰 龙穴探险队 - 出发前最终检查 🏰\\n\");\n\n// 1. 使用 find 找到队伍中的法师，因为我们需要他来施放保护魔法\nconst mage = party.find(member => member.class === 'Mage');\nif (mage) {\n  console.log(`✅ 找到法师: ${mage.name}！可以施放保护魔法了。`);\n} else {\n  console.log(`❌ 警告: 队伍里没有法师，太危险了！`);\n}\n\n// 2. 使用 some 检查是否至少有一个人带了“钥匙”，用来打开龙穴大门\nconst hasKey = party.some(member => member.inventory.includes('Key'));\nif (hasKey) {\n  console.log(`✅ 好消息: ${party.find(m => m.inventory.includes('Key')).name} 带了钥匙！我们可以进入龙穴。`);\n} else {\n  console.log(`❌ 警告: 没人带钥匙！我们会被关在门外的！`);\n}\n\n// 3. 使用 every 检查是否每个队员的生命值(hp)都大于50，否则状态不佳\nconst allMembersAreHealthy = party.every(member => member.hp > 50);\nif (allMembersAreHealthy) {\n  console.log('✅ 全员状态良好，生命值充足！');\n} else {\n  const unhealthyMember = party.find(member => member.hp <= 50);\n  console.log(`❌ 警告: ${unhealthyMember.name} 的生命值过低 (${unhealthyMember.hp}hp)，需要治疗！`);\n}\n\nconsole.log(\"\\n--- 最终检查结果 ---\");\nif (mage && hasKey && allMembersAreHealthy) {\n  console.log(\"🎉 完美！队伍已准备就绪，向恶龙巢穴进发！\");\n} else {\n  console.log(\"🔥 准备不足！请先解决上述问题再出发！\");\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-5-数组查找与判断（find-some-every）.md", "blockIndex": 4}
{"id": "js-sec-2-1-6", "title": "数组排序与反转", "code": "// Level 1: 基础用法\nconst heroes = ['Iron Man', 'Captain America', 'Thor', 'Hulk'];\nconsole.log(\"原始英雄列表:\", heroes);\n\n// 使用 sort() 按字母顺序排序\nheroes.sort();\nconsole.log(\"按字母排序后:\", heroes);\n\n// 使用 reverse() 将排序后的列表反转\nheroes.reverse();\nconsole.log(\"反转排序后:\", heroes);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-6-数组排序与反转.md", "blockIndex": 0}
{"id": "js-sec-2-1-6", "title": "数组排序与反转", "code": "// 定义一个原始数组\nconst originalArray = ['a', 'c', 'b'];\nconsole.log(\"原始数组:\", originalArray);\n\n// 创建一个指向原始数组的引用\nconst referenceToArray = originalArray;\n\n// 对原始数组进行排序\noriginalArray.sort();\n\nconsole.log(\"排序后的原始数组:\", originalArray); // 原始数组被改变\nconsole.log(\"引用的数组也变了:\", referenceToArray); // 引用也指向改变后的数组\n\n// 对已排序的数组进行反转\noriginalArray.reverse();\nconsole.log(\"反转后的原始数组:\", originalArray); // 再次被改变", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-6-数组排序与反转.md", "blockIndex": 1}
{"id": "js-sec-2-1-6", "title": "数组排序与反转", "code": "// 默认排序（字符串排序）\nconst scores = [100, 10, 2, 21];\nconsole.log(\"原始分数:\", scores);\n\n// 默认排序会产生意想不到的结果\n// 因为 \"100\" 在字符串中排在 \"2\" 前面\nscores.sort();\nconsole.log(\"默认排序（错误）:\", scores); // 输出 [10, 100, 2, 21]\n\n// 自定义排序（数值排序）\nconst correctScores = [100, 10, 2, 21];\n// 提供一个比较函数 (a, b) => a - b 来实现升序排列\ncorrectScores.sort((a, b) => a - b);\nconsole.log(\"使用比较函数排序（正确升序）:\", correctScores); // 输出 [2, 10, 21, 100]\n\n// 使用 (a, b) => b - a 实现降序排列\ncorrectScores.sort((a, b) => b - a);\nconsole.log(\"使用比较函数排序（正确降序）:\", correctScores); // 输出 [100, 21, 10, 2]", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-6-数组排序与反转.md", "blockIndex": 2}
{"id": "js-sec-2-1-6", "title": "数组排序与反转", "code": "const playerLevels = [5, 8, 1, 12, 30, 2];\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误：没有提供比较函数，导致按字符串顺序排序\nconst wrongSortedLevels = [...playerLevels]; // 创建副本以防修改原数组\nwrongSortedLevels.sort();\nconsole.log(\"错误排序结果:\", wrongSortedLevels);\n// 解释：数字被转为字符串 \"5\", \"8\", \"1\", \"12\", \"30\", \"2\"。\n// 排序时 \"1\" 在 \"12\" 之后，\"12\" 在 \"2\" 之前，因为比较的是第一个字符。\n\nconsole.log(\"=== 正确用法 ===\");\n// ✅ 正确：提供了比较函数 (a, b) => a - b，实现按数值大小升序排序\nconst correctSortedLevels = [...playerLevels]; // 创建副本\ncorrectSortedLevels.sort((a, b) => a - b);\nconsole.log(\"正确排序结果:\", correctSortedLevels);\n// 解释：当 a - b 返回负数时，a排在b前面；返回正数时，b排在a前面。\n// 这确保了数组按数值大小正确排序。", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-6-数组排序与反转.md", "blockIndex": 3}
{"id": "js-sec-2-1-6", "title": "数组排序与反转", "code": "// 游戏玩家数据，每个对象包含名字和分数\nconst playerScores = [\n  { name: '🚀 TopGun', score: 9850 },\n  { name: '🧑‍🚀 StarLord', score: 7600 },\n  { name: '👾 InvaderX', score: 10500 },\n  { name: '✨ Nova', score: 8800 },\n  { name: '🤖 C-3PO-ops', score: 5200 },\n];\n\nconsole.log(\"--- 🚀 太空射击游戏排行榜 ---\");\nconsole.log(\"原始比赛数据:\", playerScores);\n\n// 1. 按分数从高到低排序，决出宇宙英雄！\n// 我们使用 b.score - a.score 来实现降序排序\nplayerScores.sort((playerA, playerB) => playerB.score - playerA.score);\n\nconsole.log(\"\\n🏆 **最终排行榜** 🏆\");\nplayerScores.forEach((player, index) => {\n  console.log(`#${index + 1}: ${player.name} - ${player.score} 分`);\n});\n\n// 2. 使用 reverse() 快速查看垫底玩家，鼓励他们！\n// 注意：这会再次修改已经排好序的数组\nplayerScores.reverse();\n\nconsole.log(\"\\n--- 😅 新手飞行员鼓励榜 ---\");\nconsole.log(\"别灰心，下次加油！\");\nfor (let i = 0; i < 3; i++) {\n  if (playerScores[i]) {\n    console.log(`- ${playerScores[i].name} (${playerScores[i].score} 分)`);\n  }\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-6-数组排序与反转.md", "blockIndex": 4}
{"id": "js-sec-2-1-7", "title": "数组解构赋值", "code": "// 假设我们有一个数组，存储了比赛的前三名分数\nconst playerScores = [120, 95, 88];\n\n// 传统方式：需要三行代码来分别获取\n// const firstPlace = playerScores[0];\n// const secondPlace = playerScores[1];\n// const thirdPlace = playerScores[2];\n\n// ✨ 使用数组解构赋值：一行代码搞定！\nconst [firstPlace, secondPlace, thirdPlace] = playerScores;\n\nconsole.log(`冠军分数: ${firstPlace}`);\nconsole.log(`亚军分数: ${secondPlace}`);\nconsole.log(`季军分数: ${thirdPlace}`);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-7-数组解构赋值.md", "blockIndex": 0}
{"id": "js-sec-2-1-7", "title": "数组解构赋值", "code": "const raceResults = [\"🥇 Gold\", \"🥈 Silver\", \"🥉 Bronze\", \"Participant\"];\n\n// 我们只关心金牌和铜牌得主，所以用一个逗号跳过银牌\nconst [goldMedal, , bronzeMedal] = raceResults;\n\nconsole.log(`金牌得主是: ${goldMedal}`);\nconsole.log(`我们跳过了银牌得主...`);\nconsole.log(`铜牌得主是: ${bronzeMedal}`);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-7-数组解构赋值.md", "blockIndex": 1}
{"id": "js-sec-2-1-7", "title": "数组解构赋值", "code": "const teamLineup = [\"Captain America\", \"Iron Man\", \"Thor\", \"Hulk\", \"Black Widow\"];\n\n// 选出队长和副队长，其余的作为后备队员\nconst [captain, viceCaptain, ...otherMembers] = teamLineup;\n\nconsole.log(`队长: ${captain}`);\nconsole.log(`副队长: ${viceCaptain}`);\nconsole.log(`其他队员:`, otherMembers); // otherMembers 是一个包含剩下所有队员的新数组\nconsole.log(`后备队员有 ${otherMembers.length} 名。`);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-7-数组解构赋值.md", "blockIndex": 2}
{"id": "js-sec-2-1-7", "title": "数组解构赋值", "code": "const questRewards = [\"Magic Sword\"];\n\n// 任务奖励至少有一件，但可能没有第二件或第三件\n// 为第二、三件奖励设置默认值\nconst [reward1, reward2 = \"Health Potion\", reward3 = \"10 Gold Coins\"] = questRewards;\n\nconsole.log(`你获得了第一件奖励: ${reward1}`);\nconsole.log(`你获得了第二件奖励: ${reward2}`); // 数组中没有第二个值，使用了默认值\nconsole.log(`你获得了第三件奖励: ${reward3}`); // 数组中没有第三个值，使用了默认值\n\nconsole.log(\"\\n--- 另一个奖励更丰厚的任务 ---\");\nconst fullQuestRewards = [\"Legendary Shield\", \"Elixir\"];\nconst [item1, item2 = \"Health Potion\"] = fullQuestRewards;\nconsole.log(`你获得了: ${item1}`);\nconsole.log(`你还获得了: ${item2}`); // 数组中有第二个值\"Elixir\"，所以默认值被忽略", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-7-数组解构赋值.md", "blockIndex": 3}
{"id": "js-sec-2-1-7", "title": "数组解构赋值", "code": "console.log(\"=== 错误用法 ===\");\n// ❌ 尝试解构一个不存在的值 (null 或 undefined)\nfunction getPlayerScores() {\n  // 假设API调用失败，返回了null\n  return null;\n}\n\ntry {\n  const [score1, score2] = getPlayerScores();\n  console.log(score1, score2);\n} catch (error) {\n  console.error(\"出错了!\", error.message);\n  console.log(\"解释: 不能对 null 或 undefined 进行解构，因为它们不是可迭代的。这会抛出 TypeError。\");\n}\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 在解构前提供一个备用空数组\nfunction getSafePlayerScores() {\n  // 假设API调用失败，返回了null\n  return null;\n}\n\n// 使用 || 操作符提供一个默认的空数组，避免程序崩溃\n// 并且可以结合默认值为变量提供最终保障\nconst [safeScore1 = 0, safeScore2 = 0] = getSafePlayerScores() || [];\n\nconsole.log(`安全获取的分数1: ${safeScore1}`);\nconsole.log(`安全获取的分数2: ${safeScore2}`);\nconsole.log(\"解释: 通过 `|| []`，我们确保即使函数返回 null，解构操作的对象也是一个空数组。这样不仅避免了程序崩溃，还可以结合默认值来保证变量总有合理的初始值。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-7-数组解构赋值.md", "blockIndex": 4}
{"id": "js-sec-2-1-7", "title": "数组解构赋值", "code": "// 场景：在一个角色扮演游戏中，玩家的角色需要释放一个强大的咒语！\n// 每个咒语都是一个数组，包含 [名称, 魔法消耗, 效果描述]\n\nfunction castSpell(character, spell) {\n  console.log(`✨ ${character.name} 准备释放咒语...`);\n\n  // 使用解构赋值，清晰地从 spell 数组中获取信息\n  const [spellName, manaCost, effect] = spell;\n\n  console.log(`咒语名称: \"${spellName}\" (需要 ${manaCost}点魔法)`);\n\n  if (character.mana >= manaCost) {\n    // 扣除魔法值\n    character.mana -= manaCost;\n    console.log(`💥 释放成功! ${effect}`);\n    console.log(`${character.name} 剩余魔法: ${character.mana}`);\n  } else {\n    const manaNeeded = manaCost - character.mana;\n    console.log(`❌ 魔法不足! 还需要 ${manaNeeded}点魔法才能释放 \"${spellName}\"。`);\n  }\n  console.log(\"--------------------\");\n}\n\n// 定义我们的英雄角色\nconst hero = {\n  name: \"光明法师\",\n  mana: 80,\n};\n\n// 定义咒语列表\nconst fireball = [\"烈焰风暴\", 50, \"对所有敌人造成火焰伤害🔥\"];\nconst heal = [\"治愈之光\", 35, \"恢复了大量生命值💚\"];\nconst shield = [\"奥术护盾\", 90, \"制造一个强大的魔法护盾🛡️\"];\n\n// 开始施法！\ncastSpell(hero, fireball); // 魔法足够 (80 - 50 = 30)\ncastSpell(hero, heal);     // 魔法不够了 (30 < 35)\ncastSpell(hero, shield);   // 魔法更不够了 (30 < 90)", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-1-7-数组解构赋值.md", "blockIndex": 5}
{"id": "js-sec-2-2-1", "title": "对象创建与属性访问", "code": "// 创建一个表示宠物的对象\nconst myPet = {\n  name: \"咪咪\",\n  age: 2,\n  color: \"橘色\"\n};\n\n// 使用 \"点表示法\" (dot notation) 访问对象的属性\nconsole.log(\"我的宠物叫什么名字？\", myPet.name);\nconsole.log(\"它多大了？\", myPet.age);\nconsole.log(\"它是什么颜色的？\", myPet.color);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-1-对象创建与属性访问.md", "blockIndex": 0}
{"id": "js-sec-2-2-1", "title": "对象创建与属性访问", "code": "const character = {\n  name: \"艾拉\",\n  \"class-type\": \"法师\", // 属性名包含特殊字符'-'\n  level: 10\n};\n\n// 1. 使用点表示法访问常规属性\nconsole.log(\"角色名称:\", character.name);\n\n// 2. 使用方括号表示法访问包含特殊字符的属性\n//    注意：属性名需要用引号包裹，像一个字符串\nconsole.log(\"角色职业:\", character[\"class-type\"]);\n\n// 3. 使用方括号表示法通过变量动态访问属性\nconst propToAccess = \"level\";\nconsole.log(\"角色等级:\", character[propToAccess]);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-1-对象创建与属性访问.md", "blockIndex": 1}
{"id": "js-sec-2-2-1", "title": "对象创建与属性访问", "code": "// 创建一个无人机对象\nconst drone = {\n  id: \"X-001\",\n  status: \"待命\"\n};\n\nconsole.log(\"初始状态:\", drone.status);\n\n// 修改现有属性的值\ndrone.status = \"正在飞行\";\nconsole.log(\"更新后状态:\", drone.status);\n\n// 添加一个全新的属性\ndrone.batteryLevel = \"87%\";\nconsole.log(\"新增电池信息:\", drone.batteryLevel);\n\nconsole.log(\"无人机最终信息:\", drone);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-1-对象创建与属性访问.md", "blockIndex": 2}
{"id": "js-sec-2-2-1", "title": "对象创建与属性访问", "code": "const player = {\n  username: \"CoolGamer123\",\n  score: 9500\n};\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 尝试访问一个不存在的属性 `rank`\nconst playerRank = player.rank;\nconsole.log(\"玩家等级:\", playerRank); // 输出 undefined\n// 解释: `player` 对象上没有 `rank` 这个属性，所以返回 `undefined`。\n// 如果后续代码依赖 `playerRank` 做计算，比如 playerRank.toUpperCase()，就会立即报错。\n\nconsole.log(\"=== 正确用法 ===\");\n// ✅ 在访问前，先检查属性是否存在\nif (player.rank) {\n  console.log(\"玩家等级:\", player.rank);\n} else {\n  console.log(\"该玩家还没有等级信息。\");\n}\n// 解释: 通过条件判断，我们可以安全地处理属性可能不存在的情况，避免程序因 `undefined` 值而出错。", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-1-对象创建与属性访问.md", "blockIndex": 3}
{"id": "js-sec-2-2-1", "title": "对象创建与属性访问", "code": "// 1. 创建我们的英雄角色\nconst hero = {\n  name: \"阿尔文\",\n  level: 5,\n  hp: 100,\n  attack: 15,\n  inventory: [\"治疗药水\", \"地图\"],\n  skills: {\n    \"普通攻击\": \"挥剑斩击\"\n  }\n};\n\nconsole.log(`🌟 冒险开始！英雄 ${hero.name} 踏上了征程！`);\nconsole.log(\"初始攻击力:\", hero.attack);\nconsole.log(\"当前物品:\", hero.inventory);\n\n// 2. 英雄在森林里发现了一把“精灵之刃”！\nconst newItem = \"精灵之刃\";\nconst attackBonus = 10;\nconst newSkillName = \"风之切割\"; // 技能名包含中文，最好用方括号\n\nconsole.log(`\\n🎉 哇！${hero.name} 找到了传说中的【${newItem}】！`);\n\n// 3. 更新英雄的属性和物品\n// 增加攻击力\nhero.attack = hero.attack + attackBonus;\n// 将新物品添加到背包\nhero.inventory.push(newItem);\n// 使用方括号表示法学习一个新技能\nhero.skills[newSkillName] = \"召唤一阵锋利的风刃攻击敌人\";\n\n// 4. 展示英雄升级后的状态\nconsole.log(\"\\n--- 英雄状态更新 ---\");\nconsole.log(`💪 攻击力提升至: ${hero.attack} (原 ${hero.attack - attackBonus} + ${attackBonus} 加成)`);\nconsole.log(`🎒 背包更新: ${hero.inventory.join(\", \")}`);\nconsole.log(`📖 新学会的技能【${newSkillName}】: ${hero.skills[newSkillName]}`);\nconsole.log(\"--- 冒险继续！ ---\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-1-对象创建与属性访问.md", "blockIndex": 4}
{"id": "js-sec-2-2-2", "title": "属性的增删改查", "code": "// 1. 创建一个代表英雄信息的对象\nlet hero = {\n  name: '爱丽丝',\n  level: 1\n};\nconsole.log('初始状态:', hero);\n\n// 2. 增 (Create): 添加一个新属性 \"weapon\"\nhero.weapon = '光之剑';\nconsole.log('习得武器后:', hero);\n\n// 3. 改 (Update): 修改属性 \"level\"\nhero.level = 2;\nconsole.log('升级后:', hero);\n\n// 4. 查 (Read): 读取属性 \"name\"\nconsole.log('英雄的名字是:', hero.name);\n\n// 5. 删 (Delete): 删除属性 \"weapon\"\ndelete hero.weapon;\nconsole.log('武器丢失后:', hero);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-2-属性的增删改查.md", "blockIndex": 0}
{"id": "js-sec-2-2-2", "title": "属性的增删改查", "code": "let character = {\n  name: \"探险家小明\",\n  \"current city\": \"迷雾森林\" // 属性名包含空格，只能用方括号\n};\n\n// 使用点表示法读取常规属性\nconsole.log(\"用点访问名字:\", character.name);\n\n// 使用方括号表示法读取带特殊字符的属性\nconsole.log(\"用方括号访问城市:\", character[\"current city\"]);\n\n// 方括号的强大之处：使用变量作为属性名\nlet propToGet = \"name\";\nconsole.log(`通过变量 \"${propToGet}\" 访问:`, character[propToGet]);\n\n// 动态添加属性\nlet newStat = \"agility\";\ncharacter[newStat] = 88;\nconsole.log(\"动态添加属性后:\", character);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-2-属性的增删改查.md", "blockIndex": 1}
{"id": "js-sec-2-2-2", "title": "属性的增删改查", "code": "let gameSettings = {\n  difficulty: 'normal',\n  musicVolume: 80,\n  autosave: true\n};\nconsole.log(\"初始设置:\", gameSettings);\n\n// 使用 delete 移除 autosave 属性\ndelete gameSettings.autosave;\nconsole.log(\"删除 autosave 后:\", gameSettings);\n\n// 检查属性是否存在\n// 'autosave' in gameSettings 会返回 false，因为属性已彻底移除\nconsole.log(\"设置中还有 autosave 吗?\", 'autosave' in gameSettings); ", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-2-属性的增删改查.md", "blockIndex": 2}
{"id": "js-sec-2-2-2", "title": "属性的增删改查", "code": "// 准备一个包含临时效果的玩家对象\nlet player = {\n  hp: 100,\n  mana: 50,\n  tempBuff: 'strength' // 临时力量增益\n};\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 试图通过赋值 undefined 来“删除”属性\nplayer.tempBuff = undefined;\nconsole.log(\"赋值 undefined 后:\", player);\nconsole.log(\"玩家属性列表:\", Object.keys(player));\n// 解释：可以看到 'tempBuff' 属性的键名依然存在于对象中，只是它的值变成了 undefined。\n// 这在某些情况下（如遍历对象属性）会产生意想不到的副作用。\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 重新设置玩家对象以进行正确演示\nlet correctPlayer = {\n  hp: 100,\n  mana: 50,\n  tempBuff: 'strength'\n};\nconsole.log(\"初始玩家状态:\", correctPlayer);\n\n// 使用 delete 彻底移除属性\ndelete correctPlayer.tempBuff;\nconsole.log(\"使用 delete 后:\", correctPlayer);\nconsole.log(\"玩家属性列表:\", Object.keys(correctPlayer));\n// 解释：'tempBuff' 属性被完全移除了，Object.keys() 返回的数组中不再包含它。\n// 这才是真正的“删除”操作。", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-2-属性的增删改查.md", "blockIndex": 3}
{"id": "js-sec-2-2-2", "title": "属性的增删改查", "code": "// 你的专属数字宠物\nlet myPet = {\n  name: \"皮卡丘\",\n  type: \"电系\",\n  happiness: 50, // 快乐度\n  skills: [\"卖萌\", \"打滚\"]\n};\n\nconsole.log(`🌟 你领养了一只叫【${myPet.name}】的宠物！`);\nconsole.log(\"初始状态:\", myPet);\n\n// --- 互动开始 ---\n\n// 1. 改 (Update): 陪它玩耍，提升快乐度\nconsole.log(\"\\n陪皮卡丘玩了扔球游戏...\");\nmyPet.happiness += 30;\nconsole.log(`【${myPet.name}】的快乐度提升了！现在是: ${myPet.happiness}`);\n\n// 2. 增 (Create): 它学会了新技能！\nconsole.log(\"\\n经过训练，皮卡丘学会了新技能！\");\nmyPet.skills.push(\"十万伏特\"); // 这是对数组属性内部的修改，广义上也算“增”\nmyPet.favoriteFood = \"番茄酱\"; // 添加一个全新的属性\nconsole.log(\"现在的技能和喜好:\", { skills: myPet.skills, food: myPet.favoriteFood });\n\n// 3. 查 (Read): 检查它的状态\nconsole.log(`\\n你想知道【${myPet.name}】最喜欢的食物是什么？`);\nconsole.log(`答案是: ${myPet.favoriteFood}`);\n\n// 4. 删 (Delete): 它吃掉了你给的临时道具“能量方块”\nmyPet.inventory = { tempItem: \"能量方块\" };\nconsole.log(`\\n你给了【${myPet.name}】一个临时道具:`, myPet.inventory.tempItem);\nconsole.log(\"吃掉道具...\");\ndelete myPet.inventory.tempItem; // 道具被消耗，从物品栏移除\n// 检查物品栏是否变空\nif (Object.keys(myPet.inventory).length === 0) {\n  console.log(\"道具栏现在空了！\");\n  delete myPet.inventory; // 如果物品栏对象空了，可以把整个 inventory 属性也删掉\n}\nconsole.log(\"最终宠物状态:\", myPet);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-2-属性的增删改查.md", "blockIndex": 4}
{"id": "js-sec-2-2-3", "title": "对象方法与this", "code": "// Level 1: 基础认知\nconst character = {\n  name: \"闪电侠\",\n  introduce: function() {\n    // 在这个方法里，`this` 指的就是 `character` 这个对象\n    console.log(\"你好，我叫 \" + this.name + \"！\");\n  }\n};\n\n// 当 character 调用 introduce 方法时，this 就指向 character\ncharacter.introduce();", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-3-对象方法与this.md", "blockIndex": 0}
{"id": "js-sec-2-2-3", "title": "对象方法与this", "code": "// Level 2, 特性1: this 指向调用者\nfunction showStats() {\n  console.log(`角色名: ${this.name}, 等级: ${this.level}, 职业: ${this.job}`);\n}\n\nconst warrior = {\n  name: \"阿尔萨斯\",\n  level: 80,\n  job: \"死亡骑士\",\n  getStats: showStats // 将函数赋给 warrior 的 getStats 方法\n};\n\nconst mage = {\n  name: \"吉安娜\",\n  level: 78,\n  job: \"大法师\",\n  getStats: showStats // 将同一个函数赋给 mage 的 getStats 方法\n};\n\n// 当 warrior 调用时，this 指向 warrior\nconsole.log(\"战士信息：\");\nwarrior.getStats(); \n\n// 当 mage 调用时，this 指向 mage\nconsole.log(\"\\n法师信息：\");\nmage.getStats();", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-3-对象方法与this.md", "blockIndex": 1}
{"id": "js-sec-2-2-3", "title": "对象方法与this", "code": "// Level 2, 特性2: 全局上下文中的 this\n// 'use strict'; // 尝试取消注释这行，看看结果有何不同\n\n// 为了在任何环境中都能看到效果，我们模拟一个全局变量\nvar globalName = \"全局对象\";\n\nfunction whoAmI() {\n  // 在 Node.js 的模块作用域中，顶层的 this 是一个空对象 {} 或模块的 exports\n  // 在浏览器中，顶层的 this 是 window 对象\n  // 这里我们直接调用函数，而不是通过对象\n  // 在非严格模式的浏览器中，this.name 会是 \"全局对象\"\n  // 在严格模式或Node.js模块中，this 可能是 undefined 或 {}，导致 this.name 出错\n  // 为了示例的健壮性，我们先检查 this\n  if (this && this.name) {\n    console.log(\"我属于: \" + this.name);\n  } else if (this === undefined) {\n    console.log(\"在严格模式下，'this' 是 undefined。\");\n  } else {\n    console.log(\"在当前上下文中，'this' 没有 name 属性。\");\n  }\n}\n\nconst hero = {\n  name: \"钢铁侠\",\n  whoAmI: whoAmI\n};\n\nconsole.log(\"通过对象调用:\");\nhero.whoAmI(); // this 指向 hero 对象\n\nconsole.log(\"\\n直接调用:\");\nwhoAmI(); // this 指向全局对象（浏览器）或 undefined（严格模式）", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-3-对象方法与this.md", "blockIndex": 2}
{"id": "js-sec-2-2-3", "title": "对象方法与this", "code": "// Level 3: 对比学习 - 上下文丢失\nconst player = {\n  name: \"马里奥\",\n  coins: 10,\n  collectCoin: function() {\n    this.coins++;\n    console.log(`${this.name} 收集了一枚金币！现在有 ${this.coins} 枚金币。`);\n  },\n  oops: function() {\n    // 这里的 this.name 会是 undefined，因为 this 不再是 player\n    console.log(`糟糕！${this.name} 丢失了上下文，无法找到金币数量。`);\n  }\n};\n\nconsole.log(\"=== 正确用法 ===\");\n// ✅直接通过对象调用方法，`this` 指向 `player` 对象。\nplayer.collectCoin();\n\n\nconsole.log(\"\\n=== 错误用法 ===\");\n// ❌ 将方法赋值给一个新变量\nconst collectAction = player.collectCoin;\n\ntry {\n  // 直接调用这个新变量，此时它是一个普通函数调用。\n  // `this` 指向全局对象或 undefined（严格模式），而不是 `player`。\n  // 这会导致 `this.coins` 变成 `undefined++`，结果是 NaN (Not a Number)。\n  // `this.name` 也是 undefined。\n  collectAction(); \n} catch (e) {\n  // 在严格模式下，this 是 undefined，访问 this.coins 会直接抛出 TypeError。\n  console.error(\"出错了! 错误信息:\", e.message);\n  console.log(\"错误原因：当我们将 player.collectCoin 赋值给 collectAction 并直接调用时，'this' 的上下文丢失了。\");\n}\n\n// 为了更清晰地展示问题，我们调用一个不会报错但结果错误的方法\nconst oopsAction = player.oops;\noopsAction();\n", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-3-对象方法与this.md", "blockIndex": 3}
{"id": "js-sec-2-2-3", "title": "对象方法与this", "code": "// Level 4: 虚拟宠物养成游戏\nconst virtualPet = {\n  name: \"皮卡丘\",\n  happiness: 50, // 快乐值 (0-100)\n  energy: 60,    // 能量值 (0-100)\n\n  // 喂食方法\n  feed: function() {\n    console.log(`你喂了 ${this.name} 一些美味的树果...`);\n    this.happiness += 10;\n    this.energy += 15;\n    if (this.happiness > 100) this.happiness = 100;\n    if (this.energy > 100) this.energy = 100;\n    console.log(`${this.name} 开心地叫了一声：“皮卡~皮卡~！”`);\n    this.checkStatus();\n  },\n\n  // 玩耍方法\n  play: function() {\n    console.log(`你和 ${this.name} 玩起了抛球游戏...`);\n    if (this.energy < 20) {\n      console.log(`${this.name} 看起来太累了，不想玩...`);\n      return; // 能量不足，直接返回\n    }\n    this.happiness += 15;\n    this.energy -= 20;\n    if (this.happiness > 100) this.happiness = 100;\n    console.log(`${this.name} 玩得很开心，对你的好感度增加了！`);\n    this.checkStatus();\n  },\n\n  // 睡觉方法\n  sleep: function() {\n    console.log(`${this.name} 打了个哈欠，准备去睡觉了... Zzzz...`);\n    this.energy = 100; // 能量回满\n    this.happiness -= 5; // 睡太久可能有点无聊\n    if (this.happiness < 0) this.happiness = 0;\n    console.log(`一觉醒来，${this.name} 精神焕发！`);\n    this.checkStatus();\n  },\n\n  // 查看状态方法\n  checkStatus: function() {\n    let statusEmoji = \"😊\";\n    if (this.happiness < 30) statusEmoji = \"😢\";\n    else if (this.happiness < 60) statusEmoji = \"😐\";\n\n    let energyEmoji = \"⚡️\";\n    if (this.energy < 30) energyEmoji = \"🔋\";\n    else if (this.energy < 60) energyEmoji = \"🔌\";\n\n    console.log(`--- ${this.name} 的状态 ---`);\n    console.log(`快乐值: ${this.happiness} ${statusEmoji}`);\n    console.log(`能量值: ${this.energy} ${energyEmoji}`);\n    console.log(`-----------------------\\n`);\n  }\n};\n\n// 让我们开始和宠物互动吧！\nconsole.log(`你领养了一只叫 ${virtualPet.name} 的宠物！`);\nvirtualPet.checkStatus();\n\nvirtualPet.play();\nvirtualPet.feed();\nvirtualPet.sleep();", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-3-对象方法与this.md", "blockIndex": 4}
{"id": "js-sec-2-2-4", "title": "对象遍历", "code": "// 创建一个表示宠物的对象\nconst myPet = {\n  name: \"旺财\",\n  type: \"狗狗\",\n  age: 3\n};\n\nconsole.log(\"开始介绍我的宠物：\");\n\n// 使用 for...in 循环遍历对象的每个属性\nfor (const key in myPet) {\n  // key 是属性名 (如 \"name\", \"type\", \"age\")\n  // myPet[key] 是对应的属性值 (如 \"旺财\", \"狗狗\", 3)\n  console.log(`- ${key}: ${myPet[key]}`);\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-4-对象遍历.md", "blockIndex": 0}
{"id": "js-sec-2-2-4", "title": "对象遍历", "code": "// 创建一个“父类”构造函数\nfunction Animal(sound) {\n  this.sound = sound;\n}\n\n// 在 Animal 的原型上添加一个方法\nAnimal.prototype.makeSound = function() {\n  console.log(this.sound);\n};\n\n// 创建一个“子类”实例\nconst dog = new Animal(\"汪汪汪\");\ndog.name = \"旺财\";\ndog.age = 3;\n\nconsole.log(\"--- 未使用 hasOwnProperty ---\");\n// 这个循环会打印出 name, age, sound, 甚至 makeSound\nfor (const key in dog) {\n  console.log(`属性: ${key}`);\n}\n\nconsole.log(\"\\n--- 使用 hasOwnProperty 过滤 ---\");\n// 这个循环只打印 dog 对象自身的属性\nfor (const key in dog) {\n  if (dog.hasOwnProperty(key)) {\n    console.log(`自有属性: ${key}`);\n  }\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-4-对象遍历.md", "blockIndex": 1}
{"id": "js-sec-2-2-4", "title": "对象遍历", "code": "const characterStats = {\n  hp: 100,\n  mp: 50,\n  attack: 15,\n  defense: 8\n};\n\n// 1. 只遍历键 (Keys)\nconsole.log(\"--- Object.keys() ---\");\nconst statKeys = Object.keys(characterStats);\nstatKeys.forEach(key => {\n  console.log(`统计项: ${key}`);\n});\n\n// 2. 只遍历值 (Values)\nconsole.log(\"\\n--- Object.values() ---\");\nconst statValues = Object.values(characterStats);\nstatValues.forEach(value => {\n  console.log(`数值: ${value}`);\n});\n\n// 3. 同时遍历键和值 (Entries)\nconsole.log(\"\\n--- Object.entries() ---\");\nconst statEntries = Object.entries(characterStats);\nstatEntries.forEach(([key, value]) => {\n  console.log(`属性 ${key} 的值为 ${value}`);\n});", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-4-对象遍历.md", "blockIndex": 2}
{"id": "js-sec-2-2-4", "title": "对象遍历", "code": "// 假设在某个库或者旧代码中，有人不小心污染了 Object 的原型\nObject.prototype.isLegacy = true;\n\nconst userProfile = {\n  username: \"Alice\",\n  level: 99\n};\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 直接使用 for...in，没有检查 hasOwnProperty\n// 这会把原型链上的 'isLegacy' 也当作 userProfile 的属性打印出来，导致意外行为。\nfor (const key in userProfile) {\n  console.log(`${key}: ${userProfile[key]}`);\n}\nconsole.log(\"错误原因：遍历到了不属于对象自身的、来自原型链的属性 'isLegacy'。\");\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 使用 Object.keys() 配合 forEach，这是最推荐的现代做法\n// 它只会遍历对象自身的属性，完全不受原型链污染的影响。\nObject.keys(userProfile).forEach(key => {\n  console.log(`${key}: ${userProfile[key]}`);\n});\nconsole.log(\"正确原因：Object.keys() 明确只获取对象自身的键，更安全、可预测。\");\n\n// 清理原型污染，以免影响其他示例\ndelete Object.prototype.isLegacy;", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-4-对象遍历.md", "blockIndex": 3}
{"id": "js-sec-2-2-4", "title": "对象遍历", "code": "function createCharacterSheet(character) {\n  console.log(\"================================\");\n  console.log(\"⚔️  你的冒险者角色卡  ⚔️\");\n  console.log(\"================================\");\n\n  const iconMapping = {\n    name: \"👤\",\n    class: \"🛡️\",\n    level: \"🌟\",\n    hp: \"❤️\",\n    mp: \"💧\",\n    inventory: \"🎒\",\n    gold: \"💰\"\n  };\n\n  // 使用 Object.entries() 是最优雅的方式，可以同时拿到 key 和 value\n  for (const [key, value] of Object.entries(character)) {\n    // 根据 key 获取对应的 icon，如果没有就用一个默认的\n    const icon = iconMapping[key] || \"🔹\";\n\n    let displayValue;\n\n    // 如果值是数组（比如 inventory），我们把它格式化成一个漂亮的列表\n    if (Array.isArray(value)) {\n      displayValue = value.join(\", \");\n    } else {\n      displayValue = value;\n    }\n\n    // 将 key 的首字母大写，让输出更美观\n    const formattedKey = key.charAt(0).toUpperCase() + key.slice(1);\n\n    console.log(`${icon} ${formattedKey}: ${displayValue}`);\n  }\n\n  console.log(\"================================\");\n  console.log(\"旅途愉快，勇敢的冒险者！\");\n}\n\n// 定义你的角色信息\nconst myHero = {\n  name: \"闪电侠客\",\n  class: \"游侠\",\n  level: 12,\n  hp: 150,\n  mp: 80,\n  inventory: [\"长弓\", \"治疗药水\", \"地图\"],\n  gold: 250\n};\n\n// 调用函数，生成角色卡！\ncreateCharacterSheet(myHero);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-4-对象遍历.md", "blockIndex": 4}
{"id": "js-sec-2-2-5", "title": "对象解构赋值", "code": "// 创建一个代表游戏角色的对象\nconst player = {\n  name: '闪电侠',\n  level: 99,\n  health: 100,\n  mana: 80\n};\n\n// 传统方式：逐个访问属性\n// const name = player.name;\n// const level = player.level;\n// console.log(name); // 输出: 闪电侠\n// console.log(level); // 输出: 99\n\n// ✨ 使用解构赋值的方式\nconst { name, level } = player;\n\nconsole.log(`欢迎英雄 ${name}！你的等级是 ${level}。`);\n// 输出: 欢迎英雄 闪电侠！你的等级是 99。", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-5-对象解构赋值.md", "blockIndex": 0}
{"id": "js-sec-2-2-5", "title": "对象解构赋值", "code": "const characterProfile = {\n  nickname: '代码巫师',\n  rank: 'S',\n  skill: '快速编码'\n};\n\n// 将属性 nickname 赋值给新变量 wizardName\n// 将属性 rank 赋值给新变量 tier\nconst { nickname: wizardName, rank: tier } = characterProfile;\n\n// console.log(nickname); // 这会报错，因为 nickname 未被定义\nconsole.log(`你好, ${wizardName}! 你的评级是 ${tier}。`);\n// 输出: 你好, 代码巫师! 你的评级是 S。", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-5-对象解构赋值.md", "blockIndex": 1}
{"id": "js-sec-2-2-5", "title": "对象解构赋值", "code": "const pet = {\n  petName: '旺财',\n  age: 2\n};\n\n// 'species' 属性在 pet 对象中不存在，所以会使用默认值 '狗狗'\n// 'petName' 属性存在，所以会使用对象中的值 '旺财'\nconst { petName, species = '狗狗', age } = pet;\n\nconsole.log(`${petName} 是一只 ${age} 岁的 ${species}。`);\n// 输出: 旺财 是一只 2 岁的 狗狗。", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-5-对象解构赋值.md", "blockIndex": 2}
{"id": "js-sec-2-2-5", "title": "对象解构赋值", "code": "const gameSettings = {\n  player: 'Alex',\n  difficulty: 'Hard',\n  graphics: {\n    resolution: '1920x1080',\n    shadowQuality: 'High',\n    textureDetail: 'Ultra'\n  }\n};\n\n// 从嵌套的 graphics 对象中提取 shadowQuality\nconst { difficulty, graphics: { shadowQuality } } = gameSettings;\n\nconsole.log(`当前游戏难度: ${difficulty}`);\nconsole.log(`阴影质量已设置为: ${shadowQuality}`);\n// 输出:\n// 当前游戏难度: Hard\n// 阴影质量已设置为: High", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-5-对象解构赋值.md", "blockIndex": 3}
{"id": "js-sec-2-2-5", "title": "对象解构赋值", "code": "// 模拟一个可能返回 null 的函数\nfunction findCharacter(name) {\n  if (name === '英雄A') {\n    return { name: '英雄A', power: 100 };\n  }\n  return null; // 找不到角色时返回 null\n}\n\nconsole.log(\"=== 错误用法 ===\");\ntry {\n  // ❌ 尝试对 null 进行解构，会抛出 TypeError\n  const { power } = findCharacter('英雄B');\n  console.log(power);\n} catch (error) {\n  console.error(\"错误！不能对 null 或 undefined 进行解构。\");\n  console.error(error.message);\n  // 输出: 错误！不能对 null 或 undefined 进行解构。\n  // 输出: Cannot destructure property 'power' of 'null' as it is null.\n}\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 在解构时提供一个默认的空对象 {} 作为备用\n// 如果 findCharacter 返回 null，我们解构的就是 {}，而不是 null\nconst { power = 5 } = findCharacter('英雄B') || {};\n\nconsole.log(`角色B的力量值（使用默认值）: ${power}`);\n// 解释：当 findCharacter('英雄B') 返回 null 时，`null || {}` 的结果是 `{}`。\n// 对一个空对象解构 power 属性，由于找不到，所以会使用默认值 5。\n// 输出: 角色B的力量值（使用默认值）: 5", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-5-对象解构赋值.md", "blockIndex": 4}
{"id": "js-sec-2-2-5", "title": "对象解构赋值", "code": "// 角色升级奖励系统\nfunction processLevelUp(character) {\n  console.log(`🎉 恭喜 ${character.name} 升级到 ${character.level} 级！🎉\\n`);\n\n  // 使用解构赋值，同时重命名和设置默认值\n  // 从 stats 中提取 hp 和 mp\n  // 从 equipment 中提取 weapon，如果不存在，默认为 '新手匕首'\n  // 从 profile 中提取 title，并重命名为 honorific，如果不存在，默认为 '无名小卒'\n  const {\n    name,\n    stats: { hp, mp },\n    equipment: { weapon = '新手匕首' } = {}, // 为 equipment 也提供默认值，防止 character.equipment 不存在\n    profile: { title: honorific = '无名小卒' } = {}\n  } = character;\n\n  // 根据解构出的变量生成动态的奖励信息\n  let rewardMessage = `作为一名勇敢的“${honorific}”，你的状态得到了提升：\\n`;\n  rewardMessage += `  - ❤️ 生命值: ${hp}\\n`;\n  rewardMessage += `  - 💧 魔法值: ${mp}\\n`;\n\n  if (weapon !== '新手匕首') {\n    rewardMessage += `  - ⚔️ 你的武器 \"${weapon}\" 也获得了祝福，闪耀着新的光芒！\\n`;\n  } else {\n    rewardMessage += `  - 🎁 系统赠送了你一把 \"${weapon}\" 以开始新的冒险！\\n`;\n  }\n\n  console.log(rewardMessage);\n}\n\n// 定义两个不同的角色\nconst warrior = {\n  name: '阿尔萨斯',\n  level: 25,\n  stats: { hp: 2500, mp: 800 },\n  equipment: { weapon: '霜之哀伤', armor: '符文战甲' },\n  profile: { title: '屠龙者' }\n};\n\nconst rookieMage = {\n  name: '吉安娜',\n  level: 5,\n  stats: { hp: 600, mp: 1200 }\n  // 这位新手法师还没有装备(equipment)和头衔(profile)\n};\n\n// 为两个角色执行升级流程\nprocessLevelUp(warrior);\nconsole.log('--------------------');\nprocessLevelUp(rookieMage);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-5-对象解构赋值.md", "blockIndex": 5}
{"id": "js-sec-2-2-6", "title": "JSON序列化", "code": "// 你的游戏角色信息\nconst player = {\n  name: \"Link\",\n  level: 5,\n  hasSword: true\n};\n\n// 使用 JSON.stringify() 将对象转换为字符串\nconst playerString = JSON.stringify(player);\n\nconsole.log(\"JavaScript 对象:\", player);\nconsole.log(\"转换后的 JSON 字符串:\", playerString);\nconsole.log(\"字符串的类型是:\", typeof playerString);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-6-JSON序列化.md", "blockIndex": 0}
{"id": "js-sec-2-2-6", "title": "JSON序列化", "code": "const wizard = {\n  name: \"Gandalf\",\n  level: 99,\n  power: undefined, // undefined 会被忽略\n  castSpell: function() { // 函数会被忽略\n    return \"You shall not pass!\";\n  },\n  secretSymbol: Symbol('Istari') // Symbol 会被忽略\n};\n\n// 数组中的特殊值会被转换为 null\nconst inventory = [\"mana potion\", undefined, function() {}];\n\nconst wizardString = JSON.stringify(wizard);\nconst inventoryString = JSON.stringify(inventory);\n\nconsole.log(\"序列化前的巫师对象:\", wizard);\nconsole.log(\"序列化后的巫师字符串:\", wizardString); // 注意 power, castSpell, secretSymbol 都消失了\n\nconsole.log(\"--- 分割线 ---\");\n\nconsole.log(\"序列化前的库存数组:\", inventory);\nconsole.log(\"序列化后的库存字符串:\", inventoryString); // 注意 undefined 和函数变成了 null", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-6-JSON序列化.md", "blockIndex": 1}
{"id": "js-sec-2-2-6", "title": "JSON序列化", "code": "const dragon = {\n  name: \"Smaug\",\n  type: \"Fire Drake\",\n  treasures: [\n    { name: \"Arkenstone\", value: 1000000 },\n    { name: \"Gold Coins\", quantity: 500000 }\n  ],\n  isAwake: true\n};\n\n// 不加格式化参数\nconst compactJson = JSON.stringify(dragon);\nconsole.log(\"紧凑的JSON字符串:\");\nconsole.log(compactJson);\n\nconsole.log(\"\\n--- 使用2个空格缩进 ---\");\n// 第三个参数是数字，表示用多少个空格缩进\nconst prettyJson = JSON.stringify(dragon, null, 2);\nconsole.log(prettyJson);\n\nconsole.log(\"\\n--- 使用字符串作为缩进 ---\");\n// 也可以用字符串（比如制表符 \\t 或者其他符号）\nconst fancyJson = JSON.stringify(dragon, null, '🐉 ');\nconsole.log(fancyJson);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-6-JSON序列化.md", "blockIndex": 2}
{"id": "js-sec-2-2-6", "title": "JSON序列化", "code": "// 完整的对比示例，包含所有必要的变量定义\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 两个对象互相引用，形成了死循环\nconst personA = { name: \"Alice\" };\nconst personB = { name: \"Bob\" };\n\npersonA.friend = personB;\npersonB.friend = personA; // 这里创建了循环引用\n\ntry {\n  JSON.stringify(personA);\n} catch (error) {\n  console.error(\"出错了！JSON无法处理循环引用:\", error.message);\n  console.log(\"解释: 当 stringify 试图转换 personA 时，它遇到了 friend (personB)。然后它去转换 personB，又遇到了 friend (personA)，如此无限循环，直到栈溢出。\");\n}\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 在序列化之前，创建一个“干净”的不包含循环引用的版本\nconst characterA = { name: \"Frodo\", id: 1 };\nconst characterB = { name: \"Sam\", id: 2 };\n\n// 我们不直接引用整个对象，而是引用其唯一标识符\nconst cleanCharacterA = {\n  name: characterA.name,\n  friendId: characterB.id // 只保存朋友的ID，而不是整个对象\n};\n\nconst characterString = JSON.stringify(cleanCharacterA);\nconsole.log(\"序列化成功:\", characterString);\nconsole.log(\"解释: 通过只存储ID，我们打破了循环引用。在需要时，我们可以根据这个ID再找到完整的朋友对象。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-6-JSON序列化.md", "blockIndex": 3}
{"id": "js-sec-2-2-6", "title": "JSON序列化", "code": "// 这是一个代表你虚拟宠物的对象\nconst myPet = {\n  name: \"Pikachu\",\n  type: \"Electric Mouse\",\n  happiness: 80,\n  hunger: 40,\n  lastPlayed: new Date(), // Date对象在序列化时会变成ISO格式字符串\n  // 宠物有一个行为，但我们不希望保存这个行为到存档里\n  play: function() {\n    this.happiness += 10;\n    console.log(`${this.name} is happy! Happiness is now ${this.happiness}.`);\n  }\n};\n\nconsole.log(\"🎮 游戏开始！这是你的宠物：\", myPet);\nmyPet.play(); // 玩了一会儿，宠物心情变好了\n\nconsole.log(\"\\n🌙 准备睡觉了，需要保存游戏进度...\");\n\n// 使用 JSON.stringify 创建游戏存档\n// 使用 2 个空格美化存档文件，方便调试查看\nconst saveFile = JSON.stringify(myPet, null, 2);\n\nconsole.log(\"\\n💾 游戏存档已生成 (一个JSON字符串):\");\nconsole.log(saveFile);\nconsole.log(\"\\n✨ 你看！'play' 函数被自动忽略了，'lastPlayed' 日期变成了标准的字符串格式。\");\nconsole.log(\"这个字符串现在可以轻松地发送到服务器或保存在浏览器的 localStorage 中了！\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-6-JSON序列化.md", "blockIndex": 4}
{"id": "js-sec-2-2-7", "title": "对象的浅拷贝与深拷贝", "code": "// 假设我们在制作一个披萨订单\nconst originalPizza = {\n  name: \"夏威夷披萨\",\n  size: \"12寸\"\n};\n\n// 使用展开语法(...)进行浅拷贝，创建一份新订单\nconst copiedPizza = { ...originalPizza };\n\n// 顾客想把新订单的尺寸改成9寸\ncopiedPizza.size = \"9寸\";\n\nconsole.log(\"原始订单:\", originalPizza);\n// 输出: 原始订单: { name: '夏威夷披萨', size: '12寸' }\n\nconsole.log(\"拷贝的订单:\", copiedPizza);\n// 输出: 拷贝的订单: { name: '夏威夷披萨', size: '9寸' }\n\nconsole.log(\"✅ 成功！修改拷贝的订单没有影响原始订单。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-7-对象的浅拷贝与深拷贝.md", "blockIndex": 0}
{"id": "js-sec-2-2-7", "title": "对象的浅拷贝与深拷贝", "code": "// 这是一个游戏角色的配置\nconst originalCharacter = {\n  name: \"艾拉\",\n  attributes: {\n    health: 100,\n    mana: 50\n  }\n};\n\n// 对角色进行浅拷贝，想创建一个“镜像分身”\nconst mirrorImage = { ...originalCharacter };\n\n// 镜像分身被敌人击中，生命值下降\nmirrorImage.attributes.health = 20;\n\nconsole.log(\"原始角色生命值:\", originalCharacter.attributes.health);\n// 输出: 原始角色生命值: 20\n\nconsole.log(\"镜像分身生命值:\", mirrorImage.attributes.health);\n// 输出: 镜像分身生命值: 20\n\nconsole.log(\"😱 糟糕！修改分身的生命值，导致原始角色的生命值也改变了！\");\nconsole.log(\"这是因为浅拷贝共享了 `attributes` 这个嵌套对象。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-7-对象的浅拷贝与深拷贝.md", "blockIndex": 1}
{"id": "js-sec-2-2-7", "title": "对象的浅拷贝与深拷贝", "code": "// 另一个游戏角色\nconst masterWizard = {\n  name: \"甘道夫\",\n  inventory: {\n    staff: \"法杖\",\n    potions: [\"治疗药水\", \"法力药水\"]\n  },\n  // 注意：JSON方法会丢失函数\n  castSpell: () => \"火焰球！\" \n};\n\n// 使用 JSON.parse(JSON.stringify(...)) 的技巧实现深拷贝\nconst evilClone = JSON.parse(JSON.stringify(masterWizard));\n\n// 邪恶克隆偷换了自己背包里的法杖\nevilClone.inventory.staff = \"被诅咒的魔杖\";\n\nconsole.log(\"大法师的法杖:\", masterWizard.inventory.staff);\n// 输出: 大法师的法杖: 法杖\n\nconsole.log(\"邪恶克隆的法杖:\", evilClone.inventory.staff);\n// 输出: 邪恶克隆的法杖: 被诅咒的魔杖\n\nconsole.log(\"✅ 安全！深拷贝后，修改克隆体不会影响本体。\");\n\n// 额外提示：JSON深拷贝的局限性\nconsole.log(\"大法师能施法吗?\", typeof masterWizard.castSpell); // \"function\"\nconsole.log(\"邪恶克隆能施法吗?\", typeof evilClone.castSpell); // \"undefined\" (函数丢失了)", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-7-对象的浅拷贝与深拷贝.md", "blockIndex": 2}
{"id": "js-sec-2-2-7", "title": "对象的浅拷贝与深拷贝", "code": "// 原始的秘密配方\nconst secretRecipe = {\n  name: \"祖母的苹果派\",\n  ingredients: {\n    fruit: \"苹果\",\n    sugar: \"1杯\",\n    secretSpice: \"肉桂\"\n  }\n};\n\nconsole.log(\"=== 错误用法：使用浅拷贝修改嵌套数据 ===\");\n// ❌ 尝试创建一个“低糖版”配方，但使用了浅拷贝\nconst lowSugarRecipeAttempt = { ...secretRecipe };\nlowSugarRecipeAttempt.ingredients.sugar = \"半杯\"; // 修改嵌套对象里的属性\n\nconsole.log(\"原始配方糖量:\", secretRecipe.ingredients.sugar);\n// 输出: 原始配方糖量: 半杯\nconsole.log(\"低糖配方糖量:\", lowSugarRecipeAttempt.ingredients.sugar);\n// 输出: 低糖配方糖量: 半杯\nconsole.log(\"❌ 失败！原始的秘密配方被永久修改了，祖母会生气的！\");\n\n\nconsole.log(\"\\n=== 正确用法：使用深拷贝保护原始数据 ===\");\n// 为了安全，我们重新定义一个干净的原始配方\nconst safeSecretRecipe = {\n  name: \"祖母的苹果派\",\n  ingredients: {\n    fruit: \"苹果\",\n    sugar: \"1杯\",\n    secretSpice: \"肉桂\"\n  }\n};\n// ✅ 使用深拷贝创建完全独立的“低糖版”\nconst correctLowSugarRecipe = JSON.parse(JSON.stringify(safeSecretRecipe));\ncorrectLowSugarRecipe.ingredients.sugar = \"半杯\";\n\nconsole.log(\"原始配方糖量:\", safeSecretRecipe.ingredients.sugar);\n// 输出: 原始配方糖量: 1杯\nconsole.log(\"低糖配方糖量:\", correctLowSugarRecipe.ingredients.sugar);\n// 输出: 低糖配方糖量: 半杯\nconsole.log(\"✅ 成功！我们安全地创建了新配方，而没有篡改神圣的原始版本。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-7-对象的浅拷贝与深拷贝.md", "blockIndex": 3}
{"id": "js-sec-2-2-7", "title": "对象的浅拷贝与深拷贝", "code": "// 一个简单的深拷贝函数（实际项目推荐用 lodash.cloneDeep）\nfunction createDeepClone(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\n// 1. 英雄的初始状态\nlet hero = {\n  name: \"阿尔萨斯\",\n  hp: 1000,\n  stats: {\n    attack: 150,\n    defense: 80,\n  },\n  statusEffects: []\n};\n\n// 2. 保存一个战斗开始前的“快照”\nconsole.log(\"--- 战斗开始，保存英雄快照 ---\");\nconst heroSnapshot = createDeepClone(hero);\nconsole.log(\"快照已创建！当前攻击力:\", heroSnapshot.stats.attack);\n\n// 3. 英雄捡到了一个“被诅咒的头盔”，攻击力大幅提升，但防御力归零\nconsole.log(\"\\n--- 英雄戴上了'被诅咒的头盔'！ ---\");\nhero.stats.attack += 200;\nhero.stats.defense = 0;\nhero.statusEffects.push(\"诅咒:防御清零\");\n\nconsole.log(`当前状态: ${hero.name}, 攻击力: ${hero.stats.attack}, 防御力: ${hero.stats.defense}`);\nconsole.log(\"当前效果:\", hero.statusEffects);\n\n// 4. 战斗胜利后，英雄丢掉了头盔，需要从快照恢复状态\nconsole.log(\"\\n--- 战斗结束，从快照恢复状态 ---\");\nhero = createDeepClone(heroSnapshot); // 使用快照覆盖当前状态\n\nconsole.log(`恢复后状态: ${hero.name}, 攻击力: ${hero.stats.attack}, 防御力: ${hero.stats.defense}`);\nconsole.log(\"恢复后效果:\", hero.statusEffects);\nconsole.log(\"🎉 英雄毫发无损地恢复到了初始状态，可以继续冒险了！深拷贝万岁！\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-2-7-对象的浅拷贝与深拷贝.md", "blockIndex": 4}
{"id": "js-sec-2-3-1", "title": "字符串方法（substring/slice）", "code": "// 假设 \"JavaScript\" 是我们的长面包\nconst message = \"Hello, JavaScript!\";\n\n// 使用 slice 从索引 7 的位置切到索引 17 的位置（不包含17）\n// J(7) a(8) v(9) a(10) S(11) c(12) r(13) i(14) p(15) t(16)\nconst slicedPart = message.slice(7, 17);\nconsole.log(\"使用 slice 切出的部分:\", slicedPart); // 输出: JavaScript\n\n// 使用 substring 也可以做到同样的事情\nconst subPart = message.substring(7, 17);\nconsole.log(\"使用 substring 切出的部分:\", subPart); // 输出: JavaScript", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-1-字符串方法（substring-slice）.md", "blockIndex": 0}
{"id": "js-sec-2-3-1", "title": "字符串方法（substring/slice）", "code": "const greeting = \"Welcome to the future!\";\n\n// --- slice 的表现 ---\n// slice(-1) 表示从倒数第1个字符开始切到末尾\nconst sliceNegative = greeting.slice(-7);\nconsole.log(\"slice(-7):\", sliceNegative); // 输出: future!\n\n// --- substring 的表现 ---\n// substring 会将所有负数参数都当作 0\nconst substringNegative = greeting.substring(-7); // 相当于 greeting.substring(0)\nconsole.log(\"substring(-7):\", substringNegative); // 输出: Welcome to the future!\n\nconst substringNegative2 = greeting.substring(0, -1); // 相当于 greeting.substring(0, 0)\nconsole.log(\"substring(0, -1):\", substringNegative2); // 输出: \"\" (空字符串)", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-1-字符串方法（substring-slice）.md", "blockIndex": 1}
{"id": "js-sec-2-3-1", "title": "字符串方法（substring/slice）", "code": "const code = \"CODE-12345-FINISH\";\n\n// --- substring 的表现 ---\n// substring(11, 5) 会被自动纠正为 substring(5, 11)\nconst subSwapped = code.substring(11, 5);\nconsole.log(\"substring(11, 5) [自动交换]:\", subSwapped); // 输出: 12345\n\n// --- slice 的表现 ---\n// slice(11, 5) 的起始位置在结束位置之后，无法切割，所以返回空\nconst sliceSwapped = code.slice(11, 5);\nconsole.log(\"slice(11, 5) [不交换]:\", sliceSwapped); // 输出: \"\" (空字符串)", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-1-字符串方法（substring-slice）.md", "blockIndex": 2}
{"id": "js-sec-2-3-1", "title": "字符串方法（substring/slice）", "code": "const phrase = \"The early bird catches the worm.\";\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 目标：想获取最后4个字符 \"worm\"\n// 错误地认为 substring 也支持负数索引\nconst wrongResult = phrase.substring(-5, -1);\nconsole.log('以为 substring(-5, -1) 能获取 \"worm\"，结果是:', `\"${wrongResult}\"`);\n// 解释: substring 将 -5 和 -1 都视为 0，变成了 substring(0, 0)，所以返回了空字符串。\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确做法：使用 slice 来处理负数索引\nconst correctResultSlice = phrase.slice(-5, -1);\nconsole.log('使用 slice(-5, -1) 获取 \"worm\"，结果是:', `\"${correctResultSlice}\"`);\n// 解释: slice(-5) 从倒数第5个字符('w')开始，slice(-1) 在倒数第1个字符('.')结束（不包含）。\n\n// ✅ 另一种正确做法：如果必须用 substring，需要计算出正数索引\nconst correctResultSubstring = phrase.substring(phrase.length - 5, phrase.length - 1);\nconsole.log('使用 substring(28, 32) 获取 \"worm\"，结果是:', `\"${correctResultSubstring}\"`);\n// 解释: 通过计算长度，我们得到了正确的正数索引，但显然 slice 更方便。", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-1-字符串方法（substring-slice）.md", "blockIndex": 3}
{"id": "js-sec-2-3-1", "title": "字符串方法（substring/slice）", "code": "function decodeAlphaCentauriSignal(signal) {\n  console.log(\"解码器启动... 正在分析信号:\", signal);\n  console.log(\"-------------------------------------------\");\n\n  // 任务1: 提取“来源星球”代码 (信号的前5个字符)\n  // 使用 substring，因为我们明确知道是从 0 开始的\n  const planetCode = signal.substring(0, 5);\n  console.log(`[来源分析] 信号来源代码: ${planetCode} (解码为: 半人马座α星b)`);\n\n  // 任务2: 提取“信息优先级” (信号的最后3个字符)\n  // 这种从末尾提取的场景，slice 的负数索引是最佳选择！\n  const priorityLevel = signal.slice(-3);\n  console.log(`[优先级分析] 信息紧急程度: ${priorityLevel} (解码为: 最高级别)`);\n\n  // 任务3: 提取核心信息 (从第8个字符开始，到倒数第5个字符结束)\n  // 再次使用 slice，因为它能灵活地混合正负索引\n  const coreMessage = signal.slice(8, -5);\n  console.log(`[核心信息] 破译出的核心内容: \"${coreMessage}\"`);\n  \n  console.log(\"-------------------------------------------\");\n  console.log(\"解码完成！外星人说：\", `${coreMessage}！`);\n}\n\n// 这是一个模拟的加密外星信号\nconst alienSignal = \"AC-b#|GREETINGS_EARTHLINGS|#URG\";\n\n// 运行我们的解码器\ndecodeAlphaCentauriSignal(alienSignal);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-1-字符串方法（substring-slice）.md", "blockIndex": 4}
{"id": "js-sec-2-3-2", "title": "字符串查找（indexOf/includes）", "code": "// 假设这是我们冒险游戏中的一条咒语\nconst spell = \"Abracadabra, open the door!\";\n\n// 使用 .includes() 检查咒语中是否包含 \"open\"\nconst hasOpen = spell.includes(\"open\");\nconsole.log(`咒语中是否包含 \"open\"? -> ${hasOpen}`); // true\n\n// 使用 .indexOf() 找到 \"door\" 这个词的起始位置\nconst doorPosition = spell.indexOf(\"door\");\nconsole.log(`\"door\" 这个词从第几个位置开始? -> ${doorPosition}`); // 23", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-2-字符串查找（indexOf-includes）.md", "blockIndex": 0}
{"id": "js-sec-2-3-2", "title": "字符串查找（indexOf/includes）", "code": "const secretCode = \"Agent 007 is on a secret mission.\";\n\n// .includes() 直接返回 true 或 false，语义清晰\nconst hasAgent = secretCode.includes(\"Agent\");\nconsole.log(`Is an agent mentioned? -> ${hasAgent}`); // true\n\nconst hasVillain = secretCode.includes(\"Villain\");\nconsole.log(`Is a villain mentioned? -> ${hasVillain}`); // false\n\n// .indexOf() 返回索引值，如果找不到则返回 -1\nconst agentPosition = secretCode.indexOf(\"Agent\");\nconsole.log(`\"Agent\" found at index: ${agentPosition}`); // 0\n\nconst villainPosition = secretCode.indexOf(\"Villain\");\nconsole.log(`\"Villain\" found at index: ${villainPosition}`); // -1", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-2-字符串查找（indexOf-includes）.md", "blockIndex": 1}
{"id": "js-sec-2-3-2", "title": "字符串查找（indexOf/includes）", "code": "const greeting = \"Hello World!\";\n\n// 它们都严格区分大小写\nconsole.log('--- 尝试查找小写的 \"world\" ---');\nconst hasLowercaseWorld = greeting.includes(\"world\");\nconst indexOfLowercaseWorld = greeting.indexOf(\"world\");\nconsole.log(`includes(\"world\"): ${hasLowercaseWorld}`); // false\nconsole.log(`indexOf(\"world\"): ${indexOfLowercaseWorld}`);   // -1\n\nconsole.log('\\n--- 尝试查找大写的 \"World\" ---');\nconst hasUppercaseWorld = greeting.includes(\"World\");\nconst indexOfUppercaseWorld = greeting.indexOf(\"World\");\nconsole.log(`includes(\"World\"): ${hasUppercaseWorld}`); // true\nconsole.log(`indexOf(\"World\"): ${indexOfUppercaseWorld}`);   // 6", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-2-字符串查找（indexOf-includes）.md", "blockIndex": 2}
{"id": "js-sec-2-3-2", "title": "字符串查找（indexOf/includes）", "code": "const treasureMap = \"The treasure is buried under the old oak tree.\";\n\nconsole.log(\"=== 错误/过时用法 ===\");\n// ❌ 错误原因: .indexOf('The') 返回 0。在if判断中，数字 0 会被自动转换为 false，导致逻辑错误！\n// 即使 \"The\" 确实存在于字符串的开头，代码块也无法执行。\nif (treasureMap.indexOf('The')) {\n    console.log(\"这段代码不会执行，尽管 'The' 确实存在!\");\n} else {\n    console.log(\"逻辑错误：'The' 在索引 0 处，被当作 'falsy' 值处理了。\");\n}\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确做法1: 使用 indexOf 时，必须和 -1 进行比较\nif (treasureMap.indexOf('The') !== -1) {\n    console.log(\"正确：使用 indexOf() !== -1 成功找到了 'The'\");\n}\n\n// ✅ 正确做法2 (更推荐): 使用 includes()，代码意图更清晰，不会有 0 的陷阱\nif (treasureMap.includes('The')) {\n    console.log(\"现代方式：使用 includes() 成功找到了 'The'，代码更易读！\");\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-2-字符串查找（indexOf-includes）.md", "blockIndex": 3}
{"id": "js-sec-2-3-2", "title": "字符串查找（indexOf/includes）", "code": "// 这是一个简单的翻译函数，用于检测特定外星词汇\nfunction alienTranslator(message) {\n  console.log(`\\n[收到星际消息]: \"${message}\"`);\n  console.log(\"🤖...开始分析消息...\");\n\n  // 使用 .includes() 检查是否包含已知的几种外星语关键词\n  const isZorpian = message.includes(\"Zorp\");\n  const isGleepian = message.includes(\"Gleep\");\n  const isBlorgonian = message.toLowerCase().includes(\"blorgon\"); // 演示忽略大小写的查找\n\n  if (isZorpian) {\n    console.log(\"✅ [分析结果]: 检测到佐普星语！他们似乎在索要...宇宙甜甜圈！\");\n    console.log(\"🚨 [建议行动]: 准备好甜甜圈弹射器！\");\n  } else if (isGleepian) {\n    console.log(\"✅ [分析结果]: 是格利普星人的求救信号！他们的宠物太空猫被困在虫洞里了。\");\n    console.log(\"🚨 [建议行动]: 立刻派遣星际猫咪救援队！\");\n  } else if (isBlorgonian) {\n    console.log(\"✅ [分析结果]: 是布洛贡人！他们又在挑战我们进行银河系尬舞大赛了。\");\n    console.log(\"🚨 [建议行动]: 启动迪斯科球，释放我们的终极舞步！\");\n  } else {\n    console.log(\"✅ [分析结果]: 这似乎是一条普通的人类消息。\");\n    console.log(\"😴 [建议行动]: 解除警报，继续摸鱼...呃，我是说，继续监控。\");\n  }\n}\n\n// 测试翻译器\nalienTranslator(\"你好，地球人，我是 Zorp。\");\nalienTranslator(\"救命！我们的飞船 Gleep 动力系统失灵了！\");\nalienTranslator(\"你们这些凡人，准备好迎接伟大的 BlorGon 了吗？\");\nalienTranslator(\"今天天气不错，适合散步。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-2-字符串查找（indexOf-includes）.md", "blockIndex": 4}
{"id": "js-sec-2-3-3", "title": "字符串替换与分割", "code": "// Level 1: 基础用法\n\n// 1. 替换 (replace)\nconst greeting = \"Hello, World!\";\n// 将 \"World\" 替换为 \"JavaScript\"\nconst newGreeting = greeting.replace(\"World\", \"JavaScript\");\nconsole.log(\"替换前:\", greeting);\nconsole.log(\"替换后:\", newGreeting); // 输出: \"Hello, JavaScript!\"\n\n// 2. 分割 (split)\nconst fruitString = \"苹果,香蕉,橘子\";\n// 使用逗号 \",\" 作为分隔符\nconst fruitArray = fruitString.split(\",\");\nconsole.log(\"分割前的字符串:\", fruitString);\nconsole.log(\"分割后的数组:\", fruitArray); // 输出: [ '苹果', '香蕉', '橘子' ]", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-3-字符串替换与分割.md", "blockIndex": 0}
{"id": "js-sec-2-3-3", "title": "字符串替换与分割", "code": "// Level 2, Feature 1: replace() vs replaceAll()\n\nconst story = \"A black cat saw another black cat.\";\n\n// 默认的 replace() 只替换第一个 \"black\"\nconst replacedOnce = story.replace(\"black\", \"white\");\nconsole.log(\"只替换第一个:\", replacedOnce);\n// 输出: \"A white cat saw another black cat.\"\n\n// 使用 replaceAll() 替换所有 \"black\"\nconst replacedAll = story.replaceAll(\"black\", \"white\");\nconsole.log(\"替换所有:\", replacedAll);\n// 输出: \"A white cat saw another white cat.\"\n\n// 在旧的浏览器环境中，可以使用正则表达式 /g (全局) 标志来达到同样效果\nconst replacedAllWithRegex = story.replace(/black/g, \"white\");\nconsole.log(\"使用正则替换所有:\", replacedAllWithRegex);\n// 输出: \"A white cat saw another white cat.\"", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-3-字符串替换与分割.md", "blockIndex": 1}
{"id": "js-sec-2-3-3", "title": "字符串替换与分割", "code": "// Level 2, Feature 2: split() 高级用法\n\n// 1. 限制分割数量\nconst sentence = \"我 爱 编程 和 游戏\";\n// 只分割前2个空格，得到3个元素\nconst limitedSplit = sentence.split(\" \", 3); \nconsole.log(\"限制分割为3个元素:\", limitedSplit);\n// 输出: [ '我', '爱', '编程' ]\n\n// 2. 分割成单个字符\nconst word = \"HELLO\";\nconst characters = word.split('');\nconsole.log(\"将 'HELLO' 分割成字符数组:\", characters);\n// 输出: [ 'H', 'E', 'L', 'L', 'O' ]", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-3-字符串替换与分割.md", "blockIndex": 2}
{"id": "js-sec-2-3-3", "title": "字符串替换与分割", "code": "// Level 3: 字符串的不可变性\n\nlet originalMessage = \"欢迎来到火星！\";\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 只是调用了 replace()，但没有接收其返回值\noriginalMessage.replace(\"火星\", \"地球\"); \nconsole.log(\"原始消息（错误尝试后）:\", originalMessage);\n// 解释：上面的代码运行了，但返回的新字符串 \"欢迎来到地球！\" 被丢弃了。\n// originalMessage 变量本身的值没有改变。\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 调用 replace() 并将其返回值赋给一个新变量（或覆盖旧变量）\nlet newMessage = originalMessage.replace(\"火星\", \"地球\");\nconsole.log(\"原始消息（正确用法后）:\", originalMessage); // 原始值不变\nconsole.log(\"新消息:\", newMessage); // 新值被正确保存\n// 解释：我们捕获了 replace() 方法返回的新字符串，这才是正确的做法。", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-3-字符串替换与分割.md", "blockIndex": 3}
{"id": "js-sec-2-3-3", "title": "字符串替换与分割", "code": "// Level 4: 外星语言翻译器\n\n// 1. 我们收到的Zorg电码和破译的词典\nconst zorgMessage = \"Gleep-zorp-blip! Knorb flixx zorp-zorp.\";\nconst dictionary = {\n  \"Gleep\": \"你好\",\n  \"zorp\": \"地球\",\n  \"blip\": \"朋友\",\n  \"Knorb\": \"我\",\n  \"flixx\": \"喜欢\"\n};\n\nconsole.log(\"👽 收到Zorg星电码:\", zorgMessage);\nconsole.log(\"📖 已破译词典:\", dictionary);\n\n// 2. 开始翻译！\nlet translatedMessage = zorgMessage;\n\n// 遍历词典，用地球语替换Zorg语单词\n// 使用 for...in 循环遍历对象的键\nfor (const zorgWord in dictionary) {\n  const earthWord = dictionary[zorgWord];\n  // 使用正则表达式和 \"g\" 标志来确保替换所有出现的单词\n  const regex = new RegExp(zorgWord, \"g\");\n  translatedMessage = translatedMessage.replace(regex, earthWord);\n}\n\nconsole.log(\"🌍 翻译结果:\", translatedMessage);\nconsole.log(\"---\");\n\n// 3. 分析电码结构\nconsole.log(\"🔬 开始分析电码结构...\");\n// 使用非字母数字的字符作为分隔符来分割句子\nconst sentences = zorgMessage.split(/[!.]/);\nconsole.log(\"电码包含的句子数量:\", sentences.filter(s => s).length); // filter(s => s) 过滤空字符串\n\n// 分割单词，看看Zorg人说了多少个“词”\nconst words = zorgMessage.replace(/[!.]/g, '').split('-');\nconsole.log(\"电码包含的Zorg词组数量:\", words.length);\nconsole.log(\"Zorg词组列表:\", words);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-3-字符串替换与分割.md", "blockIndex": 4}
{"id": "js-sec-2-3-4", "title": "模板字符串", "code": "// 传统方法 vs 模板字符串\n\nconst userName = \"Alex\";\n\n// 传统方法使用 '+' 拼接\nconst oldGreeting = \"Hello, \" + userName + \"!\";\nconsole.log(\"传统方法:\", oldGreeting);\n\n// 模板字符串使用反引号 `` 和 ${}\nconst newGreeting = `Hello, ${userName}!`;\nconsole.log(\"模板字符串:\", newGreeting);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-4-模板字符串.md", "blockIndex": 0}
{"id": "js-sec-2-3-4", "title": "模板字符串", "code": "const item = \"苹果\";\nconst price = 5;\nconst quantity = 3;\n\n// 1. 进行数学运算\nconst message1 = `购买 ${quantity} 个${item}，总价是 ${price * quantity} 元。`;\nconsole.log(message1);\n\n// 2. 调用函数\nfunction getStoreName() {\n  return \"奇妙水果店\";\n}\nconst message2 = `欢迎光临${getStoreName()}！`;\nconsole.log(message2);\n\n// 3. 使用三元运算符\nconst isMember = true;\nconst message3 = `顾客 ${isMember ? '是会员' : '不是会员'}。`;\nconsole.log(message3);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-4-模板字符串.md", "blockIndex": 1}
{"id": "js-sec-2-3-4", "title": "模板字符串", "code": "// 传统方法创建多行字符串，需要使用 \\n\nconst oldMultiLine = \"这是一个传统的多行字符串。\\n第一行在这里。\\n第二行在这里。\";\nconsole.log(\"传统多行:\\n\" + oldMultiLine);\n\nconsole.log(\"\\n\" + \"=\".repeat(20) + \"\\n\");\n\n// 使用模板字符串，所见即所得\nconst newMultiLine = `这是一个模板字符串创建的多行文本。\n第一行在这里。\n第二行在这里。`;\nconsole.log(\"模板字符串多行:\\n\" + newMultiLine);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-4-模板字符串.md", "blockIndex": 2}
{"id": "js-sec-2-3-4", "title": "模板字符串", "code": "const hero = \"蜘蛛侠\";\nconst city = \"纽约\";\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误：使用了单引号 ''\n// 解释：单引号会把 ${hero} 当作普通文本，不会进行变量替换。\nconst wrongMessage1 = '我们的英雄是 ${hero}，他守护着 ${city}。';\nconsole.log(\"使用单引号:\", wrongMessage1);\n\n// ❌ 错误：使用了双引号 \"\"\n// 解释：双引号同样会把 ${hero} 当作普通文本。\nconst wrongMessage2 = \"我们的英雄是 ${hero}，他守护着 ${city}。\";\nconsole.log(\"使用双引号:\", wrongMessage2);\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确：必须使用反引号 ``\n// 解释：只有在反引号中，`${...}` 语法才会被解析为表达式并嵌入到字符串中。\nconst correctMessage = `我们的英雄是 ${hero}，他守护着 ${city}。`;\nconsole.log(\"使用反引号:\", correctMessage);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-4-模板字符串.md", "blockIndex": 3}
{"id": "js-sec-2-3-4", "title": "模板字符串", "code": "// 角色升级通知生成器\n\nfunction createLevelUpNotification(character) {\n  const { name, level, job, stats, newSkill } = character;\n\n  // 使用模板字符串构建一个丰富、多行的通知\n  const notification = `\n  ┌──────────────────────────────────┐\n  │                                  │\n  │   🎉🎉🎉 等级提升！🎉🎉🎉   │\n  │                                  │\n  ├──────────────────────────────────┤\n  │                                  │\n  │  英雄 ${name} (${job})            │\n  │  等级提升至 Lv. ${level}！          │\n  │                                  │\n  │  新的属性:                       │\n  │    - 生命值: ${stats.hp}         │\n  │    - 攻击力: ${stats.attack}     │\n  │    - 防御力: ${stats.defense}    │\n  │                                  │\n  │  学会新技能: 【${newSkill}】     │\n  │                                  │\n  └──────────────────────────────────┘\n  `;\n  return notification;\n}\n\n// 定义一个角色对象\nconst player = {\n  name: \"闪电之刃\",\n  level: 25,\n  job: \"剑士\",\n  stats: {\n    hp: 1200,\n    attack: 350,\n    defense: 200,\n  },\n  newSkill: \"疾风斩\"\n};\n\n// 生成并打印通知\nconst levelUpMessage = createLevelUpNotification(player);\nconsole.log(levelUpMessage);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-4-模板字符串.md", "blockIndex": 4}
{"id": "js-sec-2-3-5", "title": "正则表达式基础", "code": "// 定义一个正则表达式，/hello/ 表示我们要查找 \"hello\" 这个模式\nconst pattern = /hello/;\n\n// 准备两个待测试的字符串\nconst string1 = \"hello world, this is a greeting.\";\nconst string2 = \"goodbye world, see you later.\";\n\n// 使用 .test() 方法检查字符串是否匹配模式\nconst result1 = pattern.test(string1);\nconst result2 = pattern.test(string2);\n\nconsole.log(`在 \"${string1}\" 中查找 \"hello\":`, result1); // 输出: true\nconsole.log(`在 \"${string2}\" 中查找 \"hello\":`, result2); // 输出: false", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-5-正则表达式基础.md", "blockIndex": 0}
{"id": "js-sec-2-3-5", "title": "正则表达式基础", "code": "// 验证一个用户名是否合法：必须由3-10位的小写字母或数字组成\nconst usernameRegex = /^[a-z0-9]{3,10}$/;\n\nconst validUsername = \"user123\";\nconst shortUsername = \"u1\";\nconst longUsername = \"thisusernameistoolong\";\nconst invalidCharUsername = \"User-123\"; // 包含大写字母和连字符\n\nconsole.log(`用户名 \"${validUsername}\" 是否合法?`, usernameRegex.test(validUsername));\nconsole.log(`用户名 \"${shortUsername}\" 是否合法?`, usernameRegex.test(shortUsername));\nconsole.log(`用户名 \"${longUsername}\" 是否合法?`, usernameRegex.test(longUsername));\nconsole.log(`用户名 \"${invalidCharUsername}\" 是否合法?`, usernameRegex.test(invalidCharUsername));", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-5-正则表达式基础.md", "blockIndex": 1}
{"id": "js-sec-2-3-5", "title": "正则表达式基础", "code": "// 目标：将 \"YYYY-MM-DD\" 格式的日期转换为 \"MM/DD/YYYY\"\nconst dateRegex = /(\\d{4})-(\\d{2})-(\\d{2})/;\n// (\\d{4}) 是第1个捕获组 ($1)，匹配4个数字（年）\n// (\\d{2}) 是第2个捕获组 ($2)，匹配2个数字（月）\n// (\\d{2}) 是第3个捕获组 ($3)，匹配2个数字（日）\n\nconst originalDate = \"2023-10-26\";\n\n// 使用 replace 方法和捕获组引用来重新格式化字符串\nconst formattedDate = originalDate.replace(dateRegex, \"$2/$3/$1\");\n\nconsole.log(`原始日期: ${originalDate}`);\nconsole.log(`格式化后日期: ${formattedDate}`);", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-5-正则表达式基础.md", "blockIndex": 2}
{"id": "js-sec-2-3-5", "title": "正则表达式基础", "code": "// 陷阱：对同一个带 g 标志的正则表达式实例连续调用 test()\nconst globalRegex = /cat/g;\nconst text = \"cat dog cat\";\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 多次对同一个 globalRegex 实例调用 test()\nconsole.log(\"第一次调用 test():\", globalRegex.test(text)); // true, 找到第一个 \"cat\"\nconsole.log(\"第二次调用 test():\", globalRegex.test(text)); // true, 从上次位置继续，找到第二个 \"cat\"\nconsole.log(\"第三次调用 test():\", globalRegex.test(text)); // false, 找不到了，内部指针重置\nconsole.log(\"第四次调用 test():\", globalRegex.test(text)); // true, 又从头开始\n// 解释：这种行为是因为 test() 会更新正则表达式的 lastIndex 属性，导致结果不稳定，不适合做简单的存在性检查。\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 方案一：对于简单的存在性检查，不要使用 g 标志\nconst simpleRegex = /cat/;\nconsole.log(\"方案一，第一次调用:\", simpleRegex.test(text)); // true\nconsole.log(\"方案一，第二次调用:\", simpleRegex.test(text)); // true\n// 解释：不带 g 标志的正则表达式每次都从头开始查找，结果稳定。\n\n// ✅ 方案二：如果必须用 g (例如在循环中)，请理解其工作原理或使用 String.match()\nconst matches = text.match(/cat/g);\nconsole.log(\"方案二，使用 match:\", matches); // [\"cat\", \"cat\"]\nconsole.log(\"方案二，检查匹配结果:\", Array.isArray(matches) && matches.length > 0); // true\n// 解释：String.prototype.match() 配合 g 标志可以一次性返回所有匹配项，更直观。", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-5-正则表达式基础.md", "blockIndex": 3}
{"id": "js-sec-2-3-5", "title": "正则表达式基础", "code": "// Zorg星人的加密规则：在单词中随意插入数字\nconst zorgMessage = \"W3e a1re co45mbi1ng t9o E2a2rt8h. P8r4epare t3o b8e am8az8ed b3y o2ur p3eac3e an4d t2ec3hno8logy!\";\n\n/**\n * 解码Zorg星人的信息\n * @param {string} message - 加密的Zorg信息\n * @returns {string} - 解码后的地球语\n */\nfunction decodeZorgMessage(message) {\n  console.log(\"--- 收到加密电文 ---\");\n  console.log(`原始信息: ${message}`);\n\n  // 正则表达式 /[a-zA-Z]+/g\n  // [a-zA-Z]+ : 匹配一个或多个连续的英文字母（大小写都算）\n  // g : 全局匹配，找出所有符合条件的片段，而不是只找第一个\n  const wordRegex = /[a-zA-Z]+/g;\n\n  // 使用 string.match() 方法找出所有匹配的单词片段\n  const earthWords = message.match(wordRegex);\n\n  // 如果没有找到任何单词，返回一条提示信息\n  if (!earthWords) {\n    return \"信号干扰，未检测到有效词汇！\";\n  }\n\n  // 将提取出的单词数组用空格连接成一句话\n  const decodedMessage = earthWords.join(\" \");\n\n  console.log(\"\\n--- 启动地球语翻译程序 ---\");\n  console.log(`提取出的单词片段:`, earthWords);\n  \n  return decodedMessage;\n}\n\n// 执行解码任务\nconst earthMessage = decodeZorgMessage(zorgMessage);\n\nconsole.log(\"\\n--- 解码完成 ---\");\nconsole.log(`破译结果: ${earthMessage}`);\nconsole.log(\"🚀 Zorg星人好像是来和平交流的！我们差点就开火了！\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-2-3-5-正则表达式基础.md", "blockIndex": 4}
{"id": "js-sec-3-1-1", "title": "函数作为参数", "code": "// 定义一个说“你好”的函数\nfunction sayHello() {\n  console.log(\"Hello!\");\n}\n\n// 定义一个说“Hola”的函数\nfunction sayHola() {\n  console.log(\"Hola!\");\n}\n\n// 这个函数接收另一个函数作为参数，并执行它\nfunction greet(howToSayHi) {\n  console.log(\"准备打招呼...\");\n  // 在这里调用传入的函数\n  howToSayHi();\n  console.log(\"打招呼完毕！\");\n}\n\n// 将 sayHello 函数作为参数传递给 greet 函数\ngreet(sayHello);\n\nconsole.log(\"---\");\n\n// 将 sayHola 函数作为参数传递给 greet 函数\ngreet(sayHola);", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-1-函数作为参数.md", "blockIndex": 0}
{"id": "js-sec-3-1-1", "title": "函数作为参数", "code": "// 模拟一个从服务器获取数据的函数，它需要一些时间\nfunction fetchData(callback) {\n  console.log(\"正在从火星服务器获取用户数据...\");\n  \n  // 使用 setTimeout 模拟网络延迟\n  setTimeout(function() {\n    const userData = { name: \"星际探险家\", level: 99 };\n    console.log(\"数据获取成功！\");\n    // 数据准备好后，调用传入的 callback 函数，并把数据传给它\n    callback(userData);\n  }, 1500); // 模拟1.5秒的延迟\n}\n\n// 定义一个回调函数，用来处理获取到的数据\nfunction displayUserData(user) {\n  console.log(`--- 用户信息面板 ---`);\n  console.log(`姓名: ${user.name}`);\n  console.log(`等级: ${user.level}`);\n  console.log(`--------------------`);\n}\n\n// 调用 fetchData，并把 displayUserData 作为回调函数传进去\nfetchData(displayUserData);", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-1-函数作为参数.md", "blockIndex": 1}
{"id": "js-sec-3-1-1", "title": "函数作为参数", "code": "// 一个通用的计算器函数，它接受两个数字和一个操作函数\nfunction calculator(a, b, operation) {\n  console.log(`准备用特殊方式计算 ${a} 和 ${b}...`);\n  const result = operation(a, b);\n  console.log(`计算结果是: ${result}`);\n}\n\n// 1. 使用匿名函数作为参数\ncalculator(10, 5, function(x, y) {\n  return x * y; // 定义乘法操作\n});\n\nconsole.log(\"---\");\n\n// 2. 使用更简洁的箭头函数作为参数\ncalculator(10, 5, (x, y) => {\n  return x - y; // 定义减法操作\n});", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-1-函数作为参数.md", "blockIndex": 2}
{"id": "js-sec-3-1-1", "title": "函数作为参数", "code": "// 准备一个简单的函数\nfunction announce() {\n  return \"这是一个重要的通知！\";\n}\n\n// 一个接收通知函数的“广播站”\nfunction broadcast(notificationFunction) {\n  console.log(\"📢 广播站准备播报：\");\n  // 正确的做法是在这里调用函数\n  const message = notificationFunction();\n  console.log(message);\n}\n\n\nconsole.log(\"=== 错误用法 ❌ ===\");\n// 错误：我们传递了 announce() 的 *返回值* (\"这是一个重要的通知！\")，而不是函数本身。\n// broadcast 函数期望得到一个函数，但却得到了一个字符串，所以它在尝试调用字符串时会报错。\ntry {\n  broadcast(announce()); // 错误！这里是 announce() 而不是 announce\n} catch (e) {\n  console.error(\"出错了！\", e.message);\n  console.log(\"原因：你把一个字符串传给了 broadcast，它没法像函数一样被调用 (notificationFunction is not a function)。\");\n}\n\n\nconsole.log(\"\\n=== 正确用法 ✅ ===\");\n// 正确：我们传递了 announce 函数的 *引用*（函数本身）。\n// broadcast 函数内部可以随时调用它。\nbroadcast(announce); // 正确！传递的是函数本身", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-1-函数作为参数.md", "blockIndex": 3}
{"id": "js-sec-3-1-1", "title": "函数作为参数", "code": "// 角色状态\nconst player = {\n  name: \"闪电法师\",\n  mana: 100, // 法力值\n};\n\n// --- 技能库 ---\nfunction castFireball(target) {\n  const cost = 30;\n  console.log(`🔥 对 ${target} 施放了【火球术】！造成 50 点伤害！`);\n  return cost;\n}\n\nfunction castIceShield(target) {\n  const cost = 20;\n  console.log(`❄️ 为 ${target} 施加了【冰霜护盾】！提升了防御力！`);\n  return cost;\n}\n\nfunction summonGolem(target) {\n  const cost = 70;\n  console.log(`🗿 在 ${target} 面前召唤了【岩石傀儡】！它会为你战斗！`);\n  return cost;\n}\n\n/**\n * 通用的技能释放器\n * @param {object} character - 释放技能的角色\n * @param {string} target - 技能目标\n * @param {function} skillFunction - 要释放的技能函数\n */\nfunction useSkill(character, target, skillFunction) {\n  console.log(`\\n--- ${character.name} 的回合 ---`);\n  \n  // 模拟从技能函数获取法力消耗。\n  // 注意：这里我们只是为了演示，实际游戏中消耗可能更复杂\n  // 我们先“假装”调用一次来获取消耗值\n  const manaCost = skillFunction.toString().includes(\"30\") ? 30 : skillFunction.toString().includes(\"70\") ? 70 : 20;\n\n  console.log(`准备释放技能... 当前法力: ${character.mana}, 技能消耗: ${manaCost}`);\n  \n  if (character.mana >= manaCost) {\n    skillFunction(target); // 真正释放技能\n    character.mana -= manaCost;\n    console.log(`技能释放成功！剩余法力: ${character.mana}`);\n  } else {\n    console.log(`法力不足！无法释放技能。`);\n  }\n  console.log(`------------------------`);\n}\n\n// 让我们开始战斗！\n// 1. 闪电法师对巨龙使用火球术\nuseSkill(player, \"巨龙\", castFireball);\n\n// 2. 闪电法师为自己施加冰霜护盾\nuseSkill(player, \"自己\", castIceShield);\n\n// 3. 闪电法师尝试召唤傀儡，但法力可能不够了\nuseSkill(player, \"战场中央\", summonGolem);\n\n// 4. 再次尝试释放火球术\nuseSkill(player, \"巨龙\", castFireball);", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-1-函数作为参数.md", "blockIndex": 4}
{"id": "js-sec-3-1-2", "title": "函数作为返回值", "code": "// 定义一个函数 createGreeter，它不直接打招呼\n// 而是返回一个“专门用来打招呼”的函数\nfunction createGreeter() {\n  // 这里是返回的函数\n  return function() {\n    console.log(\"Hello, World!\");\n  };\n}\n\n// 调用 createGreeter()，我们得到的不是 \"Hello, World!\"\n// 而是得到了它返回的那个匿名函数\nconst greet = createGreeter();\n\n// 现在，greet 变量就是一个函数了\nconsole.log(\"greet 变量的类型:\", typeof greet);\n\n// 调用 greet 函数，才会真正执行 console.log\ngreet();", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-2-函数作为返回值.md", "blockIndex": 0}
{"id": "js-sec-3-1-2", "title": "函数作为返回值", "code": "function createCounter(initialValue) {\n  let count = initialValue;\n\n  // 这个返回的函数形成了一个闭包\n  // 它“记住”了变量 count\n  return function() {\n    count++;\n    console.log(\"当前计数值:\", count);\n  };\n}\n\n// 创建一个从 0 开始的计数器\nconst counterA = createCounter(0);\ncounterA(); // 输出: 当前计数值: 1\ncounterA(); // 输出: 当前计数值: 2\n\n// 创建另一个完全独立的计数器，从 10 开始\nconst counterB = createCounter(10);\ncounterB(); // 输出: 当前计数值: 11\ncounterB(); // 输出: 当前计数值: 12\n\n// 再次调用 counterA，它的 count 不受 counterB 的影响\ncounterA(); // 输出: 当前计数值: 3", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-2-函数作为返回值.md", "blockIndex": 1}
{"id": "js-sec-3-1-2", "title": "函数作为返回值", "code": "// 这是一个创建不同计算函数的“工厂”\nfunction createCalculator(operation) {\n  if (operation === 'add') {\n    return function(a, b) {\n      console.log(`${a} + ${b} =`, a + b);\n    };\n  } else if (operation === 'multiply') {\n    return function(a, b) {\n      console.log(`${a} * ${b} =`, a * b);\n    };\n  } else {\n    return function() {\n      console.log(\"不支持的操作!\");\n    };\n  }\n}\n\n// 从工厂“订购”一个加法函数\nconst add = createCalculator('add');\nadd(5, 3); // 输出: 5 + 3 = 8\n\n// 从工厂“订购”一个乘法函数\nconst multiply = createCalculator('multiply');\nmultiply(5, 3); // 输出: 5 * 3 = 15\n\n// 尝试一个不支持的操作\nconst unknown = createCalculator('divide');\nunknown(5, 3); // 输出: 不支持的操作!", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-2-函数作为返回值.md", "blockIndex": 2}
{"id": "js-sec-3-1-2", "title": "函数作为返回值", "code": "// 完整的对比示例\nfunction createGreeting(name) {\n  return \"Hello, \" + name;\n}\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误：我们想要一个函数，但却直接调用了它\n// createGreeting(name) 立即执行并返回一个字符串\n// 所以 myGreeter 变量只是一个字符串，而不是一个函数\nfunction createGreeterWrong(name) {\n  return createGreeting(name); // 这里返回的是字符串 \"Hello, Alice\"\n}\n\nconst myGreeter = createGreeterWrong(\"Alice\");\nconsole.log(\"myGreeter 的类型:\", typeof myGreeter);\ntry {\n  myGreeter(); // 这会报错，因为字符串不是函数\n} catch (e) {\n  console.error(\"出错了:\", e.message);\n}\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确：返回一个函数定义，而不是它的执行结果\n// 外层函数返回一个完整的、可以被后续调用的函数\nfunction createGreeterCorrect(name) {\n  // 返回一个匿名函数，这个函数“记住”了 name\n  return function() {\n    console.log(\"Hello, \" + name);\n  };\n}\n\nconst greetAlice = createGreeterCorrect(\"Alice\");\nconsole.log(\"greetAlice 的类型:\", typeof greetAlice);\ngreetAlice(); // 正确执行，输出: Hello, Alice\n\nconst greetBob = createGreeterCorrect(\"Bob\");\ngreetBob(); // 正确执行，输出: Hello, Bob", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-2-函数作为返回值.md", "blockIndex": 3}
{"id": "js-sec-3-1-2", "title": "函数作为返回值", "code": "/**\n * 宠物动作生成器工厂\n * @param {string} name - 宠物的名字\n * @param {string} icon - 代表宠物的表情符号\n * @returns {function} 一个能够根据心情生成动作描述的函数\n */\nfunction createPetActionGenerator(name, icon) {\n  let energy = 100; // 每个宠物都有自己的能量值，被闭包“记住”了\n\n  // 返回的这个函数就是我们为特定宠物定制的“动作生成器”\n  return function(mood) {\n    if (energy <= 0) {\n      return `${icon} ${name} 累得睡着了... Zzz...`;\n    }\n\n    switch (mood) {\n      case 'happy':\n        energy -= 10;\n        return `${icon} ${name} 开心地摇着尾巴！(能量: ${energy})`;\n      case 'hungry':\n        energy -= 5;\n        return `${icon} ${name} 用可怜巴巴的眼神看着你，肚子咕咕叫。 (能量: ${energy})`;\n      case 'playful':\n        energy -= 20;\n        return `${icon} ${name} 叼来一个球，想和你玩！ (能量: ${energy})`;\n      default:\n        energy -= 2;\n        return `${icon} ${name} 歪着头看着你，不知道你想干嘛。 (能量: ${energy})`;\n    }\n  };\n}\n\n// --- 开始我们的宠物养成游戏！ ---\n\n// 领养一只叫“旺财”的狗狗\nconsole.log(\"🎉 欢迎新伙伴，狗狗旺财！\");\nconst wangcaiAction = createPetActionGenerator(\"旺财\", \"🐶\");\n\n// 和旺财互动\nconsole.log(wangcaiAction('happy'));\nconsole.log(wangcaiAction('playful'));\n\n// 领养另一只叫“咪咪”的猫猫\nconsole.log(\"\\n🎉 欢迎新伙伴，猫猫咪咪！\");\nconst mimiAction = createPetActionGenerator(\"咪咪\", \"🐱\");\n\n// 和咪咪互动\nconsole.log(mimiAction('hungry'));\nconsole.log(mimiAction('happy'));\n\n// 再次和旺财互动，它的能量是独立的，不受咪咪影响\nconsole.log(\"\\n(回到旺财这边...)\");\nconsole.log(wangcaiAction('hungry'));", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-2-函数作为返回值.md", "blockIndex": 4}
{"id": "js-sec-3-1-3", "title": "闭包概念与应用", "code": "// Level 1: 基础认知\n\nfunction createGreeter(greeting) {\n  // greeting 和 name 变量被装进了返回的匿名函数的“记忆背包”里\n  const name = \"小明\";\n  \n  // 这个返回的函数就是一个闭包\n  return function() {\n    console.log(greeting + \", \" + name + \"!\");\n  };\n}\n\n// createGreeter函数执行完毕，它的作用域理应被销毁\n// 但因为闭包的存在，变量 greeting 和 name 被“记住”了\nconst sayHello = createGreeter(\"你好\");\nconst sayHi = createGreeter(\"Hi\");\n\n// 调用闭包函数\nsayHello(); // 输出: 你好, 小明!\nsayHi();    // 输出: Hi, 小明!", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-3-闭包概念与应用.md", "blockIndex": 0}
{"id": "js-sec-3-1-3", "title": "闭包概念与应用", "code": "// Level 2, 特性1: 数据私有化\n\nfunction createWallet(initialAmount) {\n  // balance 是一个私有变量，外界无法直接访问\n  let balance = initialAmount;\n\n  // 返回一个对象，包含了操作 balance 的方法（闭包）\n  return {\n    deposit: function(amount) {\n      if (amount > 0) {\n        balance += amount;\n        console.log(`存款成功! 当前余额: ${balance}`);\n      }\n    },\n    withdraw: function(amount) {\n      if (amount > 0 && amount <= balance) {\n        balance -= amount;\n        console.log(`取款成功! 当前余额: ${balance}`);\n      } else {\n        console.log(`取款失败! 余额不足或金额无效。`);\n      }\n    },\n    getBalance: function() {\n      console.log(`查询余额: ${balance}`);\n      return balance;\n    }\n  };\n}\n\nconst myWallet = createWallet(100);\n\n// 我们无法直接修改 balance\nconsole.log(\"尝试直接访问 myWallet.balance:\", myWallet.balance); // 输出: undefined\n\n// 只能通过暴露的方法来操作\nmyWallet.getBalance(); // 输出: 查询余额: 100\nmyWallet.deposit(50);  // 输出: 存款成功! 当前余额: 150\nmyWallet.withdraw(200); // 输出: 取款失败! 余额不足或金额无效。\nmyWallet.withdraw(30);  // 输出: 取款成功! 当前余额: 120", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-3-闭包概念与应用.md", "blockIndex": 1}
{"id": "js-sec-3-1-3", "title": "闭包概念与应用", "code": "// Level 2, 特性2: 独立的状态记忆\n\nfunction createCounter() {\n  let count = 0; // 每个计数器都有自己独立的 count\n  return function() {\n    count++;\n    console.log(count);\n  };\n}\n\nconsole.log(\"--- 计数器A ---\");\nconst counterA = createCounter(); // 创建第一个闭包实例\ncounterA(); // 输出: 1\ncounterA(); // 输出: 2\n\nconsole.log(\"--- 计数器B ---\");\nconst counterB = createCounter(); // 创建第二个独立的闭包实例\ncounterB(); // 输出: 1 (它从自己的0开始，不受counterA影响)\ncounterB(); // 输出: 2\n\nconsole.log(\"--- 回到计数器A ---\");\ncounterA(); // 输出: 3 (它记住了自己的状态是2)", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-3-闭包概念与应用.md", "blockIndex": 2}
{"id": "js-sec-3-1-3", "title": "闭包概念与应用", "code": "// Level 3: 对比学习\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误原因：循环中使用 var 声明变量\n// for循环执行完毕后，变量 i 的最终值是 3。\n// setTimeout里的所有回调函数共享同一个作用域，它们引用的都是这个最终的 i。\n// 所以当1秒后回调执行时，它们读取到的 i 都是 3。\nfunction wrongLoop() {\n  for (var i = 0; i < 3; i++) {\n    setTimeout(function() {\n      console.log(`[错误] 1秒后，我以为 i 是我创建时的值，但其实是... ${i}`);\n    }, 1000);\n  }\n}\nwrongLoop(); // 预期输出 0, 1, 2，但实际会连续输出三个 3\n\n\nconsole.log(\"=== 正确用法 ===\");\n// ✅ 正确做法：使用 let 声明变量\n// let 具有块级作用域特性。在 for 循环中，每次迭代都会为 i 创建一个新的词法环境（一个新的“记忆背包”）。\n// 因此，每个 setTimeout 的回调函数都关闭（capture）了不同迭代中的 i 变量。\nfunction correctLoop() {\n  for (let i = 0; i < 3; i++) {\n    setTimeout(function() {\n      console.log(`[正确] 1秒后，我记住了我创建时的 i 值: ${i}`);\n    }, 1000);\n  }\n}\ncorrectLoop(); // 1秒后会依次输出 0, 1, 2", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-3-闭包概念与应用.md", "blockIndex": 3}
{"id": "js-sec-3-1-3", "title": "闭包概念与应用", "code": "// Level 4: 游戏角色生成器\n\nfunction createAdventurer(name) {\n  // 角色的私有属性，外界无法直接修改\n  let level = 1;\n  let exp = 0;\n  let hp = 100;\n  const maxHp = 100;\n  \n  // 计算升级所需经验，这是一个内部辅助函数\n  const expToNextLevel = () => 10 * Math.pow(level, 2);\n\n  // 升级逻辑，也是内部函数\n  const levelUp = () => {\n    level++;\n    exp = 0; // 经验值清零或减去升级所需\n    hp = maxHp + (level - 1) * 20; // 升级后血量增加\n    console.log(`🎉 升级啦！ ${name} 已达到 Level ${level}！生命值提升至 ${hp}！`);\n  };\n\n  // 返回一个包含公开方法的对象，这些方法形成闭包\n  return {\n    fightMonster: function() {\n      const gainedExp = Math.floor(Math.random() * 25) + 5; // 随机获得5-30点经验\n      exp += gainedExp;\n      console.log(`⚔️ ${name} 奋力战斗，获得了 ${gainedExp} 点经验值。`);\n\n      if (exp >= expToNextLevel()) {\n        levelUp();\n      }\n    },\n    showStatus: function() {\n      console.log(\n        `--- 冒险家档案 ---\\n` +\n        `  姓名: ${name}\\n` +\n        `  等级: ${level}\\n` +\n        `  生命值: ${hp}\\n` +\n        `  经验值: ${exp} / ${expToNextLevel()}\\n` +\n        `--------------------`\n      );\n    }\n  };\n}\n\n// 创建两个独立的冒险家\nconst knight = createAdventurer(\"圣光骑士·阿尔文\");\nconst mage = createAdventurer(\"奥术法师·莉娜\");\n\nconsole.log(\"冒险开始！\");\nknight.showStatus();\n\nconsole.log(\"\\n阿尔文开始了他的征程...\");\nknight.fightMonster();\nknight.fightMonster();\nknight.fightMonster();\nknight.fightMonster(); // 可能会升级\nknight.showStatus();\n\nconsole.log(\"\\n莉娜也出发了，她的状态不受阿尔文影响。\");\nmage.showStatus();\n\n// 尝试作弊修改等级（失败）\nconsole.log(`\\n尝试作弊... knight.level is: ${knight.level}`); // undefined\nconsole.log(\"作弊失败！数据被闭包保护得很好！\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-3-闭包概念与应用.md", "blockIndex": 4}
{"id": "js-sec-3-1-4", "title": "柯里化", "code": "// 传统函数：一次性传入所有参数\nfunction add(a, b) {\n  return a + b;\n}\nconsole.log(`传统函数调用: add(5, 3) = ${add(5, 3)}`);\n\n// 柯里化函数：分步传入参数\nfunction curriedAdd(a) {\n  return function(b) {\n    return a + b;\n  };\n}\n\n// 调用柯里化函数\nconst addFive = curriedAdd(5); // 得到一个新函数，它会给传入的参数加上5\nconst result = addFive(3);     // 调用新函数\n\nconsole.log(`柯里化函数调用: curriedAdd(5)(3) = ${result}`);\nconsole.log(`addFive(10) 的结果是: ${addFive(10)}`);", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-4-柯里化.md", "blockIndex": 0}
{"id": "js-sec-3-1-4", "title": "柯里化", "code": "// 一个通用的日志函数\nfunction log(level, time, message) {\n  console.log(`[${level}] @ ${time.toTimeString()}: ${message}`);\n}\n\n// 手动进行部分应用\nfunction curryLog(level) {\n  return function(time) {\n    return function(message) {\n      console.log(`[${level}] @ ${time.toTimeString()}: ${message}`);\n    }\n  }\n}\n\n// 1. 创建一个专门用于记录“调试”信息的日志函数\nconst logDebug = curryLog('DEBUG');\n// 2. 在未来的某个时间点，用这个专门的函数记录信息\n// 我们不需要再每次都传入 'DEBUG'\nlogDebug(new Date())('用户点击了按钮A');\nsetTimeout(() => {\n  logDebug(new Date())('数据加载完成');\n}, 1000);\n\n// 也可以创建其他类型的日志函数\nconst logError = curryLog('ERROR');\nlogError(new Date())('API请求失败');", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-4-柯里化.md", "blockIndex": 1}
{"id": "js-sec-3-1-4", "title": "柯里化", "code": "// 一个通用的乘法函数\nfunction multiply(a, b) {\n  return a * b;\n}\n\n// 一个简单的柯里化转换器\nfunction curry(fn) {\n  return function curried(...args) {\n    // 如果传入的参数数量足够，就直接执行原函数\n    if (args.length >= fn.length) {\n      return fn.apply(this, args);\n    } else {\n      // 否则，返回一个新函数，等待接收剩余的参数\n      return function(...args2) {\n        return curried.apply(this, args.concat(args2));\n      }\n    }\n  };\n}\n\nconst curriedMultiply = curry(multiply);\n\n// 基于 curriedMultiply 动态创建新函数\nconst double = curriedMultiply(2); // 创建一个“翻倍”函数\nconst triple = curriedMultiply(3); // 创建一个“三倍”函数\nconst tenTimes = curriedMultiply(10); // 创建一个“十倍”函数\n\nconsole.log(\"使用'double'函数:\", double(5));   // 输出: 10\nconsole.log(\"使用'triple'函数:\", triple(5));   // 输出: 15\nconsole.log(\"使用'tenTimes'函数:\", tenTimes(5)); // 输出: 50", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-4-柯里化.md", "blockIndex": 2}
{"id": "js-sec-3-1-4", "title": "柯里化", "code": "// 一个通用的函数，用于格式化消息\nfunction formatMessage(sender, receiver, message) {\n  return `From ${sender} to ${receiver}: ${message}`;\n}\n\n// 通用的柯里化工具函数\nfunction curry(fn) {\n  return function curried(...args) {\n    if (args.length >= fn.length) {\n      return fn.apply(this, args);\n    } else {\n      return function(...nextArgs) {\n        return curried.apply(this, args.concat(nextArgs));\n      };\n    }\n  };\n}\n\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 这是一个“硬编码”的、不灵活的类柯里化函数\nfunction inflexibleCurryFormat(sender) {\n  return function(receiver, message) { // 强制要求后面两个参数一起传入\n    return formatMessage(sender, receiver, message);\n  };\n}\n\nconst aliceSends = inflexibleCurryFormat(\"Alice\");\n// aliceSends(\"Bob\", \"Hello!\"); // 这样可以工作\n// aliceSends(\"Bob\")(\"Hello!\"); // 这样会报错! TypeError: aliceSends(...) is not a function\n\nconsole.log(\"❌ 无法分步调用所有参数: inflexibleCurryFormat('Alice')('Bob')('Hello!') 会导致 TypeError\");\nconsole.log(\"这种方式限制了函数的组合能力，不够灵活。\");\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 使用通用的柯里化函数，它非常灵活\nconst curriedFormat = curry(formatMessage);\n\n// 我们可以根据需要，以任何组合方式传递参数\nconst msg1 = curriedFormat(\"Alice\", \"Bob\", \"Hello!\"); // 1. 一次性调用\nconst msg2 = curriedFormat(\"Alice\")(\"Bob\", \"Hello!\"); // 2. 分步调用\nconst msg3 = curriedFormat(\"Alice\", \"Bob\")(\"Hello!\"); // 3. 混合调用\n\nconst aliceSendsFlexible = curriedFormat(\"Alice\");\nconst aliceToBob = aliceSendsFlexible(\"Bob\");\nconst msg4 = aliceToBob(\"See you tomorrow!\"); // 4. 创建多个中间函数\n\nconsole.log(\"✅ 一次性调用:\", msg1);\nconsole.log(\"✅ 完全分步调用:\", msg2);\nconsole.log(\"✅ 混合调用:\", msg3);\nconsole.log(\"✅ 创建中间函数后调用:\", msg4);\nconsole.log(\"正确的柯里化提供了极大的灵活性，方便函数组合和复用。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-4-柯里化.md", "blockIndex": 3}
{"id": "js-sec-3-1-4", "title": "柯里化", "code": "// 通用的柯里化工具函数\nfunction curry(fn) {\n  return function curried(...args) {\n    if (args.length >= fn.length) {\n      return fn.apply(this, args);\n    } else {\n      return function(...nextArgs) {\n        return curried.apply(this, args.concat(nextArgs));\n      };\n    }\n  };\n}\n\n/**\n * 基础价格计算函数\n * @param {string} size - 尺寸 ('S', 'M', 'L')\n * @param {Array<string>} toppings - 配料列表\n * @param {number} discount - 折扣 (例如 0.1 表示 10% off)\n * @returns {string} - 最终价格描述\n */\nfunction calculatePizzaPrice(size, toppings, discount) {\n  const basePrices = { S: 50, M: 70, L: 90 };\n  const toppingPrice = 5; // 每份配料5元\n\n  const basePrice = basePrices[size];\n  if (!basePrice) return \"无效的尺寸！\";\n\n  const toppingsCost = toppings.length * toppingPrice;\n  const total = (basePrice + toppingsCost) * (1 - discount);\n\n  return `一个${size}寸披萨，加了[${toppings.join(', ')}]，\n  享受${discount * 100}%折扣后，总价: ${total.toFixed(2)}元！🍕`;\n}\n\n// 将我们的价格计算函数柯里化\nconst curriedPriceCalculator = curry(calculatePizzaPrice);\n\n// --- 模拟顾客点餐流程 ---\n\n// 步骤1: 顾客选定了尺寸，我们生成一个“中号披萨”计算器\nconsole.log(\"👨‍🍳 欢迎光临！请选择您的披萨尺寸。\");\nconst calculateMediumPizza = curriedPriceCalculator('M');\nconsole.log(\"👍 您选择了中号披萨，现在请添加配料。\");\n\n// 步骤2: 顾客添加了配料，我们生成一个“中号加了芝士和蘑菇”的计算器\nconst toppings = ['双倍芝士', '蘑菇', '青椒'];\nconst mediumPizzaWithToppings = calculateMediumPizza(toppings);\nconsole.log(`👌 配料已添加: [${toppings.join(', ')}]，正在为您计算价格...`);\n\n// 步骤3: 应用不同的折扣\nconsole.log(\"\\n--- 应用不同折扣 ---\");\nconst studentDiscount = 0.1; // 学生9折\nconst vipDiscount = 0.2;     // VIP 8折\n\nconst finalPriceForStudent = mediumPizzaWithToppings(studentDiscount);\nconst finalPriceForVIP = mediumPizzaWithToppings(vipDiscount);\n\nconsole.log(\"🎓 学生优惠价:\", finalPriceForStudent);\nconsole.log(\"🌟 VIP会员价:\", finalPriceForVIP);", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-4-柯里化.md", "blockIndex": 4}
{"id": "js-sec-3-1-5", "title": "函数组合", "code": "// 任务1: 将数字加倍\nconst double = (x) => x * 2;\n\n// 任务2: 将数字加1\nconst addOne = (x) => x + 1;\n\n// 初始数字\nconst initialNumber = 5;\n\n// 最基础的函数组合：将 double 的结果作为 addOne 的输入\nconst result = addOne(double(initialNumber));\n\nconsole.log(`对数字 ${initialNumber} 执行加倍再加一的操作，结果是: ${result}`);\n// 预期输出: 对数字 5 执行加倍再加一的操作，结果是: 11", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-5-函数组合.md", "blockIndex": 0}
{"id": "js-sec-3-1-5", "title": "函数组合", "code": "// compose 辅助函数，它接收多个函数，并从右向左组合它们\n// (...fns) => (initialValue) => ... 这是一个高阶函数的写法\nconst compose = (...fns) => (initialValue) => fns.reduceRight((acc, fn) => fn(acc), initialValue);\n\n// 定义一些简单的功能函数\nconst toUpperCase = (str) => str.toUpperCase();\nconst exclaim = (str) => `${str}!`;\nconst greet = (name) => `Hello, ${name}`;\n\n// 使用 compose 将三个函数组合成一个新的函数\nconst loudGreeting = compose(exclaim, toUpperCase, greet);\n\n// 调用新生成的函数\nconst result = loudGreeting('Alice');\n\nconsole.log(result);\n// 预期输出: HELLO, ALICE!\n// 执行顺序: greet('Alice') -> 'Hello, Alice'\n//          toUpperCase('Hello, Alice') -> 'HELLO, ALICE'\n//          exclaim('HELLO, ALICE') -> 'HELLO, ALICE!'", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-5-函数组合.md", "blockIndex": 1}
{"id": "js-sec-3-1-5", "title": "函数组合", "code": "// pipe 辅助函数，从左向右组合函数\nconst pipe = (...fns) => (initialValue) => fns.reduce((acc, fn) => fn(acc), initialValue);\n\n// 定义一系列数学运算函数\nconst add5 = (x) => x + 5;\nconst multiplyBy3 = (x) => x * 3;\nconst subtract10 = (x) => x - 10;\n\n// 使用 pipe 创建一个计算流水线\n// 阅读顺序与执行顺序一致：先+5，再*3，最后-10\nconst calculate = pipe(add5, multiplyBy3, subtract10);\n\nconst initialValue = 10;\nconst result = calculate(initialValue);\n\nconsole.log(`计算流水线: ((${initialValue} + 5) * 3) - 10 = ${result}`);\n// 预期输出: 计算流水线: ((10 + 5) * 3) - 10 = 35", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-5-函数组合.md", "blockIndex": 2}
{"id": "js-sec-3-1-5", "title": "函数组合", "code": "// 定义一些处理不同数据类型的函数\nconst splitString = (str) => str.split(' '); // 输入: string, 输出: array\nconst countItems = (arr) => arr.length;      // 输入: array, 输出: number\nconst isEven = (num) => num % 2 === 0;       // 输入: number, 输出: boolean\n\n// pipe 辅助函数，从左向右组合\nconst pipe = (...fns) => (initialValue) => fns.reduce((acc, fn) => fn(acc), initialValue);\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误地组合了函数，countItems 的输出是 number，但 splitString 需要 string\ntry {\n    const wrongCombination = pipe(countItems, splitString);\n    wrongCombination(['hello', 'world']);\n} catch (error) {\n    console.log(\"出错了:\", error.message);\n    console.log(\"原因: countItems返回一个数字，但splitString需要一个字符串作为输入，导致 .split() 方法不存在而出错。\");\n}\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确的组合，确保前一个函数的输出类型是后一个函数的期望输入类型\nconst processSentence = pipe(splitString, countItems, isEven);\n\nconst sentence1 = \"this is a sample sentence\"; // 6个单词\nconst sentence2 = \"another one\"; // 2个单词\n\nconst result1 = processSentence(sentence1);\nconst result2 = processSentence(sentence2);\n\nconsole.log(`句子 \"${sentence1}\" 的单词数是偶数吗? ${result1}`);\nconsole.log(`句子 \"${sentence2}\" 的单词数是偶数吗? ${result2}`);\n// 预期输出:\n// 句子 \"this is a sample sentence\" 的单词数是偶数吗? true\n// 句子 \"another one\" 的单词数是偶数吗? true", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-5-函数组合.md", "blockIndex": 3}
{"id": "js-sec-3-1-5", "title": "函数组合", "code": "// compose 辅助函数，从右向左组合\nconst compose = (...fns) => (initialValue) => fns.reduceRight((acc, fn) => fn(acc), initialValue);\n\n// --- 角色部件函数 (每个函数都接收一个字符串数组并返回一个新的字符串数组) ---\n\n// 添加头部\nconst addHead = (character) => ['  O  ', ...character];\n\n// 添加身体\nconst addBody = (character) => [...character, ' /|\\\\ ', '  |  '];\n\n// 添加腿部\nconst addLegs = (character) => [...character, ' / \\\\ '];\n\n// 穿上盔甲\nconst addArmor = (character) => {\n    character[1] = ' /|█|\\\\'; // 替换身体部分\n    character[2] = '  █  ';\n    return character;\n};\n\n// 拿起宝剑\nconst addSword = (character) => {\n    character[0] = '  O  <-- Master Sword!';\n    character[1] = ' /|█|\\\\o'; // 手持剑\n    return character;\n};\n\n// 戴上巫师帽\nconst addWizardHat = (character) => {\n    character[0] = '  ^  '; // 帽子\n    character[1] = ' (O) '; // 戴帽子的头\n    return character;\n};\n\n// --- 角色创建流水线 ---\n\n// 创建一个基础村民\nconst createVillager = compose(addLegs, addBody, addHead);\n\n// 创建一个全副武装的骑士\nconst createKnight = compose(addSword, addArmor, addLegs, addBody, addHead);\n\n// 创建一个神秘的巫师\nconst createWizard = compose(addWizardHat, addLegs, addBody, addHead);\n\n// --- 开始生成！ ---\n\n// 初始状态是一个空的角色画布（一个空数组）\nconst emptyCanvas = [];\n\nconsole.log(\"--- 生成一个村民 ---\");\nconst villager = createVillager(emptyCanvas);\nconsole.log(villager.join('\\n'));\n\nconsole.log(\"\\n--- 生成一个骑士 ---\");\nconst knight = createKnight(emptyCanvas);\nconsole.log(knight.join('\\n'));\n\nconsole.log(\"\\n--- 生成一个巫师 ---\");\nconst wizard = createWizard(emptyCanvas);\nconsole.log(wizard.join('\\n'));\n\n/*\n预期输出:\n\n--- 生成一个村民 ---\n  O  \n /|\\ \n  |  \n / \\ \n\n--- 生成一个骑士 ---\n  O  <-- Master Sword!\n /|█|\\o\n  █  \n / \\ \n\n--- 生成一个巫师 ---\n  ^  \n (O) \n /|\\ \n  |  \n / \\ \n\n*/", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-1-5-函数组合.md", "blockIndex": 4}
{"id": "js-sec-3-2-1", "title": "this的四种绑定规则", "code": "// 当一个函数被一个对象“拥有”并调用时，this就指向那个对象\nconst player = {\n  name: '勇者',\n  level: 5,\n  showStatus: function() {\n    // 这里的 this 指向 player 对象\n    console.log(`${this.name} (等级 ${this.level}) 状态良好！`);\n  }\n};\n\n// 通过 player 对象调用 showStatus 方法\nplayer.showStatus();\n// 输出: 勇者 (等级 5) 状态良好！", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-2-1-this的四种绑定规则.md", "blockIndex": 0}
{"id": "js-sec-3-2-1", "title": "this的四种绑定规则", "code": "// 在非严格模式下，独立调用的函数 this 指向全局对象 (如 window)\nfunction checkThis() {\n  // 在浏览器环境中，this 会是 window 对象。\n  // 在 Node.js 环境中，this 会是 global 对象。\n  // 为了通用性，我们检查 this 是否等于全局对象。\n  console.log(\"this 是全局对象吗?\", this === globalThis); // globalThis 是一个标准属性，在任何环境中都指向全局对象\n}\n\ncheckThis(); // 直接调用，不通过任何对象\n// 输出: this 是全局对象吗? true", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-2-1-this的四种绑定规则.md", "blockIndex": 1}
{"id": "js-sec-3-2-1", "title": "this的四种绑定规则", "code": "// 谁调用，this就指向谁\nfunction attack() {\n  console.log(`${this.name} 发动了攻击！造成 ${this.damage} 点伤害。`);\n}\n\nconst warrior = {\n  name: '剑士',\n  damage: 15,\n  performAttack: attack\n};\n\nconst mage = {\n  name: '法师',\n  damage: 20,\n  performAttack: attack\n};\n\nwarrior.performAttack(); // attack 函数由 warrior 调用，this 指向 warrior\n// 输出: 剑士 发动了攻击！造成 15 点伤害。\n\nmage.performAttack(); // attack 函数由 mage 调用，this 指向 mage\n// 输出: 法师 发动了攻击！造成 20 点伤害。", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-2-1-this的四种绑定规则.md", "blockIndex": 2}
{"id": "js-sec-3-2-1", "title": "this的四种绑定规则", "code": "function castSpell(spellName) {\n  console.log(`${this.name} 吟唱了咒语: \"${spellName}\"!`);\n}\n\nconst wizard = { name: '甘道夫' };\nconst witch = { name: '赫敏' };\n\n// 使用 .call() 强制将 castSpell 的 this 绑定到 wizard 对象\ncastSpell.call(wizard, '火焰球');\n// 输出: 甘道夫 吟唱了咒语: \"火焰球\"!\n\n// 使用 .apply() 作用类似，但参数需要放在数组里\ncastSpell.apply(witch, ['漂浮咒']);\n// 输出: 赫敏 吟唱了咒语: \"漂浮咒\"!\n\n// 使用 .bind() 会创建一个新函数，其 this 被永久绑定\nconst hermioneCasts = castSpell.bind(witch);\nhermioneCasts('守护神咒');\n// 输出: 赫敏 吟唱了咒语: \"守护神咒\"!", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-2-1-this的四种绑定规则.md", "blockIndex": 3}
{"id": "js-sec-3-2-1", "title": "this的四种绑定规则", "code": "// 构造函数，通常首字母大写\nfunction Monster(name, type) {\n  // 1. new 会创建一个空对象 {}\n  // 2. this 会被绑定到这个新对象上\n  this.name = name;\n  this.type = type;\n  this.isAlive = true;\n  // 3. 这个新对象会被返回 (除非函数显式返回另一个对象)\n}\n\nconst slime = new Monster('史莱姆', '凝胶怪');\nconst goblin = new Monster('哥布林', '人形怪');\n\nconsole.log(`新的怪物诞生了: ${slime.name}，种类: ${slime.type}`);\nconsole.log(`新的怪物诞生了: ${goblin.name}，种类: ${goblin.type}`);\n// 输出:\n// 新的怪物诞生了: 史莱姆，种类: 凝胶怪\n// 新的怪物诞生了: 哥布林，种类: 人形怪", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-2-1-this的四种绑定规则.md", "blockIndex": 4}
{"id": "js-sec-3-2-1", "title": "this的四种绑定规则", "code": "// 完整的对比示例，包含所有必要的变量定义\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误：在 setTimeout 的回调中丢失 this\nconst adventurer = {\n  name: \"林克\",\n  action: \"探索\",\n  goOnAdventure: function() {\n    console.log(`${this.name} 开始了冒险！`);\n    // setTimeout 的回调函数是独立调用的，不通过 adventurer 对象\n    setTimeout(function() {\n      // 这里的 this 遵循“默认绑定”，指向全局对象 (window)\n      // window.action 是 undefined，所以结果很奇怪\n      console.log(`1秒后, ${this.name} 正在 ${this.action}... (糟糕，this丢了!)`);\n    }, 1000);\n  }\n};\nadventurer.goOnAdventure();\n// 输出:\n// 林克 开始了冒险！\n// 1秒后, undefined 正在 undefined... (糟糕，this丢了!)\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确：使用箭头函数或 .bind() 保持 this 上下文\nconst smartAdventurer = {\n  name: \"塞尔达\",\n  action: \"研究\",\n  goOnAdventure: function() {\n    console.log(`${this.name} 开始了冒险！`);\n    // 方案一：箭头函数。它没有自己的 this，会捕获外层作用域的 this\n    setTimeout(() => {\n      console.log(`(箭头函数) 1秒后, ${this.name} 正在 ${this.action}... (成功!)`);\n    }, 1000);\n\n    // 方案二：使用 .bind() 显式绑定 this\n    const callback = function() {\n        console.log(`(.bind) 1秒后, ${this.name} 正在 ${this.action}... (也成功!)`);\n    }.bind(this);\n    setTimeout(callback, 2000);\n  }\n};\nsmartAdventurer.goOnAdventure();\n// 输出:\n// 塞尔达 开始了冒险！\n// (箭头函数) 1秒后, 塞尔达 正在 研究... (成功!)\n// (.bind) 1秒后, 塞尔达 正在 研究... (也成功!)", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-2-1-this的四种绑定规则.md", "blockIndex": 5}
{"id": "js-sec-3-2-1", "title": "this的四种绑定规则", "code": "// 🐾 CodePet - 虚拟宠物养成游戏 🐾\n\n// 构造函数，用于创建新的宠物 (new 绑定)\nfunction CodePet(name, emoji) {\n  this.name = name;\n  this.emoji = emoji;\n  this.happiness = 50;\n  this.hunger = 50;\n  console.log(`欢迎 ${this.emoji} ${this.name} 来到这个世界!`);\n}\n\n// 使用原型添加方法，这是标准做法\nCodePet.prototype.showStatus = function() {\n  let status = '😐';\n  if (this.happiness > 70) status = '😄';\n  if (this.happiness < 30) status = '😢';\n  if (this.hunger > 70) status += '🍔';\n  if (this.hunger < 30) status += '😵';\n  console.log(`[状态] ${this.emoji} ${this.name}: 开心 ${this.happiness}, 饥饿 ${this.hunger} ${status}`);\n};\n\n// 喂食方法 (隐式绑定)\nCodePet.prototype.feed = function() {\n  console.log(`[喂食] 你给了 ${this.name} 一块美味的饼干!`);\n  this.hunger = Math.max(0, this.hunger - 20);\n  this.happiness += 10;\n  this.showStatus();\n};\n\n// 玩耍方法 (隐式绑定)\nCodePet.prototype.play = function() {\n  console.log(`[玩耍] 你和 ${this.name} 玩了抛球游戏!`);\n  this.hunger += 15;\n  this.happiness = Math.min(100, this.happiness + 20);\n  this.showStatus();\n};\n\n// 一个独立的“特殊款待”函数\nfunction giveSpecialTreat(treat) {\n  console.log(`[特殊款待] 哇！${this.name} 得到了一个 ${treat}! 开心值飙升！`);\n  this.happiness = 100;\n  this.showStatus();\n}\n\n\n// --- 游戏开始 ---\nconsole.log(\"--- 领养你的第一只宠物 ---\");\nconst myPet = new CodePet('小比特', '🐶');\nmyPet.showStatus();\n\nconsole.log(\"\\n--- 日常互动 (隐式绑定) ---\");\nmyPet.feed();\nmyPet.play();\n\nconsole.log(\"\\n--- 使用特殊道具 (显式绑定) ---\");\n// myPet 没有 giveSpecialTreat 方法，但我们可以用 .call() 强制让它享用\ngiveSpecialTreat.call(myPet, '皇家代码骨头');\n\nconsole.log(\"\\n--- 克隆宠物 (new 绑定) ---\");\nconst clonedPet = new CodePet(myPet.name + '二号', '🤖');\nclonedPet.showStatus();\n", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-2-1-this的四种绑定规则.md", "blockIndex": 6}
{"id": "js-sec-3-2-2", "title": "call/apply/bind", "code": "// 角色A有一个自我介绍的技能\nconst characterA = {\n  name: \"皮卡丘\",\n  introduce: function() {\n    console.log(`我是 ${this.name}！`);\n  }\n};\n\n// 角色B没有这个技能\nconst characterB = {\n  name: \"伊布\"\n};\n\n// 初始情况\ncharacterA.introduce(); // 输出: 我是 皮卡丘！\n\n// 使用 call，让角色B“借用”角色A的 introduce 技能\n// 第一个参数 characterB 就是我们要指定的 this\nconsole.log(\"--- 借用技能后 ---\");\ncharacterA.introduce.call(characterB); // 输出: 我是 伊布！", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-2-2-call-apply-bind.md", "blockIndex": 0}
{"id": "js-sec-3-2-2", "title": "call/apply/bind", "code": "const chef = {\n  name: \"料理鼠王\"\n};\n\nfunction cook(dish, seasoning) {\n  console.log(`${this.name} 正在烹饪 ${dish}，加入了 ${seasoning}。`);\n}\n\n// 使用 call: 参数需要一个一个地列出来\n// 'call' 的 'c' 可以联想为 'comma' (逗号分隔)\nconsole.log(\"--- 使用 call ---\");\ncook.call(chef, \"法式焗蜗牛\", \"百里香\");\n// 输出: 料理鼠王 正在烹饪 法式焗蜗牛，加入了 百里香。\n\n// 使用 apply: 参数需要放在一个数组里\n// 'apply' 的 'a' 可以联想为 'array' (数组)\nconsole.log(\"--- 使用 apply ---\");\nconst ingredients = [\"普罗旺斯炖菜\", \"迷迭香\"];\ncook.apply(chef, ingredients);\n// 输出: 料理鼠王 正在烹饪 普罗旺斯炖菜，加入了 迷迭香。", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-2-2-call-apply-bind.md", "blockIndex": 1}
{"id": "js-sec-3-2-2", "title": "call/apply/bind", "code": "const cat = {\n  name: \"汤姆\",\n  catchMouse: function() {\n    console.log(`${this.name} 正在抓老鼠！`);\n  }\n};\n\n// 直接将方法赋给变量，`this` 会丢失\nconst action = cat.catchMouse;\ntry {\n  action(); // 在非严格模式下 this 指向全局对象(window)，严格模式下是 undefined，会报错\n} catch (e) {\n  console.log(\"直接调用失败了，因为 this 不是 cat！\", e.message);\n}\n\n\n// 使用 bind 创建一个新函数，并将 this 永久绑定到 cat 对象上\nconst boundAction = cat.catchMouse.bind(cat);\n\n// 现在，无论在哪里调用 boundAction，它的 this 都会是 cat\nconsole.log(\"--- 使用 bind 后的效果 ---\");\nboundAction(); // 输出: 汤姆 正在抓老鼠！\n\n// 模拟一个延迟执行的场景\nsetTimeout(boundAction, 100); // 100毫秒后输出: 汤姆 正在抓老鼠！", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-2-2-call-apply-bind.md", "blockIndex": 2}
{"id": "js-sec-3-2-2", "title": "call/apply/bind", "code": "// 模拟一个简单的事件处理器\nconst button = {\n  content: '点我!',\n  // 假设这是一个点击事件的监听器\n  // 它期望接收一个函数作为参数，在“点击”时执行\n  addEventListener: function(eventName, handler) {\n    if (eventName === 'click') {\n      console.log(`为 \"${this.content}\" 按钮绑定了点击事件...`);\n      // 模拟点击后执行 handler\n      handler();\n    }\n  }\n};\n\nconst player = {\n  name: '马里奥',\n  jump: function() {\n    console.log(`${this.name} 跳起来了！`);\n  }\n};\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误：使用 call 会立即执行 player.jump，\n// 然后将它的返回值(undefined)作为事件处理函数。\n// 这不是我们想要的！函数在绑定时就被执行了。\ntry {\n    button.addEventListener('click', player.jump.call(player));\n} catch(e) {\n    console.log(\"这里会报错，因为传给 addEventListener 的不是函数，而是 undefined。\");\n    console.log(e.message);\n}\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确：使用 bind 会创建一个新函数，这个新函数绑定了正确的 this，\n// 并且可以被 addEventListener 稍后（在“点击”时）调用。\nconst boundJump = player.jump.bind(player);\nbutton.addEventListener('click', boundJump);\n// 输出:\n// 为 \"点我!\" 按钮绑定了点击事件...\n// 马里奥 跳起来了！", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-2-2-call-apply-bind.md", "blockIndex": 3}
{"id": "js-sec-3-2-2", "title": "call/apply/bind", "code": "// 通用的技能函数，它们依赖 `this` 来确定作用于哪个角色\nfunction levelUp(hpBoost, mpBoost) {\n  this.hp += hpBoost;\n  this.mp += mpBoost;\n  console.log(`[升级!] ${this.name} 生命值 +${hpBoost}, 魔法值 +${mpBoost}。当前状态: HP ${this.hp}, MP ${this.mp}`);\n}\n\nfunction castSpell(spellName, cost) {\n  if (this.mp >= cost) {\n    this.mp -= cost;\n    console.log(`✨ ${this.name} 施放了 [${spellName}]! 消耗 ${cost} MP。剩余 MP: ${this.mp}`);\n  } else {\n    console.log(`❌ ${this.name} 魔法值不足，无法施放 [${spellName}]!`);\n  }\n}\n\n// 创建两个不同的角色\nconst warrior = {\n  name: \"狂战士·阿尔萨斯\",\n  hp: 100,\n  mp: 30\n};\n\nconst mage = {\n  name: \"大法师·吉安娜\",\n  hp: 70,\n  mp: 120\n};\n\nconsole.log(\"--- 游戏开始 ---\");\nconsole.log(`${warrior.name}: HP ${warrior.hp}, MP ${warrior.mp}`);\nconsole.log(`${mage.name}: HP ${mage.hp}, MP ${mage.mp}\\n`);\n\n\n// 场景1: 战士喝下了“巨力药水”，立即获得属性提升 (使用 call)\n// call 很适合这种一次性的、立即生效的调用\nconsole.log(\"--- 场景1: 战士使用药水 (call) ---\");\nlevelUp.call(warrior, 20, 5); // 立即为 warrior 提升 20 HP 和 5 MP\n\n\n// 场景2: 法师找到了一个“智慧卷轴”，卷轴上的增益是以数组形式记录的 (使用 apply)\n// apply 非常适合处理参数是数组的情况\nconsole.log(\"\\n--- 场景2: 法师使用卷轴 (apply) ---\");\nconst scrollBoosts = [10, 40]; // [hpBoost, mpBoost]\nlevelUp.apply(mage, scrollBoosts);\n\n\n// 场景3: 法师学会了一个新技能“奥术护盾”，这是一个固化技能 (使用 bind)\n// bind 可以创建一个“预设”了施法者和法术名称的新技能函数，方便以后多次使用\nconsole.log(\"\\n--- 场景3: 法师学习新技能 (bind) ---\");\n// 创建一个名为 \"奥术护盾\" 的专属技能，它永久绑定在 mage 身上，并且消耗固定为 30 MP\nconst arcaneShieldSkill = castSpell.bind(mage, \"奥术护盾\", 30);\n\n// 现在，法师可以随时使用这个技能，无需再指定施法者和消耗\narcaneShieldSkill(); // 第一次施放\narcaneShieldSkill(); // 第二次施放\n\nconsole.log(\"\\n--- 战斗结束，查看最终状态 ---\");\nconsole.log(`${warrior.name}: HP ${warrior.hp}, MP ${warrior.mp}`);\nconsole.log(`${mage.name}: HP ${mage.hp}, MP ${mage.mp}`);", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-2-2-call-apply-bind.md", "blockIndex": 4}
{"id": "js-sec-3-2-3", "title": "箭头函数的this", "code": "// 在浏览器环境中，顶层`this`通常是`window`。在Node.js中是`{}`。\n// 为了在任何环境中都能清晰演示，我们创建一个对象。\n\nconst myCat = {\n  name: \"咪咪\",\n  sayHelloAfter: function(delay) {\n    // 1. 使用传统函数，`this`会丢失\n    setTimeout(function() {\n      // 在这里，`this` 不再指向 myCat，而是指向全局对象 (window) 或在严格模式下是 undefined\n      console.log(`[传统函数] 你好，我是 ${this.name}`); // 输出 \"你好，我是 undefined\" (或在非严格模式下的浏览器中是空)\n    }, delay);\n\n    // 2. 使用箭头函数，`this`被正确捕获\n    setTimeout(() => {\n      // 箭头函数从外部的 sayHelloAfter 方法继承了 `this`，所以 `this` 指向 myCat\n      console.log(`[箭头函数] 你好，我是 ${this.name}`); // 输出 \"你好，我是 咪咪\"\n    }, delay);\n  }\n};\n\nmyCat.sayHelloAfter(100);", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-2-3-箭头函数的this.md", "blockIndex": 0}
{"id": "js-sec-3-2-3", "title": "箭头函数的this", "code": "function Game() {\n  this.score = 0;\n  console.log(\"游戏开始，初始分数:\", this.score);\n\n  // 箭头函数作为 setInterval 的回调\n  // 它“继承”了 Game 构造函数中的 `this`\n  this.timer = setInterval(() => {\n    this.score++;\n    console.log(\"得分！当前分数:\", this.score);\n    if (this.score >= 3) {\n      clearInterval(this.timer);\n      console.log(\"游戏结束！最终分数:\", this.score);\n    }\n  }, 500);\n}\n\n// new Game(); // 取消注释即可在你的环境中运行此游戏模拟\n// 为了自动化测试和展示，我们手动模拟一下\nconst gameInstance = { score: 0 };\nconsole.log(\"游戏开始，初始分数:\", gameInstance.score);\n\nconst tick = () => {\n    // 箭头函数捕获了外部作用域的 gameInstance 作为 this\n    gameInstance.score++;\n    console.log(\"得分！当前分数:\", gameInstance.score);\n};\n\ntick();\ntick();\ntick();\nconsole.log(\"游戏结束！最终分数:\", gameInstance.score);\n", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-2-3-箭头函数的this.md", "blockIndex": 1}
{"id": "js-sec-3-2-3", "title": "箭头函数的this", "code": "const playerA = { name: \"玩家A\" };\nconst playerB = { name: \"玩家B\" };\n\nconst showName = () => {\n  // 这个箭头函数定义在全局作用域中\n  // 在浏览器中，全局的 this 是 window\n  // 在 Node.js 中，全局的 this 是一个空对象 {}\n  // 为了演示一致，我们假设它捕获了一个特定的上下文\n  const context = { name: \"游戏世界\" };\n  const arrowFunc = () => console.log(\"我的名字是:\", this.name);\n  \n  // 绑定上下文到箭头函数\n  const boundArrowFunc = arrowFunc.bind(context);\n  boundArrowFunc(); // 输出 \"我的名字是: undefined\" (因为它捕获的是定义时的全局this，而不是context)\n};\n\n// 让我们在一个对象内部定义箭头函数，看得更清楚\nconst character = {\n  name: \"勇者\",\n  // 箭头函数作为属性\n  arrowGetName: () => {\n    // 这里的 this 是在 character 对象定义时所在的全局作用域，而不是 character 本身\n    console.log(\"箭头函数 this.name:\", this.name); \n  }\n};\n\nconsole.log(\"尝试用 call 改变箭头函数的 this：\");\n// 即使使用 .call(playerA)，也无法改变箭头函数的 this\ncharacter.arrowGetName.call(playerA); // 期望输出 \"玩家A\"，但实际输出 undefined (或全局 name)\n\nconsole.log(\"结论：箭头函数的 this 是铁打的，无法被 call、apply、bind 改变。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-2-3-箭头函数的this.md", "blockIndex": 2}
{"id": "js-sec-3-2-3", "title": "箭头函数的this", "code": "console.log(\"=== 错误用法 ===\");\n// ❌ 错误：将箭头函数用作对象的方法\nconst counterWrong = {\n  count: 0,\n  increment: () => {\n    // 陷阱！这里的 `this` 指向的是定义 counterWrong 对象时的全局作用域\n    // 而不是 counterWrong 对象本身。\n    this.count++; \n    console.log(\"❌ 当前计数值:\", this.count); // 在浏览器中会输出 NaN，因为 window.count 是 undefined\n  }\n};\n\ncounterWrong.increment();\ncounterWrong.increment();\n// 结果可能不是你想要的，它修改的是全局的 count (如果存在)\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确：使用传统函数作为方法，在方法内部需要保留 this 时使用箭头函数\nconst counterCorrect = {\n  count: 0,\n  increment: function() {\n    // 这里的 `this` 正确地指向 counterCorrect 对象\n    console.log(\"✅ 方法执行，当前 this.count:\", this.count);\n    \n    // 假设我们有一个需要延迟执行的操作\n    setTimeout(() => {\n      // 箭头函数继承了外层 increment 方法的 `this`\n      this.count++;\n      console.log(\"✅ 1秒后，计数值增加为:\", this.count);\n    }, 1000);\n  }\n};\n\n// counterCorrect.increment(); // 取消注释以查看1秒后的效果\n// 为了在非异步环境中直接展示结果，我们模拟一下\ncounterCorrect.count = 10;\ncounterCorrect.increment = function() {\n    const innerArrowFunc = () => {\n        this.count++;\n        console.log(\"✅ 内部箭头函数执行后，计数值为:\", this.count);\n    };\n    innerArrowFunc();\n};\ncounterCorrect.increment(); // 输出 11\n", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-2-3-箭头函数的this.md", "blockIndex": 3}
{"id": "js-sec-3-2-3", "title": "箭头函数的this", "code": "// 🎮 角色升级系统\nconst hero = {\n  name: \"闪电侠\",\n  level: 1,\n  hp: 100,\n  exp: 0,\n\n  // 获得经验的方法\n  gainExp: function(amount) {\n    this.exp += amount;\n    console.log(`💥 ${this.name} 获得了 ${amount} 点经验，当前经验: ${this.exp}`);\n\n    if (this.exp >= 100) {\n      this.levelUp();\n    }\n  },\n\n  // 升级方法\n  levelUp: function() {\n    console.log(\"✨ 经验值已满，准备升级！\");\n    this.exp -= 100; // 消耗升级所需的经验\n\n    // 模拟一个 1.5 秒的升级动画\n    setTimeout(() => {\n      // 关键时刻！箭头函数确保了 `this` 依然是我们的英雄 `hero`\n      this.level++;\n      this.hp += 50; // 升级奖励：生命值上限增加\n\n      console.log(\"===============================\");\n      console.log(\"🌟🎉 等级提升！ 🎉🌟\");\n      console.log(`  ${this.name}`);\n      console.log(`  等级: ${this.level}`);\n      console.log(`  生命值: ${this.hp}`);\n      console.log(`  剩余经验: ${this.exp}`);\n      console.log(\"===============================\");\n      console.log(\"我又变强了！💪\");\n    }, 1500);\n  }\n};\n\n// --- 游戏开始 ---\nconsole.log(`英雄 ${hero.name} 开始了他的冒险！`);\nhero.gainExp(50);\nhero.gainExp(60); // 这次调用将触发升级\n\n// 注意：由于 setTimeout 是异步的，后续代码会先执行。\n// 在实际环境中，升级信息将在1.5秒后出现。", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-2-3-箭头函数的this.md", "blockIndex": 4}
{"id": "js-sec-3-2-4", "title": "常见this陷阱", "code": "'use strict'; // 使用严格模式，这是现代JS开发的标准\n\nconst player = {\n  name: 'Wizard',\n  castSpell: function() {\n    console.log(`${this.name} casts a spell!`);\n  }\n};\n\n// 直接调用，this指向player，一切正常\nplayer.castSpell();\n\n// 陷阱出现：将方法赋值给一个变量\nconst cast = player.castSpell;\n\n// 通过新变量调用，this不再是player\n// 在严格模式下，this是undefined，会报错\ntry {\n  cast(); \n} catch (e) {\n  console.error(\"💥 Oops! Error:\", e.message);\n  console.log(\"因为 'this' 现在是 undefined, 所以 this.name 会抛出错误。\");\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-2-4-常见this陷阱.md", "blockIndex": 0}
{"id": "js-sec-3-2-4", "title": "常见this陷阱", "code": "'use strict';\n\nconst cat = {\n  name: 'Whiskers',\n  meowLater: function() {\n    // this.name 在这里期望是 'Whiskers'\n    console.log(`A cat named ${this.name} will meow in 1 second...`);\n    \n    // 将 this.meow 作为回调函数传递\n    // setTimeout 调用它时，是在全局上下文中，而不是 cat 的上下文中\n    setTimeout(function() {\n      // 此时的 this 是 Timeout 对象（在Node.js中）或 window/undefined（在浏览器中）\n      // 它没有 .name 属性\n      try {\n        console.log(`Meow from ${this.name}!`);\n      } catch (e) {\n        console.error('🙀 Meow failed!', e.message);\n        console.log('这里的 this 不是我们的猫咪对象了！');\n      }\n    }, 100);\n  }\n};\n\ncat.meowLater();", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-2-4-常见this陷阱.md", "blockIndex": 1}
{"id": "js-sec-3-2-4", "title": "常见this陷阱", "code": "'use strict';\n\nconst robot = {\n  name: 'Bender',\n  // 错误：使用箭头函数作为方法\n  // 这个箭头函数在 robot 对象被创建时定义\n  // 它捕获了外部作用域的 this，在这里是 undefined (严格模式)\n  sayName: () => {\n    try {\n      console.log(`My name is ${this.name}.`);\n    } catch(e) {\n      console.error(`Error: ${e.message}`);\n      console.log(\"🤖 箭头函数方法无法访问到 'Bender'，因为它的 'this' 指向了别处。\");\n    }\n  },\n  \n  // 正确：使用传统函数表达式\n  sayNameCorrectly: function() {\n    console.log(`My name is ${this.name}. This works!`);\n  }\n};\n\nrobot.sayName();\nrobot.sayNameCorrectly();", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-2-4-常见this陷阱.md", "blockIndex": 2}
{"id": "js-sec-3-2-4", "title": "常见this陷阱", "code": "'use strict';\n\nconst timer = {\n  seconds: 0,\n  message: \"Time's up!\",\n  start: function() {\n    // setInterval会以全局上下文调用其回调\n    // 如果不处理，this.seconds会是undefined\n    const callback = function() {\n      // this 在这里不是 timer 对象\n      this.seconds++; // this 是 Timeout/Window/undefined\n      console.log(this.seconds);\n      if (this.seconds > 1) {\n        console.log(this.message); // 永远不会执行，因为 this.seconds 是 NaN\n      }\n    };\n    \n    // 使用 .bind(this) 创建一个新函数，并将它的 this 永久绑定到 timer 对象\n    const boundCallback = function() {\n      this.seconds++;\n      console.log(`${this.seconds} second(s) passed...`);\n      if (this.seconds >= 2) {\n        console.log(`🔔 ${this.message}`);\n        // 为了让示例停止，我们需要清除定时器\n        clearInterval(timerId); \n      }\n    }.bind(this);\n    \n    let timerId;\n\n    console.log(\"=== 错误用法 ❌ ===\");\n    // 这里我们只运行一次来演示错误\n    try {\n        callback();\n    } catch (e) {\n        console.error(\"直接调用回调会失败: \", e.message);\n    }\n\n\n    console.log(\"\\n=== 正确用法 ✅ (使用 .bind) ===\");\n    console.log(\"Timer starting...\");\n    // 我们需要一个变量来存储定时器ID以便清除它\n    timerId = setInterval(boundCallback, 500);\n  }\n};\n\n// 为了在自动运行环境中演示，我们只让它运行一小段时间\n// 在实际应用中，你可能不会这么做\nsetTimeout(() => {\n  timer.start();\n}, 10);\n\n// 注意：这个示例会启动一个定时器。在交互式环境中，你会在几秒钟后看到输出。\n// 在Node.js或浏览器控制台中运行以查看完整效果。", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-2-4-常见this陷阱.md", "blockIndex": 3}
{"id": "js-sec-3-2-4", "title": "常见this陷阱", "code": "'use strict';\n\n// 史莱姆角色生成器\nfunction createSlime(name) {\n  return {\n    name: name,\n    health: 100,\n    \n    // 受到攻击的方法\n    takeDamage: function(amount) {\n      this.health -= amount;\n      console.log(`💥 Ouch! ${this.name} took ${amount} damage. Health is now ${this.health}.`);\n      if (this.health <= 0) {\n        console.log(`☠️ ${this.name} has dissolved into a puddle...`);\n      }\n    },\n\n    // 一个会触发this陷阱的技能\n    startMeltingWrong: function() {\n      console.log(`💧 ${this.name} starts melting... (the WRONG way)`);\n      // 错误示范：直接传递 this.takeDamage\n      // 当 setTimeout 调用它时，'this' 将不再是史莱姆对象\n      setTimeout(this.takeDamage, 1000, 10); // 第三个参数10会传给takeDamage\n    },\n    \n    // 正确的技能实现\n    startMeltingCorrect: function() {\n      console.log(`💧 ${this.name} starts melting... (the CORRECT way)`);\n      \n      // 解决方案：使用箭头函数包裹，箭头函数会从 startMeltingCorrect 捕获正确的 'this'\n      const meltTick = () => {\n        // 这里的 'this' 就是我们期望的史莱姆对象\n        this.takeDamage(15);\n        if(this.health > 0) {\n            console.log(\"Gloop... gloop...\");\n        }\n      };\n      \n      setTimeout(meltTick, 1000);\n    }\n  };\n}\n\nconst slimey = createSlime('Slimey');\nconsole.log(`A wild Slimey appears! Health: ${slimey.health}`);\n\nconsole.log(\"\\n--- 演示错误用法 ---\");\n// 运行这个函数，你会看到 health 变成 NaN，因为 this.health 是 undefined - 10\nslimey.startMeltingWrong();\n\n\n// 为了让错误演示的结果先出现，我们稍等一下再运行正确的\nsetTimeout(() => {\n  console.log(\"\\n--- 演示正确用法 ---\");\n  const goopy = createSlime('Goopy');\n  console.log(`A new challenger, Goopy, appears! Health: ${goopy.health}`);\n  goopy.startMeltingCorrect();\n}, 1500);", "lang": "javascript", "source": "web-learner/public/content/js-sec-3-2-4-常见this陷阱.md", "blockIndex": 4}
{"id": "js-sec-4-1-1", "title": "构造函数", "code": "// 定义一个玩家构造函数 (蓝图)\n// 按照惯例，构造函数名首字母大写\nfunction Player(name, level) {\n  this.name = name;\n  this.level = level;\n}\n\n// 使用 new 关键字，根据蓝图创建一个具体的玩家对象\nconst player1 = new Player('勇者爱丽丝', 99);\n\n// 查看我们创建的玩家\nconsole.log('新玩家已创建:', player1);\nconsole.log(`玩家名称: ${player1.name}`);\nconsole.log(`玩家等级: ${player1.level}`);", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-1-1-构造函数.md", "blockIndex": 0}
{"id": "js-sec-4-1-1", "title": "构造函数", "code": "function Monster(name, hp) {\n  console.log(`(1) 一个新的怪兽对象正在创建... this 指向它`);\n  this.name = name;\n  this.hp = hp;\n  // (2) 由于没有 return 语句，函数会自动返回 this\n  console.log(`(3) 怪兽 ${this.name} 创建完毕!`);\n}\n\n// 使用 new 调用构造函数\nconsole.log('--- 开始召唤怪兽 ---');\nconst slime = new Monster('史莱姆', 50);\n\n// slime 就是构造函数返回的新对象\nconsole.log('--- 召唤成功 ---');\nconsole.log('召唤出的怪兽:', slime);\nconsole.log(`它的名字是 ${slime.name}，生命值是 ${slime.hp}`);", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-1-1-构造函数.md", "blockIndex": 1}
{"id": "js-sec-4-1-1", "title": "构造函数", "code": "function Robot(model) {\n  // 每个机器人实例独有的属性\n  this.model = model;\n  this.energy = 100;\n}\n\n// 将共享的方法定义在原型上\n// 所有 Robot 实例都能访问这个 sayHello 方法，但它只在内存中存在一份\nRobot.prototype.sayHello = function() {\n  console.log(`你好，我是 ${this.model} 型号机器人。`);\n};\n\nconst robotA = new Robot('T-800');\nconst robotB = new Robot('R2-D2');\n\nrobotA.sayHello();\nrobotB.sayHello();\n\n// 验证两个实例是否共享同一个方法\nconsole.log('两个机器人是否共享同一个 sayHello 方法?', robotA.sayHello === robotB.sayHello); // 输出 true", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-1-1-构造函数.md", "blockIndex": 2}
{"id": "js-sec-4-1-1", "title": "构造函数", "code": "function Spell(name, type) {\n  this.name = name;\n  this.type = type;\n  console.log(`'this' 在函数内部指向:`, this);\n}\n\nconsole.log(\"=== ❌ 错误用法: 忘记使用 new ===\");\n// 如果不使用 new，Spell 就像一个普通函数被调用\n// 在非严格模式下，'this' 会指向全局对象 (在浏览器中是 window)\n// 这会污染全局作用域！\nconst fireball = Spell('火球术', '火焰');\nconsole.log('fireball 的值:', fireball); // undefined, 因为函数没有显式 return\n// 尝试访问全局变量，你会发现它们被意外创建了\n// 在浏览器环境中取消下面一行的注释会看到结果\n// console.log('全局变量 name:', window.name); // '火球术'\n\n\nconsole.log(\"\\n=== ✅ 正确用法: 使用 new 关键字 ===\");\n// 使用 new 会创建一个新的对象，并将 'this' 指向它\nconst iceBlast = new Spell('寒冰箭', '冰霜');\nconsole.log('iceBlast 的值:', iceBlast);\nconsole.log(`创建的法术是: ${iceBlast.name}，属于 ${iceBlast.type} 系。`);", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-1-1-构造函数.md", "blockIndex": 3}
{"id": "js-sec-4-1-1", "title": "构造函数", "code": "// 赛博宠物构造函数\nfunction CyberPet(name, type) {\n  this.name = name;\n  this.type = type; // 例如: '电子狗', '像素猫'\n  this.energy = 100; // 能量值\n  this.happiness = 100; // 快乐值\n\n  console.log(`✨ 哇！一只叫做 ${this.name} 的 ${this.type} 诞生了！`);\n}\n\n// 在原型上添加互动方法\nCyberPet.prototype.play = function() {\n  if (this.energy >= 20) {\n    this.energy -= 20;\n    this.happiness += 15;\n    console.log(`🎾 你和 ${this.name} 玩了激光笔，它的快乐值上升了！`);\n  } else {\n    console.log(`💤 ${this.name} 太累了，不想玩...`);\n  }\n  this.checkStatus();\n};\n\nCyberPet.prototype.feed = function() {\n  this.energy += 30;\n  this.happiness += 5;\n  console.log(`🍖 你喂了 ${this.name} 一块能量方块，它的能量恢复了！`);\n  this.checkStatus();\n};\n\nCyberPet.prototype.checkStatus = function() {\n  console.log(\n    `--- ${this.name} 的状态 --- 能量: ${this.energy}, 快乐: ${this.happiness} ---`\n  );\n};\n\n// --- 开始游戏 ---\n// 领养一只宠物\nconst myPet = new CyberPet('比特', '电子狗');\nmyPet.checkStatus();\n\n// 和它互动\nconsole.log('\\n--- 一天过去了 ---');\nmyPet.play();\nmyPet.play();\nmyPet.feed();\nmyPet.play();\nmyPet.play();\nmyPet.play(); // 能量不足", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-1-1-构造函数.md", "blockIndex": 4}
{"id": "js-sec-4-1-2", "title": "prototype原型", "code": "// 1. 创建一个“小狗”构造函数（模具）\nfunction Dog(name) {\n  this.name = name;\n}\n\n// 2. 在“小狗”模具的原型上添加一个共享的“叫”方法\nDog.prototype.bark = function() {\n  console.log(`汪汪！我是 ${this.name}！`);\n};\n\n// 3. 使用模具创建两只具体的小狗实例\nconst dog1 = new Dog('旺财');\nconst dog2 = new Dog('小黑');\n\n// 4. 两只小狗都可以使用原型上的方法\ndog1.bark(); // 输出: 汪汪！我是 旺财！\ndog2.bark(); // 输出: 汪汪！我是 小黑！\n\n// 验证一下：它们共享的是同一个函数吗？\nconsole.log(dog1.bark === dog2.bark); // 输出: true", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-1-2-prototype原型.md", "blockIndex": 0}
{"id": "js-sec-4-1-2", "title": "prototype原型", "code": "function Cat(name) {\n  this.name = name;\n}\n\n// 在原型上添加 \"meow\" 方法\nCat.prototype.meow = function() {\n  console.log(`${this.name}: 喵~`);\n};\n\nconst kitty = new Cat('咪咪');\nconst garfield = new Cat('加菲');\n\nconsole.log(\"--- 修改原型前 ---\");\nkitty.meow(); // 输出: 咪咪: 喵~\n\n// 突然，我们想让所有猫咪学会“抓老鼠”的技能\nconsole.log(\"\\n--- 在原型上添加新方法后 ---\");\nCat.prototype.catchMouse = function() {\n  console.log(`${this.name} 正在英勇地抓老鼠！`);\n};\n\n// 即使是之前创建的实例，也马上拥有了新技能\nkitty.catchMouse();    // 输出: 咪咪 正在英勇地抓老鼠！\ngarfield.catchMouse(); // 输出: 加菲 正在英勇地抓老鼠！\n\n// 我们还可以修改已有的方法\nconsole.log(\"\\n--- 修改原型上已有的方法后 ---\");\nCat.prototype.meow = function() {\n    console.log(`${this.name}: 喵喵喵~ （升级版叫声）`);\n};\nkitty.meow(); // 输出: 咪咪: 喵喵喵~ （升级版叫声）", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-1-2-prototype原型.md", "blockIndex": 1}
{"id": "js-sec-4-1-2", "title": "prototype原型", "code": "function Animal(species) {\n    this.species = species;\n}\n\n// 所有动物都会呼吸\nAnimal.prototype.breathe = function() {\n    console.log(\"呼...吸...我能呼吸！\");\n};\n\nfunction Dog(name) {\n    this.name = name;\n}\n\n// 让 Dog 的原型指向一个 Animal 的实例，形成原型链\n// Dog.prototype -> Animal 实例 -> Animal.prototype -> Object.prototype -> null\nDog.prototype = new Animal('犬科');\n\n// 狗会叫\nDog.prototype.bark = function() {\n    console.log(\"汪汪！\");\n};\n\nconst myDog = new Dog('豆豆');\n\n// 1. 在 myDog 实例自身上查找 .bark() -> 找不到\n// 2. 沿着原型链在 Dog.prototype 上查找 -> 找到了！\nmyDog.bark(); // 输出: 汪汪！\n\n// 1. 在 myDog 实例自身上查找 .breathe() -> 找不到\n// 2. 在 Dog.prototype 上查找 -> 找不到\n// 3. 在 Dog.prototype 的原型（Animal 实例）上查找 -> 找不到\n// 4. 在 Animal 实例的原型（Animal.prototype）上查找 -> 找到了！\nmyDog.breathe(); // 输出: 呼...吸...我能呼吸！\n\n// .toString() 是 Object.prototype 上的方法，位于原型链的更上层\nconsole.log(myDog.toString()); // 输出: [object Object]", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-1-2-prototype原型.md", "blockIndex": 2}
{"id": "js-sec-4-1-2", "title": "prototype原型", "code": "// === 错误用法 ===\n// 每次创建实例，都会在内存中创建一个新的 meow 函数\nfunction BadCat(name) {\n  this.name = name;\n  this.meow = function() {\n    console.log(`(浪费内存的叫声) 我是 ${this.name}`);\n  };\n}\n\nconsole.log(\"=== 错误用法 ===\");\nconst cat1 = new BadCat('花花');\nconst cat2 = new BadCat('白白');\n\ncat1.meow();\ncat2.meow();\n\n// 验证：每个实例都有自己独立的 meow 函数副本\nconsole.log('cat1.meow 和 cat2.meow 是同一个函数吗?', cat1.meow === cat2.meow);\n// ❌ 输出: false。这意味着创建100只猫，就会有100个 meow 函数副本，造成内存浪费。\n\n\n// === 正确用法 ===\n// 所有实例共享原型上的同一个 meow 函数\nfunction GoodCat(name) {\n  this.name = name;\n}\n\nGoodCat.prototype.meow = function() {\n  console.log(`(高效的叫声) 我是 ${this.name}`);\n};\n\nconsole.log(\"\\n=== 正确用法 ===\");\nconst cat3 = new GoodCat('小橘');\nconst cat4 = new GoodCat('大橘');\n\ncat3.meow();\ncat4.meow();\n\n// 验证：所有实例共享同一个函数\nconsole.log('cat3.meow 和 cat4.meow 是同一个函数吗?', cat3.meow === cat4.meow);\n// ✅ 输出: true。创建100只猫，内存中也只有一个 meow 函数，非常高效。", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-1-2-prototype原型.md", "blockIndex": 3}
{"id": "js-sec-4-1-2", "title": "prototype原型", "code": "// 怪物构造函数（蓝图）\nfunction Monster(name, level, weapon) {\n  this.name = name;\n  this.level = level;\n  this.hp = level * 100;\n  this.weapon = weapon;\n  console.log(`一只 ${level} 级的 ${name} 带着 ${weapon} 出现了！`);\n}\n\n// 在怪物原型上添加共享的“攻击”能力\nMonster.prototype.attack = function() {\n  console.log(`💥 ${this.name} 使用 ${this.weapon} 发动了攻击！造成 ${this.level * 5} 点伤害！`);\n};\n\n// 在怪物原型上添加共享的“展示状态”能力\nMonster.prototype.showStatus = function() {\n  console.log(`--- [${this.name}] 状态 ---`);\n  console.log(`  等级: ${this.level}`);\n  console.log(`  生命: ${this.hp}`);\n  console.log(`  武器: ${this.weapon}`);\n  console.log(`------------------------`);\n};\n\n// 在怪物原型上添加共享的“升级”能力\nMonster.prototype.levelUp = function() {\n  this.level++;\n  this.hp += 100;\n  console.log(`🎉 哇！${this.name} 升级到了 ${this.level} 级！生命值增加！`);\n};\n\n\n// --- 游戏开始！创建怪物军团 ---\nconsole.log(\"--- 军团集结 ---\");\nconst slime = new Monster('史莱姆', 1, '黏液');\nconst goblin = new Monster('哥布林', 3, '生锈的匕首');\n\n// --- 展示怪物信息 ---\nconsole.log(\"\\n--- 查看初始状态 ---\");\nslime.showStatus();\ngoblin.showStatus();\n\n// --- 怪物行动 ---\nconsole.log(\"\\n--- 战斗回合 ---\");\nslime.attack();\ngoblin.attack();\n\n// --- 史莱姆获得了经验，升级了！ ---\nconsole.log(\"\\n--- 怪物成长 ---\");\nslime.levelUp();\nslime.showStatus(); // 查看升级后的状态\n\n// 即使史莱姆升级了，它使用的 attack 方法仍然是原型上共享的那个\nslime.attack(); // 伤害变高了，因为伤害计算依赖于实例的 level 属性", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-1-2-prototype原型.md", "blockIndex": 4}
{"id": "js-sec-4-1-3", "title": "原型链", "code": "// 定义一个构造函数，它有一个原型方法\nfunction Dog(name) {\n  this.name = name;\n}\n\n// 在Dog的原型上添加一个方法\nDog.prototype.bark = function() {\n  return \"Woof woof!\";\n};\n\n// 创建一个Dog实例\nconst myDog = new Dog(\"Buddy\");\n\n// myDog本身没有bark方法，但它能通过原型链找到并使用它\nconsole.log(`小狗 ${myDog.name} 在叫: ${myDog.bark()}`);\nconsole.log(\"myDog自身有'bark'方法吗?\", myDog.hasOwnProperty('bark')); // false\nconsole.log(\"myDog的原型有'bark'方法吗?\", Dog.prototype.hasOwnProperty('bark')); // true", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-1-3-原型链.md", "blockIndex": 0}
{"id": "js-sec-4-1-3", "title": "原型链", "code": "// 祖先：生物\nfunction Creature() {\n  this.isAlive = true;\n}\nCreature.prototype.breathe = function() {\n  return \"Breathing...\";\n};\n\n// 父类：动物\nfunction Animal() {\n  this.hasLegs = true;\n}\n// 将Animal的原型链接到Creature\nAnimal.prototype = Object.create(Creature.prototype);\n\n// 子类：猫\nfunction Cat(name) {\n  this.name = name;\n}\n// 将Cat的原型链接到Animal\nCat.prototype = Object.create(Animal.prototype);\nCat.prototype.meow = function() {\n  return \"Meow!\";\n};\n\nconst myCat = new Cat(\"Mimi\");\n\n// 访问自己的属性\nconsole.log(`我的猫叫: ${myCat.name}`);\n// 访问原型链上的方法 (Cat.prototype)\nconsole.log(`它在叫: ${myCat.meow()}`);\n// 访问原型链上更远的方法 (Creature.prototype)\nconsole.log(`它在呼吸吗? ${myCat.breathe()}`);\n// 访问原型链上的属性 (Creature.prototype -> Creature instance)\nconsole.log(`它还活着吗? ${myCat.isAlive}`); // isAlive 在 Creature 的实例上，但这里我们通过原型链访问到了", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-1-3-原型链.md", "blockIndex": 1}
{"id": "js-sec-4-1-3", "title": "原型链", "code": "function Hero(name) {\n  this.name = name;\n}\n\n// 英雄原型上有一个通用的攻击方法\nHero.prototype.attack = function() {\n  return `${this.name} 使用了普通攻击!`;\n};\n\n// 创建一个普通英雄\nconst genericHero = new Hero(\"路人甲\");\nconsole.log(genericHero.attack()); // 输出: 路人甲 使用了普通攻击!\n\n// 创建一个特殊的英雄，并给他一个自己的、更强的攻击方法\nconst superHero = new Hero(\"超人\");\nsuperHero.attack = function() {\n  return `${this.name} 使用了【激光眼】! 伤害+999!`;\n};\n\n// superHero的attack方法“屏蔽”了原型上的attack方法\nconsole.log(superHero.attack()); // 输出: 超人 使用了【激光眼】! 伤害+999!\n\n// 删除实例上的方法后，原型上的方法又可见了\ndelete superHero.attack;\nconsole.log(superHero.attack()); // 输出: 超人 使用了普通攻击!", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-1-3-原型链.md", "blockIndex": 2}
{"id": "js-sec-4-1-3", "title": "原型链", "code": "console.log(\"=== 错误用法 ===\");\n// ❌ 错误：直接给 Object.prototype 添加方法\n// 这会导致所有对象（包括数组、普通对象等）都拥有这个方法，可能与库或代码中的其他部分冲突。\nObject.prototype.sayHi = function() {\n  console.log(\"Hi from global prototype!\");\n};\n\nconst myObject = {};\nmyObject.sayHi(); // 输出: Hi from global prototype!\n\nconst myArray = [];\nmyArray.sayHi(); // 数组也受到了污染! 输出: Hi from global prototype!\n\n// 更糟糕的是，它会干扰 for...in 循环\nfor (let key in myObject) {\n  console.log(`发现属性: ${key}`); // 输出: 发现属性: sayHi，这不是我们想要的！\n}\n// 清理污染，以免影响后续示例\ndelete Object.prototype.sayHi;\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确：通过创建自定义构造函数或类来扩展功能\nfunction Greeter(greeting) {\n    this.greeting = greeting;\n}\n\nGreeter.prototype.sayHi = function() {\n    console.log(`${this.greeting}, I am a proper instance!`);\n};\n\nconst myGreeter = new Greeter(\"Hello\");\nmyGreeter.sayHi(); // 输出: Hello, I am a proper instance!\n\nconst anotherObject = {};\n// anotherObject.sayHi(); // 抛出错误: anotherObject.sayHi is not a function，因为它没有被污染\nconsole.log(\"anotherObject 有 sayHi 方法吗?\", typeof anotherObject.sayHi === 'function'); // false", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-1-3-原型链.md", "blockIndex": 3}
{"id": "js-sec-4-1-3", "title": "原型链", "code": "// Level 1: 基础怪兽 - 史莱姆\nfunction Slime(name, hp) {\n  this.name = name;\n  this.hp = hp;\n}\n\nSlime.prototype.attack = function() {\n  console.log(`💧 ${this.name} 发起了【撞击】，造成 5 点伤害!`);\n};\n\nSlime.prototype.showStatus = function() {\n  console.log(`[${this.name}] HP: ${this.hp}`);\n};\n\n// Level 2: 进化 - 火焰史莱姆\nfunction FireSlime(name, hp) {\n  // 调用父类的构造函数，继承基础属性\n  Slime.call(this, name, hp);\n  this.element = \"火\";\n}\n\n// 关键一步：建立原型链，让 FireSlime 继承 Slime 的方法\nFireSlime.prototype = Object.create(Slime.prototype);\nFireSlime.prototype.constructor = FireSlime; // 修复构造函数指向\n\n// \"属性屏蔽\": 覆盖父类的 attack 方法，使其更强大\nFireSlime.prototype.attack = function() {\n  console.log(`🔥 ${this.name} 喷射【火焰弹】，造成 15 点伤害!`);\n};\n\n// Level 3: 终极进化 - 熔岩史莱姆王\nfunction MagmaSlimeKing(name, hp) {\n  FireSlime.call(this, name, hp);\n  this.title = \"王\";\n}\n\nMagmaSlimeKing.prototype = Object.create(FireSlime.prototype);\nMagmaSlimeKing.prototype.constructor = MagmaSlimeKing;\n\n// 新增终极技能\nMagmaSlimeKing.prototype.ultimateAttack = function() {\n  console.log(`🌋👑 ${this.name} ${this.title} 释放了【末日熔岩】，全屏燃烧，造成 99 点伤害!`);\n};\n\n\n// --- 开始我们的冒险！---\nconsole.log(\"一只弱小的史莱姆出现了...\");\nconst basicSlime = new Slime(\"噗噗\", 50);\nbasicSlime.showStatus();\nbasicSlime.attack();\n\nconsole.log(\"\\n史莱姆沐浴在火焰中进化了！\");\nconst fireSlime = new FireSlime(\"燃燃\", 120);\nfireSlime.showStatus(); // 继承自Slime\nfireSlime.attack();     // 使用自己的attack方法\n\nconsole.log(\"\\n最终，它成为了熔岩之王！\");\nconst king = new MagmaSlimeKing(\"暴君\", 500);\nking.showStatus();      // 继承自Slime\nking.attack();          // 继承自FireSlime\nking.ultimateAttack();  // 使用自己的终极技能", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-1-3-原型链.md", "blockIndex": 4}
{"id": "js-sec-4-1-4", "title": "instanceof原理", "code": "// 定义一个简单的“宠物”类\nclass Pet {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n// 创建一个 Pet 的实例（一只名叫“旺财”的宠物）\nconst myPet = new Pet('旺财');\n\n// 使用 instanceof 进行鉴定\nconst isPet = myPet instanceof Pet;\n\nconsole.log(`“旺财”是 Pet 类的实例吗? ->`, isPet); // 输出: true\n\n// 定义一个完全不相关的“汽车”类\nclass Car {}\nconst myCar = new Car();\n\nconst isPetAlsoACar = myPet instanceof Car;\nconsole.log(`“旺财”是 Car 类的实例吗? ->`, isPetAlsoACar); // 输出: false", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-1-4-instanceof原理.md", "blockIndex": 0}
{"id": "js-sec-4-1-4", "title": "instanceof原理", "code": "// 定义一个基础的“动物”类\nclass Animal {\n  speak() {\n    console.log('动物发出声音...');\n  }\n}\n\n// 定义一个“狗”类，它继承自“动物”\nclass Dog extends Animal {\n  speak() {\n    console.log('汪汪汪!');\n  }\n}\n\n// 创建一个 Dog 的实例\nconst dog = new Dog();\n\n// dog 是 Dog 的实例吗？是的，它是直接实例。\nconsole.log('这只狗是 Dog 的实例吗?', dog instanceof Dog); // -> true\n\n// dog 是 Animal 的实例吗？是的，因为 Dog 继承了 Animal。\nconsole.log('这只狗是 Animal 的实例吗?', dog instanceof Animal); // -> true\n\n// dog 是 Object 的实例吗？是的，因为所有对象的原型链最终都指向 Object。\nconsole.log('这只狗是 Object 的实例吗?', dog instanceof Object); // -> true", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-1-4-instanceof原理.md", "blockIndex": 1}
{"id": "js-sec-4-1-4", "title": "instanceof原理", "code": "// 定义一些原始数据类型\nconst greeting = \"Hello, world!\";\nconst luckyNumber = 7;\nconst isReady = true;\n\n// 尝试对原始类型使用 instanceof\nconsole.log('字符串 \"Hello, world!\" 是 String 的实例吗?', greeting instanceof String); // -> false\nconsole.log('数字 7 是 Number 的实例吗?', luckyNumber instanceof Number); // -> false\nconsole.log('布尔值 true 是 Boolean 的实例吗?', isReady instanceof Boolean); // -> false\n\n// 特殊情况：使用构造函数创建的包装对象\nconst greetingObject = new String(\"Hello, object!\");\nconsole.log('new String(\"...\") 是 String 的实例吗?', greetingObject instanceof String); // -> true\n// 注意：这是一种不推荐的做法，通常我们直接使用原始类型。", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-1-4-instanceof原理.md", "blockIndex": 2}
{"id": "js-sec-4-1-4", "title": "instanceof原理", "code": "// 准备一个对象和一个原始类型\nclass Player {}\nconst player1 = new Player();\nconst playerName = \"Alice\";\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 尝试用 instanceof 判断字符串类型\nconst isString = playerName instanceof String;\nconsole.log(`用 instanceof 判断 \"Alice\" 是不是 String:`, isString);\n// 解释：这是错误的，因为 instanceof 对原始类型字符串返回 false。\n\nconsole.log(\"=== 正确用法 ===\");\n// ✅ 使用 typeof 判断原始类型\nconst typeOfString = typeof playerName;\nconsole.log(`用 typeof 判断 \"Alice\" 的类型:`, typeOfString);\n// 解释：typeof 能准确返回原始类型的字符串表示，如 \"string\", \"number\"。\n\n// ✅ 使用 instanceof 判断对象类型\nconst isPlayer = player1 instanceof Player;\nconsole.log(`用 instanceof 判断 player1 是不是 Player:`, isPlayer);\n// 解释：instanceof 专为对象设计，用于检查其构造函数和原型链。", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-1-4-instanceof原理.md", "blockIndex": 3}
{"id": "js-sec-4-1-4", "title": "instanceof原理", "code": "// 基础角色类\nclass Character {\n  constructor(name, health) {\n    this.name = name;\n    this.health = health;\n  }\n}\n\n// 法师类，继承自角色\nclass Mage extends Character {\n  constructor(name, health, mana) {\n    super(name, health);\n    this.mana = mana;\n  }\n  castFireball() {\n    return `🔥 ${this.name} 念动咒语，发射了一颗巨大的火球！`;\n  }\n}\n\n// 战士类，继承自角色\nclass Warrior extends Character {\n  constructor(name, health, rage) {\n    super(name, health);\n    this.rage = rage;\n  }\n  charge() {\n    return `⚔️ ${this.name} 发出怒吼，像猛虎一样冲向敌人！`;\n  }\n}\n\n// 创建不同职业的角色\nconst gandalf = new Mage('甘道夫', 100, 150);\nconst aragorn = new Warrior('阿拉贡', 150, 100);\nconst frodo = new Character('佛罗多', 50); // 一个没有特定职业的角色\n\n// 这是一个通用的技能释放函数，它会根据角色类型决定做什么\nfunction activateSpecialAbility(character) {\n  console.log(`\\n--- ${character.name} 的回合 ---`);\n  if (character instanceof Mage) {\n    // 如果是法师，就施放火球术\n    console.log(character.castFireball());\n  } else if (character instanceof Warrior) {\n    // 如果是战士，就发动冲锋\n    console.log(character.charge());\n  } else if (character instanceof Character) {\n    // 如果只是个普通角色\n    console.log(`🤔 ${character.name} 看了看自己的双手，不知道该做什么特殊技能...`);\n  } else {\n    console.log('😱 这不是一个有效的角色！');\n  }\n}\n\n// 让我们看看不同角色释放技能的效果\nactivateSpecialAbility(gandalf);\nactivateSpecialAbility(aragorn);\nactivateSpecialAbility(frodo);", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-1-4-instanceof原理.md", "blockIndex": 4}
{"id": "js-sec-4-2-1", "title": "class声明", "code": "// 定义一个“宠物猫”的蓝图 (class)\nclass PetCat {\n  // 构造函数，当使用 new 创建实例时被调用\n  constructor(name, color) {\n    this.name = name;\n    this.color = color;\n  }\n\n  // 一个方法，所有 PetCat 实例都会有这个方法\n  meow() {\n    console.log(`我是${this.color}的猫咪，我叫${this.name}，喵~`);\n  }\n}\n\n// 使用 class 蓝图创建一个具体的猫咪实例\nconst garfield = new PetCat('加菲', '橘色');\nconst tom = new PetCat('汤姆', '蓝灰色');\n\n// 调用实例的方法\ngarfield.meow();\ntom.meow();", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-1-class声明.md", "blockIndex": 0}
{"id": "js-sec-4-2-1", "title": "class声明", "code": "// 父类：定义所有动物的通用特性\nclass Animal {\n  constructor(name) {\n    this.name = name;\n    this.speed = 0;\n  }\n\n  run(speed) {\n    this.speed = speed;\n    console.log(`${this.name} 正在以每小时 ${this.speed} 公里的速度奔跑！`);\n  }\n\n  stop() {\n    this.speed = 0;\n    console.log(`${this.name} 停了下来。`);\n  }\n}\n\n// 子类：Rabbit 继承自 Animal\n// 它拥有 Animal 的所有属性和方法，并可以添加自己的特性\nclass Rabbit extends Animal {\n  // Rabbit 可以有自己的方法\n  hide() {\n    console.log(`${this.name} 找到一个洞，藏了起来！`);\n  }\n}\n\nconst bugsBunny = new Rabbit('兔八哥');\n\n// 调用从 Animal 父类继承来的方法\nbugsBunny.run(40); \nbugsBunny.stop();\n\n// 调用 Rabbit 自己独有的方法\nbugsBunny.hide();", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-1-class声明.md", "blockIndex": 1}
{"id": "js-sec-4-2-1", "title": "class声明", "code": "class MathHelper {\n  // 这是一个静态方法，直接通过 MathHelper.add() 调用\n  static add(a, b) {\n    return a + b;\n  }\n  \n  // 这是一个普通方法，需要先创建实例才能调用\n  multiply(a, b) {\n    return a * b;\n  }\n}\n\n// 直接调用静态方法，无需创建实例\nconst sum = MathHelper.add(5, 10);\nconsole.log(`静态方法计算结果: ${sum}`);\n\n// 尝试在实例上调用静态方法会导致错误\n// const helperInstance = new MathHelper();\n// console.log(helperInstance.add(2, 3)); // 这会抛出错误：helperInstance.add is not a function\n\n// 调用普通方法，必须先创建实例\nconst helperInstance = new MathHelper();\nconst product = helperInstance.multiply(5, 10);\nconsole.log(`实例方法计算结果: ${product}`);", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-1-class声明.md", "blockIndex": 2}
{"id": "js-sec-4-2-1", "title": "class声明", "code": "class Player {\n  constructor(name) {\n    this.name = name;\n    this.score = 0;\n  }\n\n  increaseScore() {\n    this.score += 10;\n    console.log(`${this.name} 的分数增加了，现在是 ${this.score}`);\n  }\n}\n\nconsole.log(\"=== 错误用法 ===\");\ntry {\n  // ❌ 错误：直接像调用普通函数一样调用 class 构造函数\n  // 这会抛出一个 TypeError，因为类构造函数不能在没有 'new' 的情况下被调用\n  const player1 = Player('Alex'); \n  player1.increaseScore();\n} catch (e) {\n  console.error(\"出错了:\", e.message);\n  console.log(\"解释: Class 构造函数必须使用 'new' 关键字来调用，否则无法创建实例。\");\n}\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确：使用 'new' 关键字创建 Player 的一个实例\nconst player2 = new Player('Betty');\nplayer2.increaseScore();\nconsole.log(\"解释: 'new' 关键字创建了一个 Player 的新实例，并正确地将 this 指向这个新实例，然后调用构造函数进行初始化。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-1-class声明.md", "blockIndex": 3}
{"id": "js-sec-4-2-1", "title": "class声明", "code": "// 基础角色蓝图\nclass Character {\n  constructor(name, hp, attackPower) {\n    this.name = name;\n    this.hp = hp;\n    this.attackPower = attackPower;\n  }\n\n  attack(target) {\n    console.log(`💥 ${this.name} 对 ${target.name} 发动了普通攻击!`);\n    target.takeDamage(this.attackPower);\n  }\n\n  takeDamage(damage) {\n    this.hp -= damage;\n    if (this.hp <= 0) {\n      this.hp = 0;\n      console.log(`💀 ${this.name} 受到了 ${damage} 点伤害，倒下了...`);\n    } else {\n      console.log(`💔 ${this.name} 受到了 ${damage} 点伤害, 剩余 HP: ${this.hp}`);\n    }\n  }\n\n  showStatus() {\n    console.log(`[状态] ${this.name} | HP: ${this.hp}`);\n  }\n}\n\n// 魔法师子类，继承自 Character\nclass Mage extends Character {\n  constructor(name, hp, attackPower, mana) {\n    super(name, hp, attackPower); // 调用父类的构造函数\n    this.mana = mana;\n  }\n\n  // 魔法师的特殊技能\n  castFireball(target) {\n    if (this.mana >= 20) {\n      this.mana -= 20;\n      const spellDamage = this.attackPower * 2; // 火球术伤害翻倍\n      console.log(`🔥 ${this.name} 吟唱咒语，对 ${target.name} 释放了火球术! (消耗20点法力)`);\n      target.takeDamage(spellDamage);\n    } else {\n      console.log(`💧 ${this.name} 的法力不足，施法失败!`);\n      this.attack(target); // 法力不够，改为普通攻击\n    }\n  }\n}\n\n// 战士子类，继承自 Character\nclass Warrior extends Character {\n  constructor(name, hp, attackPower, rage) {\n    super(name, hp, attackPower);\n    this.rage = rage;\n  }\n  \n  // 战士的特殊技能\n  charge(target) {\n    if (this.rage >= 15) {\n      this.rage -= 15;\n      const chargeDamage = this.attackPower + 10; // 冲锋造成额外伤害\n      console.log(`🛡️ ${this.name} 发动英勇冲锋，撞向 ${target.name}! (消耗15点怒气)`);\n      target.takeDamage(chargeDamage);\n    } else {\n      console.log(`😠 ${this.name} 怒气不足，冲锋失败!`);\n      this.attack(target); // 怒气不够，改为普通攻击\n    }\n  }\n}\n\n// --- 冒险开始！ ---\nconsole.log(\"--- ⚔️ 决斗开始! ⚔️ ---\");\nconst gandalf = new Mage('甘道夫', 80, 15, 50); // 法师：血少，攻高，有法力\nconst aragorn = new Warrior('阿拉贡', 120, 10, 40); // 战士：血厚，攻低，有怒气\n\ngandalf.showStatus();\naragorn.showStatus();\nconsole.log(\"\\n--- 第一回合 ---\");\n\naragorn.charge(gandalf);\ngandalf.castFireball(aragorn);\n\nconsole.log(\"\\n--- 第二回合 ---\");\n\naragorn.attack(gandalf);\ngandalf.castFireball(aragorn);\n\nconsole.log(\"\\n--- 决斗结束 ---\");\ngandalf.showStatus();\naragorn.showStatus();", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-1-class声明.md", "blockIndex": 4}
{"id": "js-sec-4-2-2", "title": "构造器与属性", "code": "// 定义一个“宠物”蓝图 (class)\nclass Pet {\n  // 构造器：当创建一个新宠物时，这个函数会自动运行\n  constructor(name, type) {\n    console.log(`正在创建一只新的宠物...`);\n    // `this` 指向新创建的对象实例\n    // 将传入的 name 和 type 赋值给新对象的属性\n    this.name = name;\n    this.type = type;\n  }\n}\n\n// 使用 new 关键字，根据 Pet 蓝图创建一个具体的宠物实例\nconst myCat = new Pet('咪咪', '猫');\n\n// 访问实例的属性\nconsole.log(`我的宠物叫 ${myCat.name}，它是一只${myCat.type}。`);\nconsole.log(myCat);", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-2-构造器与属性.md", "blockIndex": 0}
{"id": "js-sec-4-2-2", "title": "构造器与属性", "code": "class Player {\n  // 为 level 和 score 设置默认值\n  constructor(name, level = 1, score = 0) {\n    this.name = name;\n    this.level = level;\n    this.score = score;\n  }\n}\n\n// 创建玩家时只提供了名字，level 和 score 会使用默认值\nconst newPlayer = new Player('新手玩家');\nconsole.log('新玩家信息:', newPlayer);\n\n// 创建一个提供了所有参数的玩家\nconst proPlayer = new Player('高玩大神', 99, 150000);\nconsole.log('高手玩家信息:', proPlayer);", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-2-构造器与属性.md", "blockIndex": 1}
{"id": "js-sec-4-2-2", "title": "构造器与属性", "code": "class Monster {\n  constructor(type) {\n    this.type = type;\n    this.createdAt = new Date().toLocaleTimeString();\n\n    // 根据传入的怪物类型，动态设置不同的属性\n    if (type === '哥布林') {\n      this.health = 50;\n      this.attack = 5;\n      this.loot = '金币';\n    } else if (type === '史莱姆') {\n      this.health = 30;\n      this.attack = 2;\n      this.loot = '凝胶';\n    } else {\n      this.health = 100;\n      this.attack = 10;\n      this.loot = '未知物品';\n    }\n  }\n}\n\nconst goblin = new Monster('哥布林');\nconsole.log('遭遇了哥布林!', goblin);\n\nconst slime = new Monster('史莱姆');\nconsole.log('发现了史莱姆!', slime);", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-2-构造器与属性.md", "blockIndex": 2}
{"id": "js-sec-4-2-2", "title": "构造器与属性", "code": "console.log(\"=== 错误用法 ===\");\n// ❌ 忘记使用 `this` 关键字\nclass Book_Wrong {\n  constructor(title, author) {\n    // 这里的 title 和 author 只是构造函数内部的局部变量\n    // 它们在函数执行完毕后就会消失，并不会成为实例的属性\n    let bookTitle = title;\n    let bookAuthor = author;\n  }\n}\n\nconst wrongBook = new Book_Wrong('JavaScript高级程序设计', 'Nicholas C. Zakas');\n// 尝试访问属性，会得到 undefined，因为它们从未被附加到实例上\nconsole.log('书名:', wrongBook.bookTitle); // 输出: undefined\nconsole.log('作者:', wrongBook.bookAuthor); // 输出: undefined\nconsole.log('错误创建的实例:', wrongBook); // 输出: Book_Wrong {} (一个空对象)\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 使用 `this` 关键字将属性绑定到实例\nclass Book_Correct {\n  constructor(title, author) {\n    // `this` 指向即将被创建的 book 实例\n    // this.title = ... 这行代码的意思是：“给这个新实例添加一个名为 title 的属性”\n    this.title = title;\n    this.author = author;\n  }\n}\n\nconst correctBook = new Book_Correct('你不知道的JavaScript', 'Kyle Simpson');\n// 可以成功访问到实例的属性\nconsole.log('书名:', correctBook.title);\nconsole.log('作者:', correctBook.author);\nconsole.log('正确创建的实例:', correctBook);", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-2-构造器与属性.md", "blockIndex": 3}
{"id": "js-sec-4-2-2", "title": "构造器与属性", "code": "// 角色生成器\nclass GameCharacter {\n  constructor(name, race, job) {\n    this.name = name;\n    this.race = race;\n    this.job = job;\n    this.level = 1;\n    this.inventory = ['面包', '水'];\n\n    console.log(`🌟 英雄诞生！欢迎，${this.race}族的${this.job}——${this.name}！`);\n\n    // --- 根据种族分配基础属性 ---\n    if (this.race === '兽人') {\n      this.health = 120;\n      this.strength = 15;\n      this.agility = 8;\n    } else if (this.race === '精灵') {\n      this.health = 80;\n      this.strength = 8;\n      this.agility = 15;\n    } else { // 默认人类\n      this.health = 100;\n      this.strength = 10;\n      this.agility = 10;\n    }\n\n    // --- 根据职业分配初始技能 ---\n    if (this.job === '战士') {\n      this.skills = ['猛击', '冲锋'];\n      this.strength += 3; // 战士有额外的力量加成\n    } else if (this.job === '弓箭手') {\n      this.skills = ['精准射击', '后跳'];\n      this.agility += 3; // 弓箭手有额外的敏捷加成\n    } else {\n      this.skills = ['火球术', '治疗术'];\n    }\n  }\n\n  // 一个简单的方法来展示角色状态\n  showStatus() {\n    console.log(`\n    --- 角色状态面板 ---\n    姓名: ${this.name}\n    种族: ${this.race}\n    职业: ${this.job}\n    等级: ${this.level}\n    生命值: ${this.health}\n    力量: ${this.strength}\n    敏捷: ${this.agility}\n    技能: ${this.skills.join(', ')}\n    背包: ${this.inventory.join(', ')}\n    --------------------\n    `);\n  }\n}\n\n// 创建一个兽人战士\nconst orcWarrior = new GameCharacter('格罗姆', '兽人', '战士');\norcWarrior.showStatus();\n\n// 创建一个精灵弓箭手\nconst elfArcher = new GameCharacter('莉雅', '精灵', '弓箭手');\nelfArcher.showStatus();", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-2-构造器与属性.md", "blockIndex": 4}
{"id": "js-sec-4-2-3", "title": "方法定义", "code": "// 创建一个代表宠物的对象\nconst pet = {\n  name: \"咪咪\",\n  type: \"猫\",\n  // 定义一个名为 \"meow\" 的方法\n  meow: function() {\n    // 这个方法返回一个字符串\n    return \"喵~ 我是\" + this.name + \"!\";\n  }\n};\n\n// 调用 pet 对象的 meow 方法\nconst sound = pet.meow();\n\nconsole.log(sound);\n// 输出: 喵~ 我是咪咪!", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-3-方法定义.md", "blockIndex": 0}
{"id": "js-sec-4-2-3", "title": "方法定义", "code": "const player = {\n  name: \"英雄阿杰\",\n  health: 100,\n  // 定义一个显示状态的方法\n  showStatus: function() {\n    // 'this' 指向 player 对象\n    // 因此 this.name 是 \"英雄阿杰\", this.health 是 100\n    console.log(`玩家: ${this.name}, 生命值: ${this.health}%`);\n  },\n  // 定义一个受伤的方法\n  takeDamage: function(amount) {\n    this.health -= amount;\n    console.log(`${this.name} 受到了 ${amount}点伤害!`);\n  }\n};\n\nplayer.showStatus(); // 调用时 this 指向 player\nplayer.takeDamage(15); // 调用时 this 指向 player\nplayer.showStatus(); // 再次查看状态，health 属性已被修改", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-3-方法定义.md", "blockIndex": 1}
{"id": "js-sec-4-2-3", "title": "方法定义", "code": "// 传统方法定义\nconst oldGreeter = {\n  name: \"传统先生\",\n  greet: function() {\n    console.log(\"传统方式问好: Hello, \" + this.name);\n  }\n};\n\n// ES6 简写方法定义\nconst newGreeter = {\n  name: \"摩登小姐\",\n  greet() { // 注意这里，省略了 \": function\"\n    console.log(\"ES6 方式问好: Hi, \" + this.name);\n  }\n};\n\nconsole.log(\"--- 传统方法定义 ---\");\noldGreeter.greet();\n\nconsole.log(\"\\n--- ES6 简写方法定义 ---\");\nnewGreeter.greet();", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-3-方法定义.md", "blockIndex": 2}
{"id": "js-sec-4-2-3", "title": "方法定义", "code": "// 完整的对比示例，包含所有必要的变量定义\nconst counter = {\n  count: 0,\n  // ❌ 错误用法：使用箭头函数定义方法\n  // 箭头函数不会创建自己的 this，它会从外部作用域继承 this。\n  // 在这个例子中，它继承了全局的 this (在浏览器中是 window)，而不是 counter 对象。\n  arrowIncrement: () => {\n    // 这里的 this 不是 counter 对象！\n    this.count++; // 尝试增加全局作用域的 count，而不是 counter.count\n    console.log(`箭头函数后的 count: ${this.count}`); // 输出 NaN 或 undefined\n  },\n\n  // ✅ 正确用法：使用常规函数或 ES6 简写\n  // 这种方式定义的函数，其 this 会在调用时动态绑定到 counter 对象。\n  correctIncrement() {\n    this.count++; // 这里的 this 是 counter 对象\n    console.log(`常规函数后的 count: ${this.count}`);\n  }\n};\n\n\nconsole.log(\"=== 错误用法 ===\");\nconsole.log(`初始 count: ${counter.count}`);\ncounter.arrowIncrement(); // 调用箭头函数方法\nconsole.log(`调用后 counter.count 实际值: ${counter.count}`); // count 并没有改变\n\nconsole.log(\"\\n=== 正确用法 ===\");\ncounter.correctIncrement(); // 调用常规函数方法\nconsole.log(`调用后 counter.count 实际值: ${counter.count}`); // count 成功增加了", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-3-方法定义.md", "blockIndex": 3}
{"id": "js-sec-4-2-3", "title": "方法定义", "code": "// 创建一个史莱姆角色对象\nconst slime = {\n  name: \"噗噗\",\n  hp: 50,\n  maxHp: 50,\n  attackPower: 5,\n  color: \"蓝色\",\n\n  // 方法1: 显示状态\n  displayStatus() {\n    console.log(`[状态] 我是${this.color}的史莱姆'${this.name}' | HP: ${this.hp}/${this.maxHp}`);\n  },\n\n  // 方法2: 攻击敌人\n  attack(targetName) {\n    console.log(`💥 '${this.name}' 对 '${targetName}' 使用了「撞击」！造成了 ${this.attackPower} 点伤害！`);\n  },\n\n  // 方法3: 受到伤害\n  takeDamage(damage) {\n    this.hp -= damage;\n    if (this.hp <= 0) {\n      this.hp = 0;\n      console.log(`😭 啊哦... '${this.name}' 被击败了，变成了一滩液体...`);\n    } else {\n      console.log(`😨 '${this.name}' 受到了 ${damage} 点伤害！`);\n      this.displayStatus();\n    }\n  },\n\n  // 方法4: 治愈自己 (不能超过最大HP)\n  heal(amount) {\n    this.hp += amount;\n    if (this.hp > this.maxHp) {\n      this.hp = this.maxHp;\n    }\n    console.log(`✨ '${this.name}' 治愈了自己，恢复了 ${amount} 点HP！`);\n    this.displayStatus();\n  }\n};\n\n// --- 让我们开始一场小小的冒险吧！ ---\nconsole.log(\"冒险开始！一只史莱姆出现了！\");\nslime.displayStatus();\n\nconsole.log(\"\\n--- 遭遇了敌人：一只愤怒的小鸡 ---\");\nslime.attack(\"愤怒的小鸡\");\n\nconsole.log(\"\\n--- 史莱姆遭到了反击！ ---\");\nslime.takeDamage(20);\n\nconsole.log(\"\\n--- 史莱姆决定吃掉一颗治愈果冻 ---\");\nslime.heal(15);\n\nconsole.log(\"\\n--- 史莱姆被最终一击击中！ ---\");\nslime.takeDamage(100);", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-3-方法定义.md", "blockIndex": 4}
{"id": "js-sec-4-2-4", "title": "继承extends", "code": "// 父类：动物\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  speak() {\n    console.log(`${this.name} 发出了一些声音。`);\n  }\n}\n\n// 子类：狗，通过 extends 继承自动物\nclass Dog extends Animal {\n  // 这个类是空的，但它自动拥有了 Animal 的所有东西\n}\n\n// 创建一个 Dog 实例\nconst myDog = new Dog('旺财');\n\n// 调用继承自 Animal 的 speak 方法\nmyDog.speak(); // 输出: 旺财 发出了一些声音。\n\nconsole.log(`我的狗叫: ${myDog.name}`); // 输出: 我的狗叫: 旺财", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-4-继承extends.md", "blockIndex": 0}
{"id": "js-sec-4-2-4", "title": "继承extends", "code": "class Vehicle {\n  constructor(name) {\n    this.name = name;\n  }\n\n  move() {\n    return `${this.name} 正在移动。`;\n  }\n}\n\nclass Car extends Vehicle {\n  constructor(name, brand) {\n    // 1. 使用 super(name) 调用父类的 constructor(name)\n    // 必须在子类构造函数中使用 'this' 之前调用 super()\n    super(name);\n    this.brand = brand;\n  }\n\n  move() {\n    // 2. 使用 super.move() 调用父类的 move 方法\n    const parentMoveAction = super.move();\n    console.log(`${this.brand} 品牌的 ${parentMoveAction} 发动机发出轰鸣！`);\n  }\n}\n\nconst myCar = new Car('探险者', '福特');\nmyCar.move();\n// 输出: 福特 品牌的 探险者 正在移动。 发动机发出轰鸣！", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-4-继承extends.md", "blockIndex": 1}
{"id": "js-sec-4-2-4", "title": "继承extends", "code": "class GameCharacter {\n  attack() {\n    console.log(\"角色使用了基础攻击，造成 10 点伤害！\");\n  }\n}\n\nclass Mage extends GameCharacter {\n  // 重写了父类的 attack 方法\n  attack() {\n    console.log(\"法师吟唱咒语，释放了火球术！🔥🔥🔥 造成 50 点伤害！\");\n  }\n\n  teleport() {\n    console.log(\"法师使用了闪现！\");\n  }\n}\n\nconst genericCharacter = new GameCharacter();\nconst gandalf = new Mage();\n\nconsole.log(\"--- 父类实例调用 ---\");\ngenericCharacter.attack();\n\nconsole.log(\"\\n--- 子类实例调用 ---\");\ngandalf.attack(); // 调用的是 Mage 中重写后的方法\ngandalf.teleport(); // 调用 Mage 自己独有的方法", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-4-继承extends.md", "blockIndex": 2}
{"id": "js-sec-4-2-4", "title": "继承extends", "code": "// 父类定义\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 在 super() 调用前使用 this\ntry {\n  class Student extends Person {\n    constructor(name, studentId) {\n      // 错误！在 super() 完成初始化之前，'this' 还不存在\n      this.studentId = studentId; \n      super(name);\n    }\n  }\n  const student = new Student('小明', 'S001');\n} catch (e) {\n  console.error(\"捕获到错误:\", e.message);\n}\nconsole.log(\"解释: 子类的 'this' 是由父类的构造函数创建的。因此，必须先调用 super() 来完成这个创建过程，然后才能安全地使用 'this'。\");\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 先调用 super()，再使用 this\nclass Teacher extends Person {\n  constructor(name, subject) {\n    // 正确！首先调用父类构造函数，初始化 this\n    super(name);\n    // 现在 'this' 已经是一个合法的实例，可以给它添加属性\n    this.subject = subject;\n  }\n  \n  introduce() {\n    console.log(`大家好，我是 ${this.name} 老师，我教 ${this.subject}。`);\n  }\n}\nconst mrWang = new Teacher('王老师', 'JavaScript');\nmrWang.introduce();\nconsole.log(\"解释: 先通过 super(name) 完成父类的初始化，创建了 this 上下文，然后子类才能继续添加自己的属性。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-4-继承extends.md", "blockIndex": 3}
{"id": "js-sec-4-2-4", "title": "继承extends", "code": "// 基础机器人 (父类)\nclass Robot {\n  constructor(name) {\n    this.name = name;\n    this.battery = 100;\n  }\n\n  charge() {\n    this.battery = 100;\n    console.log(`🤖 ${this.name} 正在充电... 电量恢复到 100%！`);\n  }\n\n  reportStatus() {\n    console.log(`- ${this.name} 状态: 电量 ${this.battery}%`);\n  }\n}\n\n// 战斗机器人 (子类)\nclass BattleBot extends Robot {\n  constructor(name, weapon) {\n    super(name); // 调用父类构造函数设置名字和电量\n    this.weapon = weapon;\n  }\n\n  // 战斗机器人特有的方法\n  attack() {\n    if (this.battery >= 10) {\n      this.battery -= 10;\n      console.log(`💥 ${this.name} 使用 ${this.weapon} 发动攻击！电量消耗 10%。`);\n    } else {\n      console.log(`🔋 ${this.name} 电量不足，无法攻击！需要充电。`);\n    }\n  }\n\n  // 重写父类的方法，加入更多信息\n  reportStatus() {\n    super.reportStatus(); // 先调用父类的方法打印基础信息\n    console.log(`  武器装备: ${this.weapon}`); // 再添加子类特有的信息\n  }\n}\n\n// 清洁机器人 (子类)\nclass CleanBot extends Robot {\n  constructor(name) {\n    super(name);\n    this.isCleaning = false;\n  }\n\n  // 清洁机器人特有的方法\n  toggleCleaning() {\n    if (this.battery > 5) {\n      this.isCleaning = !this.isCleaning;\n      if (this.isCleaning) {\n        console.log(`🧹 ${this.name} 开始打扫房间！嗡嗡嗡...`);\n        this.battery -= 5;\n      } else {\n        console.log(`⏸️ ${this.name} 停止打扫。`);\n      }\n    } else {\n      console.log(`🔋 ${this.name} 没电了，无法开始打扫。`);\n    }\n  }\n}\n\nconsole.log(\"--- 机器人军团集结！ ---\");\nconst terminator = new BattleBot('终结者T-800', '等离子炮');\nconst wallE = new CleanBot('瓦力');\n\nterminator.reportStatus();\nwallE.reportStatus();\n\nconsole.log(\"\\n--- 开始行动！ ---\");\nterminator.attack();\nterminator.attack();\nwallE.toggleCleaning();\n\nconsole.log(\"\\n--- 行动后状态 ---\");\nterminator.reportStatus();\nwallE.reportStatus();\n\nconsole.log(\"\\n--- 终结者持续战斗直到电量耗尽 ---\");\nfor(let i = 0; i < 8; i++) {\n  terminator.attack();\n}\nterminator.charge(); // 充电\nterminator.attack(); // 再次攻击", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-4-继承extends.md", "blockIndex": 4}
{"id": "js-sec-4-2-5", "title": "super关键字", "code": "// Level 1: 基础认知\n// 父类：动物\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n// 子类：狗，继承自动物\nclass Dog extends Animal {\n  constructor(name, breed) {\n    // 使用 super(name) 调用父类 Animal 的构造函数\n    // 必须先调用 super() 才能使用 this\n    super(name); \n    this.breed = breed;\n  }\n}\n\nconst myDog = new Dog('旺财', '哈士奇');\nconsole.log(`我的小狗叫 ${myDog.name}，它是一只${myDog.breed}。`);\n// 输出: 我的小狗叫 旺财，它是一只哈士奇。", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-5-super关键字.md", "blockIndex": 0}
{"id": "js-sec-4-2-5", "title": "super关键字", "code": "// Level 2, 特性1: 在构造函数中调用父类构造函数\nclass Vehicle {\n  constructor(wheels) {\n    this.wheels = wheels;\n    console.log(`一辆有 ${this.wheels} 个轮子的交通工具被制造出来了。`);\n  }\n}\n\nclass Car extends Vehicle {\n  constructor(color) {\n    // 调用父类的构造函数，并传递参数 4\n    super(4); \n    // 在 super() 被调用后，我们才能安全地使用 'this'\n    this.color = color;\n    console.log(`这是一辆${this.color}的汽车，它有 ${this.wheels} 个轮子。`);\n  }\n}\n\nconst myCar = new Car('红色');\n// 输出:\n// 一辆有 4 个轮子的交通工具被制造出来了。\n// 这是一辆红色的汽车，它有 4 个轮子。", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-5-super关键字.md", "blockIndex": 1}
{"id": "js-sec-4-2-5", "title": "super关键字", "code": "// Level 2, 特性2: 调用父类的普通方法\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n\n  greet() {\n    return `你好，我是 ${this.name}。`;\n  }\n}\n\nclass SuperHero extends Person {\n  constructor(name, power) {\n    super(name);\n    this.power = power;\n  }\n\n  // 重写 greet 方法\n  greet() {\n    // 首先，调用父类的 greet 方法\n    const parentGreeting = super.greet();\n    // 然后，添加子类自己的逻辑\n    return `${parentGreeting} 我的超能力是${this.power}！`;\n  }\n}\n\nconst superman = new SuperHero('超人', '飞行');\nconsole.log(superman.greet());\n// 输出: 你好，我是 超人。 我的超能力是飞行！", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-5-super关键字.md", "blockIndex": 2}
{"id": "js-sec-4-2-5", "title": "super关键字", "code": "// Level 3: 对比学习\nclass Parent {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nconsole.log(\"=== 错误用法 ===\");\ntry {\n  class ChildWrong extends Parent {\n    constructor(name, age) {\n      // ❌ 错误: 在调用 super() 之前使用了 'this'\n      this.age = age; \n      super(name);\n    }\n  }\n  const wrong = new ChildWrong('小明', 10);\n} catch (error) {\n  console.log(`错误信息: ${error.message}`);\n  // 解释: 在子类构造函数中，this 的值在 super() 调用之前是未初始化的。\n  // 任何尝试访问 this 的行为都会导致 ReferenceError。\n}\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\nclass ChildRight extends Parent {\n  constructor(name, age) {\n    // ✅ 正确: 必须先调用 super() 来初始化父类部分\n    super(name);\n    // 现在可以安全地使用 'this' 了\n    this.age = age;\n  }\n  \n  introduce() {\n    return `我叫${this.name}，今年${this.age}岁。`;\n  }\n}\nconst right = new ChildRight('小红', 12);\nconsole.log(right.introduce());\n// 解释: 正确的顺序是先让父类通过 super() 完成对 this 的基本构建，\n// 然后子类再在 this 上添加自己的属性。", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-5-super关键字.md", "blockIndex": 3}
{"id": "js-sec-4-2-5", "title": "super关键字", "code": "// Level 4: 游戏角色升级系统\n\n// 基础玩家类\nclass Player {\n  constructor(name, level = 1) {\n    this.name = name;\n    this.level = level;\n    this.health = 100 + level * 10;\n  }\n\n  attack() {\n    const damage = 5 + this.level * 2;\n    console.log(`🪓 ${this.name} 挥舞武器，造成了 ${damage} 点伤害！`);\n    return damage;\n  }\n\n  showStatus() {\n    return `[${this.name} | 等级:${this.level} | ❤️生命:${this.health}]`;\n  }\n}\n\n// 法师子类，继承自玩家\nclass Mage extends Player {\n  constructor(name, level = 1, magicType = '火焰') {\n    // 调用父类构造函数，初始化基础属性\n    super(name, level);\n    this.mana = 50 + level * 15; // 法师有额外的法力值\n    this.magicType = magicType;\n  }\n\n  // 法师的特殊技能：施放法术\n  castSpell() {\n    if (this.mana >= 20) {\n      this.mana -= 20;\n      const spellDamage = 15 + this.level * 5;\n      console.log(`🔮 ${this.name} 吟唱咒语，释放了一个${this.magicType}法术，造成 ${spellDamage} 点伤害！剩余法力: ${this.mana}`);\n      return spellDamage;\n    } else {\n      console.log(`🌀 法力不足！${this.name} 无法施法。`);\n      return 0;\n    }\n  }\n\n  // 重写 showStatus 方法，以显示更多信息\n  showStatus() {\n    // 调用父类的 showStatus 方法获取基础信息\n    const basicStatus = super.showStatus();\n    // 在基础信息上添加法师特有的法力值信息\n    return `${basicStatus} [💧法力:${this.mana}]`;\n  }\n}\n\nconsole.log(\"--- 欢迎来到JS冒险世界！ ---\");\n\nconst gandalf = new Mage('甘道夫', 5, '光');\n\nconsole.log(\"角色创建成功:\");\nconsole.log(gandalf.showStatus());\n\nconsole.log(\"\\n--- 战斗开始！ ---\");\ngandalf.attack();\ngandalf.castSpell();\ngandalf.castSpell();\ngandalf.castSpell(); // 尝试施放第三次法术\n\nconsole.log(\"\\n--- 战斗后状态 ---\");\nconsole.log(gandalf.showStatus());", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-5-super关键字.md", "blockIndex": 4}
{"id": "js-sec-4-2-6", "title": "静态方法与属性", "code": "class MathHelper {\n  // 使用 static 关键字定义一个静态方法\n  static add(a, b) {\n    return a + b;\n  }\n}\n\n// 直接通过类名调用静态方法，而不需要 new 一个实例\nconst sum = MathHelper.add(5, 10);\n\nconsole.log(`5 + 10 的结果是: ${sum}`);\n// 输出: 5 + 10 的结果是: 15", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-6-静态方法与属性.md", "blockIndex": 0}
{"id": "js-sec-4-2-6", "title": "静态方法与属性", "code": "class User {\n  // 静态属性：所有用户共享的配置\n  static minPasswordLength = 8;\n\n  // 静态方法：一个用于验证的工具函数\n  static validatePassword(password) {\n    return password.length >= User.minPasswordLength;\n  }\n\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n// 1. 直接通过类访问静态成员\nconsole.log(`密码最小长度要求: ${User.minPasswordLength}`);\nconsole.log(`'12345' 是否是有效密码? ${User.validatePassword('12345')}`);\nconsole.log(`'123456789' 是否是有效密码? ${User.validatePassword('123456789')}`);\n\n// 2. 尝试通过实例访问静态成员\nconst user1 = new User('Alice');\nconsole.log(`尝试通过实例 user1 访问 minPasswordLength:`, user1.minPasswordLength); // 实例上不存在\nconsole.log(`实例 user1 的名字是: ${user1.name}`);\n\n// 下一行会报错，因为 validatePassword 是静态方法，不存在于实例上\n// console.log(user1.validatePassword('password')); // TypeError: user1.validatePassword is not a function", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-6-静态方法与属性.md", "blockIndex": 1}
{"id": "js-sec-4-2-6", "title": "静态方法与属性", "code": "class ConfigManager {\n  static environment = 'development';\n  static serverURL = 'http://dev.server.com';\n\n  static setEnvironment(env) {\n    this.environment = env; // 'this' 指向 ConfigManager 类\n    // 根据环境更新另一个静态属性\n    if (env === 'production') {\n      this.serverURL = 'https://api.server.com';\n    } else {\n      this.serverURL = 'http://dev.server.com';\n    }\n  }\n\n  static printConfig() {\n    // 'this' 指向 ConfigManager 类，可以访问其他静态属性\n    console.log(`当前环境: ${this.environment}`);\n    console.log(`服务器地址: ${this.serverURL}`);\n  }\n}\n\nconsole.log(\"--- 默认配置 ---\");\nConfigManager.printConfig();\n\nconsole.log(\"\\n--- 切换到生产环境 ---\");\nConfigManager.setEnvironment('production');\nConfigManager.printConfig();", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-6-静态方法与属性.md", "blockIndex": 2}
{"id": "js-sec-4-2-6", "title": "静态方法与属性", "code": "class Player {\n  // 静态属性：记录总玩家数量\n  static totalPlayers = 0;\n\n  // 静态方法：用于创建特殊玩家（例如访客），它不依赖于任何特定实例\n  static createGuest() {\n    // 在静态方法中，this 指向 Player 类\n    this.totalPlayers++; \n    console.log(`一位访客玩家已创建！现在总共有 ${this.totalPlayers} 位玩家。`);\n    return new Player('Guest');\n  }\n\n  // 实例属性\n  constructor(name) {\n    this.name = name;\n  }\n\n  // 实例方法：每个玩家实例都可以调用，用于介绍自己\n  introduce() {\n    // 在实例方法中，this 指向调用该方法的实例 (e.g., player1)\n    console.log(`你好，我是 ${this.name}。`);\n  }\n}\n\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误1: 尝试在实例上调用静态方法\nconst player1 = new Player('Cyborg');\ntry {\n  player1.createGuest();\n} catch (error) {\n  console.log(\"错误:\", error.message);\n  console.log(\"解释: 'createGuest' 是 Player 类的静态方法，必须通过 Player.createGuest() 调用，而不是在实例上。\");\n}\n\n// ❌ 错误2: 尝试在类上调用实例方法\ntry {\n  Player.introduce();\n} catch (error) {\n  console.log(\"\\n错误:\", error.message);\n  console.log(\"解释: 'introduce' 是一个实例方法，它需要一个具体的玩家实例来知道 'this.name' 是什么。必须先 new Player()，然后才能调用。\");\n}\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确1: 在类上调用静态方法\nconst guestPlayer = Player.createGuest();\n\n// ✅ 正确2: 在实例上调用实例方法\nplayer1.introduce();\nguestPlayer.introduce();", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-6-静态方法与属性.md", "blockIndex": 3}
{"id": "js-sec-4-2-6", "title": "静态方法与属性", "code": "// 🎲 DiceMaster - 一个不需要实例化的游戏工具类\nclass DiceMaster {\n  // 静态属性：定义标准骰子的面数，这是一个类级别的常量\n  static SIDES = 6;\n\n  // 静态方法：掷一个骰子\n  // 这是一个完美的工具函数，它的功能独立，不依赖任何实例状态\n  static roll() {\n    // this.SIDES 引用了类自身的静态属性\n    return Math.floor(Math.random() * this.SIDES) + 1;\n  }\n\n  // 静态方法：掷多个骰子\n  static rollMultiple(count) {\n    const results = [];\n    for (let i = 0; i < count; i++) {\n      // 在一个静态方法中调用另一个静态方法\n      results.push(this.roll());\n    }\n    return results;\n  }\n\n  // 静态方法：一个有趣的播报结果的工具\n  static announceResult(playerName, rolls) {\n    const total = rolls.reduce((sum, val) => sum + val, 0);\n    const rollsString = rolls.join(', ');\n    let emoji = '😐';\n    if (total > rolls.length * 4) {\n      emoji = '🎉'; // 高分\n    } else if (total < rolls.length * 2) {\n      emoji = '😭'; // 低分\n    }\n    console.log(`${playerName} 掷出了: [${rollsString}] (总点数: ${total}) ${emoji}`);\n  }\n}\n\nconsole.log(\"--- 欢迎来到骰子大师游戏! ---\");\nconsole.log(`我们的标准骰子有 ${DiceMaster.SIDES} 面。\\n`);\n\n// 玩家 \"闪电侠\" 开始掷骰子\nconsole.log(\"闪电侠的回合...\");\nconst flashRolls = DiceMaster.rollMultiple(3);\nDiceMaster.announceResult('闪电侠', flashRolls);\n\nconsole.log(\"\\n神奇女侠的回合...\");\nconst wonderWomanRolls = DiceMaster.rollMultiple(3);\nDiceMaster.announceResult('神奇女侠', wonderWomanRolls);", "lang": "javascript", "source": "web-learner/public/content/js-sec-4-2-6-静态方法与属性.md", "blockIndex": 4}
{"id": "js-sec-5-1-1", "title": "同步vs异步", "code": "// Level 1: 基础认知\nconsole.log(\"1. 开始点餐\");\n\n// setTimeout 模拟一个需要等待的异步操作（比如：厨房正在做菜）\nsetTimeout(function() {\n  console.log(\"3. 菜做好了，取餐！\");\n}, 2000); // 2秒后执行\n\nconsole.log(\"2. 拿到取餐号，先去找座位玩手机\");\n\n// 输出结果:\n// 1. 开始点餐\n// 2. 拿到取餐号，先去找座位玩手机\n// (等待2秒后)\n// 3. 菜做好了，取餐！", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-1-1-同步vs异步.md", "blockIndex": 0}
{"id": "js-sec-5-1-1", "title": "同步vs异步", "code": "// Level 2, 特性1: 非阻塞性\n\nconsole.log(\"=== 同步阻塞示例 ===\");\nconsole.log(\"同步任务A：开始\");\n// 模拟一个耗时的同步计算\nconst startTime = new Date().getTime();\nwhile (new Date().getTime() - startTime < 1500) {\n  // 循环1.5秒，阻塞线程\n}\nconsole.log(\"同步任务A：结束\");\nconsole.log(\"同步任务B：这个消息必须等A结束后才能打印\");\n\nconsole.log(\"\\n=== 异步非阻塞示例 ===\");\nconsole.log(\"异步任务A：开始\");\n// 使用setTimeout模拟一个耗时的异步操作\nsetTimeout(() => {\n  console.log(\"异步任务A：结束（我是1.5秒后才出现的）\");\n}, 1500);\nconsole.log(\"异步任务B：我不会被A阻塞，立刻就被打印出来了！\");\n\n// 输出结果:\n// === 同步阻塞示例 ===\n// 同步任务A：开始\n// (等待1.5秒)\n// 同步任务A：结束\n// 同步任务B：这个消息必须等A结束后才能打印\n//\n// === 异步非阻塞示例 ===\n// 异步任务A：开始\n// 异步任务B：我不会被A阻塞，立刻就被打印出来了！\n// (等待1.5秒后)\n// 异步任务A：结束（我是1.5秒后才出现的）", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-1-1-同步vs异步.md", "blockIndex": 1}
{"id": "js-sec-5-1-1", "title": "同步vs异步", "code": "// Level 2, 特性2: 事件循环\n\nconsole.log(\"1. 同步代码：开始\");\n\n// 即使延迟时间为0，它仍然是一个异步任务\nsetTimeout(() => {\n  console.log(\"3. 异步回调：我虽然是0秒延迟，但还是得排队\");\n}, 0);\n\nconsole.log(\"2. 同步代码：结束，主线程空闲了，现在去看看有没有异步任务\");\n\n// 输出结果:\n// 1. 同步代码：开始\n// 2. 同步代码：结束，主线程空闲了，现在去看看有没有异步任务\n// 3. 异步回调：我虽然是0秒延迟，但还是得排队", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-1-1-同步vs异步.md", "blockIndex": 2}
{"id": "js-sec-5-1-1", "title": "同步vs异步", "code": "// Level 3: 对比学习\n\n// 模拟一个异步获取用户数据的函数\nfunction getUserData(userId, callback) {\n  // 模拟网络延迟\n  setTimeout(() => {\n    const users = {\n      '101': { name: '爱丽丝', pet: '兔子' },\n      '102': { name: '鲍勃', pet: '猫' }\n    };\n    const userData = users[userId];\n    // 当数据准备好后，通过回调函数将数据传出去\n    if (callback) {\n      callback(userData);\n    }\n  }, 1000); // 假设需要1秒\n}\n\n\nconsole.log(\"=== 错误用法 ===\");\nfunction getPetWrong(userId) {\n  let pet = '';\n  // 这是一个异步函数，它会立即返回，而不会等待setTimeout\n  getUserData(userId, (data) => {\n    console.log(\"❌ 异步回调执行了，但太晚了！\");\n    pet = data.pet;\n  });\n  // 函数立即返回，此时pet还是空字符串\n  return pet;\n}\n\nconst wrongPet = getPetWrong('101');\nconsole.log(`❌ 试图立即获取宠物信息: ${wrongPet || '什么都没有拿到...'}`);\nconsole.log(\"❌ 原因：getPetWrong函数在getUserData的异步回调执行前就返回了。\");\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\nfunction getPetCorrect(userId, onPetReady) {\n  // 将获取结果后的处理逻辑，也封装成一个回调函数\n  getUserData(userId, (data) => {\n    const pet = data.pet;\n    console.log(\"✅ 异步回调执行，现在可以处理宠物信息了！\");\n    // 当宠物信息准备好时，调用传入的回调函数\n    onPetReady(pet);\n  });\n}\n\nconsole.log(\"✅ 开始请求宠物信息...\");\ngetPetCorrect('102', (pet) => {\n  // 这个函数体内的代码，就是我们获取到数据后想做的事\n  console.log(`✅ 成功获取到宠物信息: 一只可爱的'${pet}'！`);\n});\n\n// 输出结果:\n// === 错误用法 ===\n// ❌ 试图立即获取宠物信息: 什么都没有拿到...\n// ❌ 原因：getPetWrong函数在getUserData的异步回调执行前就返回了。\n// (等待1秒后)\n// ❌ 异步回调执行了，但太晚了！\n//\n// === 正确用法 ===\n// ✅ 开始请求宠物信息...\n// (等待1秒后)\n// ✅ 异步回调执行，现在可以处理宠物信息了！\n// ✅ 成功获取到宠物信息: 一只可爱的'猫'！", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-1-1-同步vs异步.md", "blockIndex": 3}
{"id": "js-sec-5-1-1", "title": "同步vs异步", "code": "// Level 4: 魔法披萨外卖机器人\n\n/**\n * 模拟机器人制作披萨的异步过程\n * @param {string} pizzaType - 披萨类型\n * @param {function} onReady - 制作完成后的回调函数\n */\nfunction makePizza(pizzaType, onReady) {\n  // 不同披萨的制作时间不同\n  const prepTime = {\n    '玛格丽特': 2000, // 2秒\n    '夏威夷风情': 4000, // 4秒\n    '豪华至尊': 3000  // 3秒\n  }[pizzaType] || 2500;\n\n  console.log(`[机器人🤖]: 收到订单！开始制作 ${pizzaType} 披萨，预计需要 ${prepTime / 1000} 秒...`);\n\n  setTimeout(() => {\n    const message = `[机器人🤖]: 叮！您的 ${pizzaType} 披萨🍕准备好啦，祝您用餐愉快！`;\n    onReady(message);\n  }, prepTime);\n}\n\n// === 顾客同时下单 ===\nconsole.log(\"👨‍👩‍👧‍👦 客人们开始点餐了...\\n\");\n\n// 顾客A点了玛格丽特披萨\nmakePizza('玛格丽特', (deliveryMessage) => {\n  console.log(`[顾客A]: 🎉 太棒了！我的披萨到了！ ${deliveryMessage}`);\n});\n\n// 顾客B点了夏威夷风情披萨\nmakePizza('夏威夷风情', (deliveryMessage) => {\n  console.log(`[顾客B]: 😎 等了好久，终于来了！ ${deliveryMessage}`);\n});\n\n// 顾客C点了豪华至尊披萨\nmakePizza('豪华至尊', (deliveryMessage) => {\n  console.log(`[顾客C]: 👍 正好饿了，开吃！ ${deliveryMessage}`);\n});\n\nconsole.log(\"\\n[机器人🤖]: 所有订单已接收，厨房正在火力全开！客人们请稍等片刻...\");\n\n// 观察控制台输出，你会发现披萨完成的顺序和下单的顺序是不同的，\n// 这正是异步非阻塞的魅力！\n// 最快的玛格丽特披萨（2秒）会最先送达。\n\n// 预计输出顺序:\n// 👨‍👩‍👧‍👦 客人们开始点餐了...\n//\n// [机器人🤖]: 收到订单！开始制作 玛格丽特 披萨，预计需要 2 秒...\n// [机器人🤖]: 收到订单！开始制作 夏威夷风情 披萨，预计需要 4 秒...\n// [机器人🤖]: 收到订单！开始制作 豪华至尊 披萨，预计需要 3 秒...\n//\n// [机器人🤖]: 所有订单已接收，厨房正在火力全开！客人们请稍等片刻...\n// (2秒后)\n// [顾客A]: 🎉 太棒了！我的披萨到了！ [机器人🤖]: 叮！您的 玛格丽特 披萨🍕准备好啦，祝您用餐愉快！\n// (再过1秒, 即总共3秒后)\n// [顾客C]: 👍 正好饿了，开吃！ [机器人🤖]: 叮！您的 豪华至尊 披萨🍕准备好啦，祝您用餐愉快！\n// (再过1秒, 即总共4秒后)\n// [顾客B]: 😎 等了好久，终于来了！ [机器人🤖]: 叮！您的 夏威夷风情 披萨🍕准备好啦，祝您用餐愉快！", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-1-1-同步vs异步.md", "blockIndex": 4}
{"id": "js-sec-5-1-2", "title": "事件循环机制", "code": "// Level 1: 同步与异步的执行顺序\n\nconsole.log(\"1. 早餐：开始做饭\");\n\n// 设置一个0毫秒的定时器，代表一个异步任务（比如：用微波炉热牛奶）\n// 即使是0毫秒，它也会被放入“任务队列”等待\nsetTimeout(() => {\n  console.log(\"3. 早餐：牛奶热好了！\");\n}, 0);\n\nconsole.log(\"2. 早餐：面包烤好了，先吃面包\");\n\n// 输出结果：\n// 1. 早餐：开始做饭\n// 2. 早餐：面包烤好了，先吃面包\n// 3. 早餐：牛奶热好了！", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-1-2-事件循环机制.md", "blockIndex": 0}
{"id": "js-sec-5-1-2", "title": "事件循环机制", "code": "// Level 2, Feature 1: 调用栈与任务队列\n\nfunction main() {\n  console.log('A: 进入主函数 main');\n  taskA();\n  // 设置一个宏任务\n  setTimeout(() => {\n    console.log('D: 定时器回调执行');\n  }, 10); // 10ms后放入任务队列\n  console.log('C: 退出主函数 main');\n}\n\nfunction taskA() {\n  console.log('B: 执行任务A');\n}\n\n// 开始执行\nmain();\n\n// 执行流程分析:\n// 1. main() 进入调用栈。打印 'A'。\n// 2. taskA() 进入调用栈。打印 'B'。taskA() 结束，出栈。\n// 3. setTimeout 被调用，其回调函数被交给Web API，计时器开始。\n// 4. 打印 'C'。main() 结束，出栈。\n// 5. 调用栈变空。\n// 6. 10ms后，Web API将定时器回调放入任务队列。\n// 7. 事件循环发现调用栈为空，从任务队列取出回调，放入调用栈执行。\n// 8. 打印 'D'。", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-1-2-事件循环机制.md", "blockIndex": 1}
{"id": "js-sec-5-1-2", "title": "事件循环机制", "code": "// Level 2, Feature 2: 微任务与宏任务\n\nconsole.log('1. 同步代码：开始');\n\n// 注册一个宏任务\nsetTimeout(() => {\n  console.log('5. 宏任务：setTimeout 回调');\n}, 0);\n\n// 注册一个微任务\nPromise.resolve().then(() => {\n  console.log('3. 微任务：Promise.then 回调 1');\n}).then(() => {\n  console.log('4. 微任务：Promise.then 回调 2');\n});\n\nconsole.log('2. 同步代码：结束');\n\n// 输出结果：\n// 1. 同步代码：开始\n// 2. 同步代码：结束\n// 3. 微任务：Promise.then 回调 1\n// 4. 微任务：Promise.then 回调 2\n// 5. 宏任务：setTimeout 回调\n\n// 分析：同步代码执行完后，事件循环发现微任务队列有任务，\n// 于是清空微任务队列（执行所有.then），最后才从宏任务队列取任务执行。", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-1-2-事件循环机制.md", "blockIndex": 2}
{"id": "js-sec-5-1-2", "title": "事件循环机制", "code": "// Level 3: 对比学习\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误：试图在同步代码中获取异步更新的值\nlet pizzaStatus = \"准备中...\";\nsetTimeout(() => {\n  pizzaStatus = \"可以吃了！\";\n  console.log(\"内部更新状态:\", pizzaStatus); // 这里是 \"可以吃了！\"\n}, 0);\nconsole.log(\"外部立即检查状态:\", pizzaStatus); // 这里仍然是 \"准备中...\"\n// 解释：console.log是同步代码，会立即执行。\n// setTimeout的回调被放入任务队列，在所有同步代码执行完之前，它绝不会执行。\n// 因此，外部检查时，状态尚未被更新。\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确：使用回调函数或Promise来处理异步结果\nfunction preparePizza(callback) {\n  let status = \"准备中...\";\n  console.log(\"开始准备披萨...\");\n  // 模拟一个异步的烘焙过程\n  setTimeout(() => {\n    status = \"可以吃了！\";\n    // 当披萨准备好后，调用回调函数并传入结果\n    callback(status);\n  }, 100);\n}\n\n// 定义一个回调函数，用于处理披萨准备好的情况\nfunction enjoyPizza(status) {\n  console.log(\"现在披萨的状态是:\", status);\n}\n\n// 调用函数，并传入回调\npreparePizza(enjoyPizza);\n// 解释：我们将处理结果的逻辑（enjoyPizza）作为参数传给异步函数。\n// 当异步操作完成时，它会主动调用我们传入的函数，确保了时序的正确性。", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-1-2-事件循环机制.md", "blockIndex": 3}
{"id": "js-sec-5-1-2", "title": "事件循环机制", "code": "// Level 4: 太空探索任务计时器\n\nfunction startSpacewalkMission(totalTime, returnWindowStart) {\n  console.log(\"👩‍🚀 AI: 任务开始！太空行走总时长:\", totalTime, \"秒。\");\n  console.log(\"------------------------------------------\");\n\n  let missionStatus = \"进行中\";\n\n  // 1. 设置任务结束的宏任务（最外层的定时器）\n  setTimeout(() => {\n    if (missionStatus === \"进行中\") {\n      missionStatus = \"失败\";\n      console.log(\"💥 AI: 时间耗尽！宇航员未能及时返回！任务失败！\");\n    }\n  }, totalTime * 1000);\n\n  // 2. 设置“返回窗口期”开始的宏任务\n  setTimeout(() => {\n    console.log(\"🟡 AI: 警告！返回窗口期开启！请在倒计时结束前返回！\");\n    missionStatus = \"等待返回\";\n  }, returnWindowStart * 1000);\n\n  // 3. 模拟宇航员的操作\n  function astronautAction(actionTime) {\n    // 宇航员的行动也是一个异步事件\n    setTimeout(() => {\n      console.log(`\\n🧑‍🚀 宇航员在第 ${actionTime} 秒按下“紧急返回”按钮...`);\n      // 使用Promise（微任务）来立即处理宇航员的行动结果\n      Promise.resolve().then(() => {\n        if (missionStatus === \"等待返回\") {\n          missionStatus = \"成功\";\n          console.log(\"✅ AI: 时机完美！宇航员安全返回！任务成功！\");\n        } else if (missionStatus === \"进行中\") {\n          missionStatus = \"提前返回\";\n          console.log(\"🤔 AI: 宇航员提前返回，虽然安全，但未完成所有勘探任务。\");\n        }\n      });\n    }, actionTime * 1000);\n  }\n\n  // --- 模拟场景 ---\n  // 场景A: 宇航员在窗口期内正确返回\n  astronautAction(8);\n\n  // 场景B: (可以取消注释来测试) 宇航员返回太早\n  // astronautAction(3);\n\n  // 场景C: (可以取消注释来测试) 宇航员返回太晚 (此场景下任务会超时失败)\n  // astronautAction(11);\n}\n\n// 任务总时长10秒，返回窗口从第5秒开始\nstartSpacewalkMission(10, 5);", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-1-2-事件循环机制.md", "blockIndex": 4}
{"id": "js-sec-5-1-3", "title": "定时器（setTimeout/setInterval）", "code": "// Level 1: 最简单的setTimeout示例\n\nconsole.log(\"指令员：火箭准备发射！倒计时开始...\");\n\n// 设置一个2秒后执行的“一次性闹钟”\nsetTimeout(() => {\n  // 这部分代码将在2秒后执行\n  console.log(\"🚀 发射！火箭成功升空！\");\n}, 2000); // 2000毫秒 = 2秒\n\nconsole.log(\"指令已发出，正在等待倒计时结束...\");\n// 注意：这行代码会立即执行，不会等待2秒\n// 执行结果顺序：\n// 1. \"指令员：火箭准备发射！倒计时开始...\"\n// 2. \"指令已发出，正在等待倒计时结束...\"\n// 3. (等待2秒后) \"🚀 发射！火箭成功升空！\"", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-1-3-定时器（setTimeout-setInterval）.md", "blockIndex": 0}
{"id": "js-sec-5-1-3", "title": "定时器（setTimeout/setInterval）", "code": "// Level 2, 特性1: setTimeout vs setInterval\n\n// --- setTimeout: 只在1秒后执行一次 ---\nconst oneTimeTaskId = setTimeout(() => {\n  console.log(\"【setTimeout】: 您的外卖到了，请查收！(此消息只提醒一次)\");\n}, 1000);\n// clearTimeout(oneTimeTaskId); // 如果想在执行前取消，可以调用这个\n\n\n// --- setInterval: 每秒执行一次，直到被清除 ---\nlet deliveryCount = 0;\nconst periodicTaskId = setInterval(() => {\n  deliveryCount++;\n  console.log(`【setInterval】: 第 ${deliveryCount} 份包裹正在派送中...`);\n\n  // 当派送3次后，停止派送，否则会一直执行下去\n  if (deliveryCount >= 3) {\n    clearInterval(periodicTaskId); // 非常重要：清除定时器，防止无限循环\n    console.log(\"【setInterval】: 所有包裹派送完毕！\");\n  }\n}, 1000);\n\nconsole.log(\"定时任务已启动，请关注控制台输出。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-1-3-定时器（setTimeout-setInterval）.md", "blockIndex": 1}
{"id": "js-sec-5-1-3", "title": "定时器（setTimeout/setInterval）", "code": "// Level 2, 特性2: 传递参数\n\nfunction greet(name, occasion) {\n  console.log(`你好, ${name}! 祝你在${occasion}玩得开心!`);\n}\n\n// 第三个及以后的参数，会作为greet函数的参数传入\n// setTimeout(要执行的函数, 延迟时间, 参数1, 参数2, ...)\nsetTimeout(greet, 1500, '爱丽丝', '代码乐园');\n\n// setInterval同样适用\nlet missionCount = 1;\nconst missionTimer = setInterval((agent, objective) => {\n  console.log(`特工 ${agent}, 你的第 ${missionCount} 个任务是: ${objective}`);\n  missionCount++;\n  if (missionCount > 2) {\n    clearInterval(missionTimer);\n    console.log(`特工 ${agent}, 所有任务已传达完毕。`);\n  }\n}, 2000, '007', '寻找黄金代码');\n\nconsole.log(\"参数传递示例已启动...\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-1-3-定时器（setTimeout-setInterval）.md", "blockIndex": 2}
{"id": "js-sec-5-1-3", "title": "定时器（setTimeout/setInterval）", "code": "// Level 3: 对比学习\n\nfunction showMessage(message) {\n  console.log(message);\n}\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误：直接调用了函数 showMessage(...)\n// 这会导致 showMessage 立即执行，它的返回值(undefined)被传给了setTimeout\n// 结果就是 \"紧急警报\" 立即被打印，而1秒后什么都不会发生\nsetTimeout(showMessage(\"❌ 紧急警报：这个消息会立即出现！\"), 1000);\nconsole.log(\"错误用法演示完毕，你会发现上面的消息没有延迟。\");\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确：使用箭头函数包装，确保 showMessage 在1秒后被调用\nsetTimeout(() => {\n  showMessage(\"✅ 系统正常：这个消息在1秒后出现。\");\n}, 1000);\n// ✅ 或者直接传递函数引用（如果不需要传递自定义参数）\nsetTimeout(showMessage, 2000, \"✅ 系统正常：这是另一种正确方式，在2秒后出现。\");\n\nconsole.log(\"正确用法已设置，请等待消息出现...\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-1-3-定时器（setTimeout-setInterval）.md", "blockIndex": 3}
{"id": "js-sec-5-1-3", "title": "定时器（setTimeout/setInterval）", "code": "// Level 4: 拆弹游戏\n\nconst BOMB_TIMER_SECONDS = 10;\nlet timeLeft = BOMB_TIMER_SECONDS;\n\nconsole.log(\"💥 警报！检测到脉冲炸弹！必须在10秒内拆除！\");\nconsole.log(\"启动拆弹倒计时...\");\n\n// 设置一个每秒运行一次的“心跳”定时器，作为炸弹的倒计时\nconst countdown = setInterval(() => {\n  timeLeft--;\n  console.log(`...滴...答... 剩余 ${timeLeft} 秒！`);\n\n  // 时间到了，炸弹爆炸\n  if (timeLeft <= 0) {\n    clearInterval(countdown); // 停止倒计时\n    console.log(\"💣💥 BOOM!!! 任务失败，时空结构已坍塌...\");\n  }\n}, 1000);\n\n// 拆弹函数：清除倒计时并宣布成功\nfunction defuseBomb() {\n  // 检查是否还有时间\n  if (timeLeft > 0) {\n    clearInterval(countdown); // 关键！停止爆炸倒计时！\n    console.log(`✅ 呼... 在最后 ${timeLeft} 秒成功拆除炸弹！你拯救了整个星系！`);\n  }\n}\n\n// 模拟玩家在第4秒时，找到了正确的引线并剪断了它\n// 我们用一个setTimeout来模拟这个“延迟”的英雄行为\nconst defuseTime = 4000; // 4秒后进行拆弹\nconsole.log(`你将在 ${defuseTime / 1000} 秒后尝试拆弹... 祝你好运！`);\nsetTimeout(defuseBomb, defuseTime);\n\n// 试着修改 defuseTime 的值，比如改成 11000 (11秒)，看看会发生什么？", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-1-3-定时器（setTimeout-setInterval）.md", "blockIndex": 4}
{"id": "js-sec-5-1-4", "title": "回调函数", "code": "// 服务员函数，接收订单和联系方式（回调函数）\nfunction placeOrder(dish, callback) {\n  console.log(`收到订单：一份香喷喷的 ${dish}！`);\n  console.log(\"厨房正在加急制作中...\");\n\n  // 模拟制作过程需要2秒\n  setTimeout(() => {\n    // 制作完成，调用回调函数通知顾客\n    const message = `${dish} 已经准备好了，请来取餐！`;\n    callback(message);\n  }, 2000);\n}\n\n// 顾客的联系方式（回调函数本身）\nfunction customerNotification(message) {\n  console.log(\"叮咚! 收到通知:\");\n  console.log(message);\n}\n\n// 顾客开始点餐，并把自己的联系方式告诉服务员\nplaceOrder(\"红烧JavaScript鱼\", customerNotification);\n\nconsole.log(\"我先去逛逛，做好了叫我。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-1-4-回调函数.md", "blockIndex": 0}
{"id": "js-sec-5-1-4", "title": "回调函数", "code": "function fetchDataFromServer(callback) {\n  console.log(\"正在向服务器请求数据...\");\n  // 模拟一个需要3秒的网络请求\n  setTimeout(() => {\n    const data = { userId: 1, content: \"Hello, Callback World!\" };\n    console.log(\"数据已成功获取！\");\n    // 数据回来后，调用回调函数处理数据\n    callback(data);\n  }, 3000);\n}\n\nfunction processData(data) {\n  console.log(\"接收到数据，开始处理...\");\n  console.log(`用户ID: ${data.userId}, 内容: \"${data.content}\"`);\n}\n\nfetchDataFromServer(processData);\n\nconsole.log(\"请求已发送，程序不会卡在这里，可以继续执行其他任务。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-1-4-回调函数.md", "blockIndex": 1}
{"id": "js-sec-5-1-4", "title": "回调函数", "code": "function processArray(arr, processor) {\n  const results = [];\n  for (let i = 0; i < arr.length; i++) {\n    // 使用传入的 processor 回调函数来处理每个元素\n    results.push(processor(arr[i]));\n  }\n  return results;\n}\n\n// “插件1”：将每个数字翻倍\nfunction double(num) {\n  return num * 2;\n}\n\n// “插件2”：将每个数字转为描述性字符串\nfunction describe(num) {\n  return `这是一个神奇的数字: ${num}`;\n}\n\nconst numbers = [1, 2, 3, 4];\n\n// 使用 double 插件\nconst doubledNumbers = processArray(numbers, double);\nconsole.log(\"使用'翻倍'插件:\", doubledNumbers);\n\n// 使用 describe 插件\nconst describedNumbers = processArray(numbers, describe);\nconsole.log(\"使用'描述'插件:\", describedNumbers);", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-1-4-回调函数.md", "blockIndex": 2}
{"id": "js-sec-5-1-4", "title": "回调函数", "code": "function executeAfterDelay(callback) {\n  console.log(\"准备在2秒后执行回调...\");\n  setTimeout(callback, 2000);\n}\n\nfunction myCallback() {\n  console.log(\"回调函数被成功执行了！\");\n}\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误：传入了 myCallback() 的 *执行结果* (即 undefined)，而不是函数本身\n// 这会导致 myCallback 立即执行，而 setTimeout 收到的是 undefined，什么都不会发生\nexecuteAfterDelay(myCallback());\nconsole.log(\"错误演示中，上面那行代码会立即打印回调内容，而不是等待2秒。\");\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确：传入 myCallback 这个 *函数引用*\n// setTimeout 会在2秒后拿到这个函数引用并执行它\nexecuteAfterDelay(myCallback);\nconsole.log(\"正确演示中，请等待2秒查看回调结果。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-1-4-回调函数.md", "blockIndex": 3}
{"id": "js-sec-5-1-4", "title": "回调函数", "code": "/**\n * 魔法锻造台：尝试升级装备\n * @param {string} itemName - 要升级的装备名称\n * @param {function} onSuccess - 升级成功时调用的回调\n * @param {function} onFailure - 升级失败时调用的回调\n */\nfunction attemptUpgrade(itemName, onSuccess, onFailure) {\n  console.log(`代码勇士将【${itemName}】放入了魔法锻造台...`);\n  console.log(\"锻造台发出神秘的光芒，开始进行强化... (请稍候)\");\n\n  // 模拟一个耗时且有风险的升级过程\n  setTimeout(() => {\n    const isSuccess = Math.random() > 0.5; // 50% 的成功率\n\n    if (isSuccess) {\n      // 成功了！调用成功回调\n      onSuccess(itemName);\n    } else {\n      // 失败了！调用失败回调\n      onFailure(itemName);\n    }\n  }, 3000);\n}\n\n// 准备好处理成功情况的“庆祝仪式”\nfunction celebrateSuccess(item) {\n  console.log(`🎉 哇！【${item}】升级成功！光芒四射，威力大增！`);\n  console.log(\"代码勇士的攻击力 +100！\");\n}\n\n// 准备好处理失败情况的“安慰话语”\nfunction mournFailure(item) {\n  console.log(`💥 啊哦...一阵黑烟冒出，【${item}】升级失败了...`);\n  console.log(\"代码勇士叹了口气：没关系，下次再来！\");\n}\n\n// 开始升级！把成功和失败的处理方案都告诉锻造台\nattemptUpgrade(\"语法圣剑\", celebrateSuccess, mournFailure);\n\nconsole.log(\"升级结果将在3秒后揭晓，代码勇士正在紧张地搓手手...\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-1-4-回调函数.md", "blockIndex": 4}
{"id": "js-sec-5-2-1", "title": "Promise基础", "code": "// 创建一个外卖订单（Promise），承诺2秒后送到\nconst myOrder = new Promise((resolve, reject) => {\n  console.log(\"👨‍🍳 厨房正在准备您的披萨...\");\n  setTimeout(() => {\n    // 2秒后，披萨做好了！\n    resolve(\"🍕 热腾腾的披萨\"); \n  }, 2000);\n});\n\nconsole.log(\"🧾 订单已提交，等待厨房确认...\");\n\n// .then() 指定披萨送到后（Promise fulfilled）要做什么\nmyOrder.then((pizza) => {\n  console.log(`耶！收到了我的 ${pizza}，准备开吃！`);\n});\n\n// 输出顺序:\n// 1. \"🧾 订单已提交，等待厨房确认...\" (立即执行)\n// 2. \"👨‍🍳 厨房正在准备您的披萨...\" (立即执行)\n// 3. (等待2秒)\n// 4. \"耶！收到了我的 🍕 热腾腾的披萨，准备开吃！\" (2秒后执行)", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-1-Promise基础.md", "blockIndex": 0}
{"id": "js-sec-5-2-1", "title": "Promise基础", "code": "// 模拟一个可能会成功的任务\nconst successfulTask = new Promise((resolve, reject) => {\n  console.log(\"开始执行一个【注定成功】的任务...\");\n  setTimeout(() => {\n    resolve({ success: true, data: \"一些重要数据\" });\n  }, 1000);\n});\n\nsuccessfulTask\n  .then(result => {\n    console.log(\"✅ 成功:\", result);\n  })\n  .catch(error => {\n    console.log(\"❌ 失败:\", error); // 这段代码不会执行\n  });\n\n\n// 模拟一个可能会失败的任务\nconst failedTask = new Promise((resolve, reject) => {\n  console.log(\"开始执行一个【注定失败】的任务...\");\n  setTimeout(() => {\n    reject(new Error(\"网络连接中断\"));\n  }, 2000);\n});\n\nfailedTask\n  .then(result => {\n    console.log(\"✅ 成功:\", result); // 这段代码不会执行\n  })\n  .catch(error => {\n    // Error对象会打印出更详细的堆栈信息\n    console.log(\"❌ 失败:\", error.message); \n  });", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-1-Promise基础.md", "blockIndex": 1}
{"id": "js-sec-5-2-1", "title": "Promise基础", "code": "// 模拟一个多步骤的操作：1. 获取用户ID -> 2. 根据ID获取用户信息\nfunction getUserId() {\n  return new Promise((resolve) => {\n    console.log(\"步骤1: 开始获取用户ID...\");\n    setTimeout(() => {\n      const userId = 123;\n      console.log(\"步骤1: 成功获取用户ID:\", userId);\n      resolve(userId);\n    }, 1000);\n  });\n}\n\nfunction getUserInfo(id) {\n  return new Promise((resolve) => {\n    console.log(`步骤2: 开始根据ID [${id}] 获取用户信息...`);\n    setTimeout(() => {\n      const userInfo = { name: \"Alice\", age: 30 };\n      console.log(\"步骤2: 成功获取用户信息:\", userInfo);\n      resolve(userInfo);\n    }, 1000);\n  });\n}\n\n// 链式调用\ngetUserId()\n  .then(id => {\n    // 从上一个 .then() 接收到 id\n    // 返回一个新的 Promise，这个 Promise 的结果将被下一个 .then() 接收\n    return getUserInfo(id);\n  })\n  .then(info => {\n    // 从上一个 .then() (即 getUserInfo) 接收到 info\n    console.log(\"🎉 最终结果:\", `欢迎, ${info.name}!`);\n  })\n  .catch(error => {\n    console.error(\"处理流程出现错误:\", error);\n  });", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-1-Promise基础.md", "blockIndex": 2}
{"id": "js-sec-5-2-1", "title": "Promise基础", "code": "console.log(\"=== 错误用法 ===\");\n// ❌ 错误做法：在 .then() 中嵌套，形成回调地狱\nfunction fetchUserDataNested() {\n  return new Promise(resolve => setTimeout(() => resolve(101), 500));\n}\nfunction fetchUserPostsNested(userId) {\n  return new Promise(resolve => setTimeout(() => resolve([`Post A by ${userId}`, `Post B by ${userId}`]), 500));\n}\n\nfetchUserDataNested().then(userId => {\n  console.log(`获取到用户ID: ${userId}`);\n  // 嵌套的 .then() 使代码向右缩进，难以阅读\n  fetchUserPostsNested(userId).then(posts => {\n    console.log(\"获取到用户文章:\", posts);\n  });\n});\n// 解释：这种写法虽然能工作，但如果再多几层异步操作，就会形成“回调地狱”（Pyramid of Doom），\n// 错误处理也变得复杂，每一层都可能需要自己的 .catch()。\n\n\n// 等待上面的代码执行完\nsetTimeout(() => {\n  console.log(\"\\n=== 正确用法 ===\");\n  // ✅ 正确做法：使用扁平化的链式调用\n  function fetchUserDataChained() {\n    return new Promise(resolve => setTimeout(() => resolve(202), 500));\n  }\n  function fetchUserPostsChained(userId) {\n    return new Promise(resolve => setTimeout(() => resolve([`Post X by ${userId}`, `Post Y by ${userId}`]), 500));\n  }\n\n  fetchUserDataChained()\n    .then(userId => {\n      console.log(`获取到用户ID: ${userId}`);\n      // 关键：返回下一个Promise，而不是嵌套它\n      return fetchUserPostsChained(userId);\n    })\n    .then(posts => {\n      // 这个 .then() 处理的是 fetchUserPostsChained 的结果\n      console.log(\"获取到用户文章:\", posts);\n    })\n    .catch(error => {\n      // 单一的 .catch() 可以捕获链条中任何一个环节的错误\n      console.error(\"链式调用中发生错误:\", error);\n    });\n  // 解释：代码是扁平的，从上到下执行，非常清晰。\n  // 任何一步的失败都会被最后的 .catch() 捕获，便于统一错误处理。\n}, 2000);\n", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-1-Promise基础.md", "blockIndex": 3}
{"id": "js-sec-5-2-1", "title": "Promise基础", "code": "// 模拟探测器发射流程\n\n/**\n * 阶段1: 系统自检\n * @returns {Promise<string>}\n */\nfunction systemCheck() {\n  return new Promise((resolve, reject) => {\n    console.log(\"🚀 [阶段1] 开始系统自检...\");\n    setTimeout(() => {\n      if (Math.random() > 0.1) { // 90% 成功率\n        resolve(\"✅ 系统自检通过，所有参数正常。\");\n      } else {\n        reject(\"❌ 系统自检失败：主引擎控制器无响应！\");\n      }\n    }, 1000);\n  });\n}\n\n/**\n * 阶段2: 燃料加注\n * @param {string} checkResultMessage - 上一阶段的结果信息\n * @returns {Promise<string>}\n */\nfunction fuelEngines(checkResultMessage) {\n  return new Promise((resolve, reject) => {\n    console.log(checkResultMessage); // 打印上一阶段的信息\n    console.log(\"⛽ [阶段2] 开始加注液氢燃料...\");\n    setTimeout(() => {\n      if (Math.random() > 0.15) { // 85% 成功率\n        resolve(\"✅ 燃料加注完成，引擎已预热。\");\n      } else {\n        reject(\"❌ 燃料加注失败：检测到燃料泄漏！\");\n      }\n    }, 1500);\n  });\n}\n\n/**\n * 阶段3: 启动点火程序\n * @param {string} fuelResultMessage - 上一阶段的结果信息\n * @returns {Promise<string>}\n */\nfunction startIgnition(fuelResultMessage) {\n  return new Promise((resolve) => {\n    console.log(fuelResultMessage);\n    console.log(\"🔥 [阶段3] 启动主引擎点火程序... 倒计时 3... 2... 1...\");\n    setTimeout(() => {\n      resolve(\"🛰️ 点火成功！探测器已升空，飞向星辰大海！\");\n    }, 1000);\n  });\n}\n\n// --- 执行发射任务 ---\nconsole.log(\"--- 探测器发射任务启动 ---\");\nsystemCheck()\n  .then(result1 => fuelEngines(result1))\n  .then(result2 => startIgnition(result2))\n  .then(finalMessage => {\n    console.log(\"🎉🎉🎉 任务成功! 🎉🎉🎉\");\n    console.log(finalMessage);\n  })\n  .catch(errorMessage => {\n    console.error(\"💥💥💥 任务失败! 💥💥💥\");\n    console.error(\"原因:\", errorMessage);\n    console.log(\"地面控制中心正在分析故障...\");\n  });\n\n// 提示：可以多次运行此代码块，看看不同的成功或失败结果！", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-1-Promise基础.md", "blockIndex": 4}
{"id": "js-sec-5-2-2", "title": "then/catch/finally", "code": "// 创建一个模拟网络请求的Promise，它会在1秒后成功\nconst orderPizzaPromise = new Promise((resolve, reject) => {\n  console.log(\"正在下单披萨...\");\n  setTimeout(() => {\n    // 模拟成功，并返回结果\n    resolve(\"热腾腾的玛格丽特披萨🍕\");\n  }, 1000);\n});\n\n// 使用 .then() 来处理成功的结果\norderPizzaPromise.then(pizza => {\n  console.log(\"订单成功！我收到了: \" + pizza);\n  console.log(\"开吃！\");\n});\n\n// 输出:\n// 正在下单披萨...\n// (1秒后)\n// 订单成功！我收到了: 热腾腾的玛格丽特披萨🍕\n// 开吃！", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-2-then-catch-finally.md", "blockIndex": 0}
{"id": "js-sec-5-2-2", "title": "then/catch/finally", "code": "// 模拟一个多步骤的烹饪过程\nnew Promise((resolve, reject) => {\n  console.log(\"第一步：准备食材...\");\n  setTimeout(() => resolve(\"切好的蔬菜\"), 1000);\n})\n.then(ingredients => {\n  console.log(`拿到了: ${ingredients}。`);\n  console.log(\"第二步：开始烹饪...\");\n  // 返回一个新的值给下一个.then()\n  return `${ingredients} 和 炒锅`; \n})\n.then(toolsAndIngredients => {\n  console.log(`现在我们有: ${toolsAndIngredients}。`);\n  console.log(\"第三步：装盘！\");\n  return \"一盘美味的炒蔬菜\";\n})\n.then(dish => {\n  console.log(`任务完成！我们做好了: ${dish} 🍽️`);\n});\n\n// 输出:\n// 第一步：准备食材...\n// (1秒后)\n// 拿到了: 切好的蔬菜。\n// 第二步：开始烹饪...\n// 现在我们有: 切好的蔬菜 和 炒锅。\n// 第三步：装盘！\n// 任务完成！我们做好了: 一盘美味的炒蔬菜 🍽️", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-2-then-catch-finally.md", "blockIndex": 1}
{"id": "js-sec-5-2-2", "title": "then/catch/finally", "code": "// 模拟一个可能会失败的操作\nconst mightFailPromise = new Promise((resolve, reject) => {\n  console.log(\"正在尝试一个危险操作...\");\n  setTimeout(() => {\n    // 模拟一个随机的成功或失败\n    if (Math.random() > 0.5) {\n      resolve(\"操作成功！获得了宝藏！\");\n    } else {\n      reject(new Error(\"操作失败！触发了陷阱！\"));\n    }\n  }, 1000);\n});\n\nmightFailPromise\n  .then(successMessage => {\n    console.log(\"成功回调:\", successMessage);\n  })\n  .catch(error => {\n    console.error(\"失败回调:\", error.message);\n  })\n  .finally(() => {\n    console.log(\"最终操作: 无论如何，都要记录本次操作。\");\n  });\n\n// 可能的输出 1 (成功):\n// 正在尝试一个危险操作...\n// (1秒后)\n// 成功回调: 操作成功！获得了宝藏！\n// 最终操作: 无论如何，都要记录本次操作。\n\n// 可能的输出 2 (失败):\n// 正在尝试一个危险操作...\n// (1秒后)\n// 失败回调: 操作失败！触发了陷阱！\n// 最终操作: 无论如何，都要记录本次操作。", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-2-then-catch-finally.md", "blockIndex": 2}
{"id": "js-sec-5-2-2", "title": "then/catch/finally", "code": "console.log(\"=== 错误用法 ===\");\n// ❌ 错误做法：使用 .then(null, onRejected)\n// 这种方式无法捕获第一个 .then() 成功回调内部抛出的新错误\nnew Promise((resolve, reject) => {\n  resolve(\"一切正常\");\n})\n.then(\n  result => {\n    console.log(\"成功回调执行:\", result);\n    // 在成功回调中手动抛出一个新错误\n    throw new Error(\"成功回调里出了个新问题！\");\n  },\n  error => {\n    // 这个错误处理函数永远不会被调用\n    console.error(\"这个处理函数不会执行，因为Promise是成功的\", error.message);\n  }\n)\n.then(() => {\n    console.log(\"这个 then 也不会执行\");\n});\n// 最终，这个错误会变成未捕获的异常 (Uncaught Error)\n\n\nsetTimeout(() => {\n  console.log(\"\\n=== 正确用法 ===\");\n  // ✅ 正确做法：使用 .catch()\n  // .catch() 可以捕获它前面所有 .then() 中发生的任何错误\n  new Promise((resolve, reject) => {\n    resolve(\"一切正常\");\n  })\n  .then(result => {\n    console.log(\"成功回调执行:\", result);\n    // 同样，在成功回调中手动抛出一个新错误\n    throw new Error(\"成功回调里出了个新问题！\");\n  })\n  .catch(error => {\n    // 这个错误被 .catch() 成功捕获！\n    console.error(\"错误被 .catch() 捕获:\", error.message);\n  });\n}, 1000);\n\n// 输出:\n// === 错误用法 ===\n// 成功回调执行: 一切正常\n// (之后会有一个 Uncaught Error 报错)\n// \n// === 正确用法 ===\n// 成功回调执行: 一切正常\n// 错误被 .catch() 捕获: 成功回调里出了个新问题！", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-2-then-catch-finally.md", "blockIndex": 3}
{"id": "js-sec-5-2-2", "title": "then/catch/finally", "code": "// 模拟发射探测器\nfunction launchProbe() {\n  console.log(\"🚀 发射探测器... 目标：未知行星 Gliese 581g\");\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (Math.random() > 0.2) {\n        resolve(\"探测器成功着陆！\");\n      } else {\n        reject(new Error(\"发射失败，探测器在小行星带失联！\"));\n      }\n    }, 1000);\n  });\n}\n\n// 模拟扫描行星\nfunction scanPlanet(landingStatus) {\n  console.log(`🛰️ 状态: ${landingStatus} 开始扫描行星...`);\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (Math.random() > 0.3) {\n        resolve({ status: \"扫描完成\", mineral: \"超能量晶体\" });\n      } else {\n        reject(new Error(\"扫描仪被强电磁风暴损坏！\"));\n      }\n    }, 1000);\n  });\n}\n\n// 模拟分析样本\nfunction analyzeSample(scanResult) {\n  console.log(`🔬 分析中... 发现矿物: ${scanResult.mineral}`);\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(`分析报告：${scanResult.mineral} 纯度高达98.7%！价值连城！`);\n    }, 1000);\n  });\n}\n\n// --- 开始执行任务 ---\nlaunchProbe()\n  .then(scanPlanet)       // 发射成功后，扫描行星\n  .then(analyzeSample)    // 扫描成功后，分析样本\n  .then(finalReport => {  // 分析成功后，显示最终报告\n    console.log(`🎉 任务大成功！${finalReport}`);\n  })\n  .catch(error => {       // 链条中任何一步失败，都会在这里捕获\n    console.error(`💥 任务失败！原因: ${error.message}`);\n  })\n  .finally(() => {        // 无论成功或失败，都执行\n    console.log(\"📡 任务结束，与地球总部的通讯关闭。\");\n  });\n\n// 尝试多次运行，你会看到不同的任务结果！", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-2-then-catch-finally.md", "blockIndex": 4}
{"id": "js-sec-5-2-3", "title": "Promise链式调用", "code": "// 创建一个立即解决的Promise，值为10\nconst promise = Promise.resolve(10);\n\npromise\n  .then(value => {\n    // 第一个.then接收到值10\n    console.log(\"第一步: 接收到初始值\", value);\n    // 将值乘以2，并返回，传递给下一步\n    return value * 2;\n  })\n  .then(value => {\n    // 第二个.then接收到上一步返回的20\n    console.log(\"第二步: 接收到处理后的值\", value);\n    // 将值加上5\n    return value + 5;\n  })\n  .then(finalValue => {\n    // 第三个.then接收到最终值25\n    console.log(\"第三步: 得到最终结果\", finalValue);\n  });\n\n// 输出:\n// 第一步: 接收到初始值 10\n// 第二步: 接收到处理后的值 20\n// 第三步: 得到最终结果 25", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-3-Promise链式调用.md", "blockIndex": 0}
{"id": "js-sec-5-2-3", "title": "Promise链式调用", "code": "const startPromise = new Promise((resolve, reject) => {\n  console.log(\"开始处理...\");\n  setTimeout(() => {\n    resolve(\"数据A\");\n  }, 500);\n});\n\nstartPromise\n  .then(result1 => {\n    console.log(\"第一环: 拿到\", result1);\n    // 返回一个新值，传递给下一环\n    return \"数据B\";\n  })\n  .then(result2 => {\n    console.log(\"第二环: 拿到\", result2);\n    // 这里没有返回任何值\n  })\n  .then(result3 => {\n    console.log(\"第三环: 拿到\", result3); // 因为上一环没有返回，所以这里是undefined\n  });\n\n// 输出:\n// 开始处理...\n// (等待500ms后)\n// 第一环: 拿到 数据A\n// 第二环: 拿到 数据B\n// 第三环: 拿到 undefined", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-3-Promise链式调用.md", "blockIndex": 1}
{"id": "js-sec-5-2-3", "title": "Promise链式调用", "code": "// 模拟一个异步操作：获取用户信息\nfunction fetchUser(userId) {\n  console.log(`正在获取用户 ${userId} 的信息...`);\n  return new Promise(resolve => {\n    setTimeout(() => {\n      console.log(`✅ 用户 ${userId} 信息获取成功!`);\n      resolve({ id: userId, name: \"Alice\" });\n    }, 1000);\n  });\n}\n\n// 模拟另一个异步操作：获取用户文章\nfunction fetchPosts(user) {\n  console.log(`正在获取用户 ${user.name} 的文章...`);\n  return new Promise(resolve => {\n    setTimeout(() => {\n      console.log(`✅ 用户 ${user.name} 的文章获取成功!`);\n      resolve([\"文章1\", \"文章2\"]);\n    }, 1000);\n  });\n}\n\n// 链式调用\nfetchUser(101)\n  .then(user => {\n    // 第一个then接收到用户信息\n    // 然后返回一个新的Promise来获取文章\n    return fetchPosts(user);\n  })\n  .then(posts => {\n    // 第二个then会等待fetchPosts完成后，接收到文章数据\n    console.log(\"最终拿到的文章列表:\", posts);\n  });\n\n// 输出:\n// 正在获取用户 101 的信息...\n// (等待1秒)\n// ✅ 用户 101 信息获取成功!\n// 正在获取用户 Alice 的文章...\n// (再等待1秒)\n// ✅ 用户 Alice 的文章获取成功!\n// 最终拿到的文章列表: [ '文章1', '文章2' ]", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-3-Promise链式调用.md", "blockIndex": 2}
{"id": "js-sec-5-2-3", "title": "Promise链式调用", "code": "// 模拟一个异步函数\nfunction asyncOperation(step, delay) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      console.log(`步骤 ${step} 完成`);\n      resolve(`结果 ${step}`);\n    }, delay);\n  });\n}\n\nconsole.log(\"=== 错误用法：嵌套Promise ===\");\n// ❌ 错误做法：在.then内部嵌套另一个.then\n// 这导致代码缩进越来越深，难以阅读和维护，也叫\"Promise Hell\"\nasyncOperation(1, 500).then(result1 => {\n  asyncOperation(2, 500).then(result2 => {\n    asyncOperation(3, 500).then(result3 => {\n      console.log(\"嵌套调用全部完成！\", result1, result2, result3);\n    });\n  });\n});\n// 这种结构难以进行统一的错误处理\n\nsetTimeout(() => {\n    console.log(\"\\n=== 正确用法：链式调用 ===\");\n    // ✅ 正确做法：使用扁平的链式结构\n    // 代码清晰，呈线性结构，易于理解\n    asyncOperation(1, 500)\n      .then(result1 => {\n        // 返回一个新的Promise，链条会自动等待它完成\n        return asyncOperation(2, 500);\n      })\n      .then(result2 => {\n        return asyncOperation(3, 500);\n      })\n      .then(result3 => {\n        console.log(\"链式调用全部完成！\");\n      })\n      .catch(error => {\n        // 任何一步出错，都会被这个catch捕获\n        console.error(\"链条中出现错误:\", error);\n      });\n}, 2000); // 延迟执行，以便和错误用法分开看\n\n\n// 输出:\n// === 错误用法：嵌套Promise ===\n// (等待500ms)\n// 步骤 1 完成\n// (再等待500ms)\n// 步骤 2 完成\n// (再等待500ms)\n// 步骤 3 完成\n// 嵌套调用全部完成！ 结果 1 结果 2 结果 3\n//\n// === 正确用法：链式调用 ===\n// (等待500ms)\n// 步骤 1 完成\n// (再等待500ms)\n// 步骤 2 完成\n// (再等待500ms)\n// 步骤 3 完成\n// 链式调用全部完成！", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-3-Promise链式调用.md", "blockIndex": 3}
{"id": "js-sec-5-2-3", "title": "Promise链式调用", "code": "// 模拟异步操作：在草丛里寻找小精灵\nfunction findPokemon() {\n  console.log(\" trainer: 好的，开始在草丛里搜寻... 🌿\");\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const found = Math.random() > 0.3; // 70% 概率找到\n      if (found) {\n        const pokemon = { name: \"皮卡丘\", level: 1 };\n        console.log(` trainer: 找到了！是一只 Lv.${pokemon.level} 的 ${pokemon.name}! ⚡️`);\n        resolve(pokemon);\n      } else {\n        console.log(\" trainer: 哎呀，什么都没找到...下次再来吧。\");\n        reject(\"未找到小精灵\");\n      }\n    }, 1500);\n  });\n}\n\n// 模拟异步操作：训练小精灵提升等级\nfunction trainPokemon(pokemon) {\n  console.log(` trainer: 开始训练 ${pokemon.name}... (ง •̀_•́)ง`);\n  return new Promise(resolve => {\n    setTimeout(() => {\n      pokemon.level += 5;\n      console.log(` trainer: 训练结束！${pokemon.name} 升到了 Lv.${pokemon.level}! ✨`);\n      resolve(pokemon);\n    }, 2000);\n  });\n}\n\n// 模拟异步操作：尝试进化\nfunction evolvePokemon(pokemon) {\n  console.log(` trainer: ${pokemon.name} 身上发出了耀眼的光芒... क्या?`);\n  return new Promise(resolve => {\n    setTimeout(() => {\n      if (pokemon.level >= 5) {\n        pokemon.name = \"雷丘\";\n        console.log(` trainer: 恭喜！${pokemon.name} 进化成功！变成了 ${pokemon.name}! 🏆`);\n        resolve(pokemon);\n      } else {\n        console.log(` trainer: 光芒消失了...看来等级还不够。`);\n        resolve(pokemon); // 即使没进化，也把当前状态传下去\n      }\n    }, 1500);\n  });\n}\n\n// --- 开始我们的冒险之旅 ---\nfindPokemon()\n  .then(pokemon => {\n    // 找到后，进行训练，返回训练的Promise\n    return trainPokemon(pokemon);\n  })\n  .then(trainedPokemon => {\n    // 训练完后，尝试进化，返回进化的Promise\n    return evolvePokemon(trainedPokemon);\n  })\n  .then(finalPokemon => {\n    // 进化结束后，展示最终状态\n    console.log(`\\n--- 冒险日志 ---`);\n    console.log(`最终伙伴: ${finalPokemon.name}`);\n    console.log(`等级: ${finalPokemon.level}`);\n    console.log(` trainer: 我们成为了更强的伙伴！🎉`);\n  })\n  .catch(error => {\n    // 如果在findPokemon步骤失败，链条会直接跳到这里\n    console.error(`\\n--- 冒险日志 ---`);\n    console.error(`本次冒险失败: ${error}`);\n  });", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-3-Promise链式调用.md", "blockIndex": 4}
{"id": "js-sec-5-2-4", "title": "Promise.all/race", "code": "// 创建两个模拟异步操作的Promise\nconst promise1 = new Promise((resolve) => {\n  setTimeout(() => resolve(\"任务1完成\"), 200);\n});\n\nconst promise2 = new Promise((resolve) => {\n  setTimeout(() => resolve(\"任务2完成\"), 500);\n});\n\n// Promise.all: 等待所有Promise都完成\nPromise.all([promise1, promise2])\n  .then((results) => {\n    console.log(\"Promise.all 结果:\", results); // 输出: [\"任务1完成\", \"任务2完成\"]\n  });\n\n// Promise.race: 只等待第一个完成的Promise\nPromise.race([promise1, promise2])\n  .then((result) => {\n    console.log(\"Promise.race 结果:\", result); // 输出: \"任务1完成\" (因为它更快)\n  });", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-4-Promise.all-race.md", "blockIndex": 0}
{"id": "js-sec-5-2-4", "title": "Promise.all/race", "code": "// 模拟一个会成功的下载任务\nfunction createSuccessPromise(name, delay) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      console.log(`${name} 下载成功!`);\n      resolve(`${name}的数据`);\n    }, delay);\n  });\n}\n\n// 模拟一个会失败的下载任务\nfunction createFailurePromise(name, delay) {\n  return new Promise((_, reject) => {\n    setTimeout(() => {\n      console.log(`${name} 下载失败!`);\n      reject(`${name}的网络错误`);\n    }, delay);\n  });\n}\n\n// 场景1: 所有都成功\nconst allSuccessPromises = [\n  createSuccessPromise('图片', 300),\n  createSuccessPromise('音频', 500),\n  createSuccessPromise('文档', 100)\n];\n\nPromise.all(allSuccessPromises)\n  .then(results => console.log(\"✅ 全部成功，收到的数据:\", results))\n  .catch(error => console.error(\"❌ 不应该执行到这里:\", error));\n\n\n// 场景2: 其中一个失败\nconst oneFailurePromises = [\n  createSuccessPromise('图片', 300),\n  createFailurePromise('音频', 200), // 这个会最快失败\n  createSuccessPromise('文档', 400)\n];\n\nPromise.all(oneFailurePromises)\n  .then(results => console.log(\"✅ 不应该执行到这里:\", results))\n  .catch(error => console.error(\"❌ 其中一个失败，Promise.all立即失败:\", error));", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-4-Promise.all-race.md", "blockIndex": 1}
{"id": "js-sec-5-2-4", "title": "Promise.all/race", "code": "function createPromise(name, delay, shouldSucceed = true) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (shouldSucceed) {\n        console.log(`${name} 第一个冲过终点! (成功)`);\n        resolve(`${name}赢了!`);\n      } else {\n        console.log(`${name} 第一个冲过终点! (但失败了)`);\n        reject(`${name}摔倒了!`);\n      }\n    }, delay);\n  });\n}\n\n// 场景1: 最快的是一个成功的Promise\nconst fastestIsSuccess = [\n  createPromise('慢悠悠的乌龟', 1000, true),\n  createPromise('敏捷的兔子', 100, true),\n  createPromise('沉睡的猫', 2000, true)\n];\n\nPromise.race(fastestIsSuccess)\n  .then(winner => console.log(\"🏆 比赛结果:\", winner))\n  .catch(error => console.error(\"💥 比赛意外:\", error));\n\n// 场景2: 最快的是一个失败的Promise\nconst fastestIsFailure = [\n  createPromise('稳健的大象', 500, true),\n  createPromise('鲁莽的猎豹', 200, false), // 这个最快，但是会失败\n  createPromise('飞翔的鹰', 600, true)\n];\n\nPromise.race(fastestIsFailure)\n  .then(winner => console.log(\"🏆 比赛结果:\", winner))\n  .catch(error => console.error(\"💥 比赛意外:\", error));", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-4-Promise.all-race.md", "blockIndex": 2}
{"id": "js-sec-5-2-4", "title": "Promise.all/race", "code": "function createAsyncTask(shouldFail = false) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (shouldFail) {\n        reject(\"数据库连接超时!\");\n      } else {\n        resolve(\"数据加载成功\");\n      }\n    }, 200);\n  });\n}\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误: 没有使用 .catch() 来处理潜在的失败\n// 当 createAsyncTask(true) 失败时，会产生一个未捕获的Promise拒绝错误。\nconst promisesWithError = [\n  createAsyncTask(),\n  createAsyncTask(true), // 这个会失败\n];\n\nPromise.all(promisesWithError).then(results => {\n  console.log(\"错误用法下的结果(永远不会执行):\", results);\n});\n// 浏览器控制台会报错: Uncaught (in promise) 数据库连接超时!\nconsole.error(\"❌ 错误用法: 如果没有.catch，当Promise.all失败时，错误将无法被捕获，可能导致程序异常。\");\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确: 总是为Promise链添加 .catch() 来优雅地处理错误\nconst promisesForCorrectUsage = [\n  createAsyncTask(),\n  createAsyncTask(true), // 这个会失败\n];\n\nPromise.all(promisesForCorrectUsage)\n  .then(results => {\n    console.log(\"正确用法下的成功结果(不会执行):\", results);\n  })\n  .catch(error => {\n    console.log(\"✅ 正确用法: 成功捕获到了错误!\", error);\n  });", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-4-Promise.all-race.md", "blockIndex": 3}
{"id": "js-sec-5-2-4", "title": "Promise.all/race", "code": "// 定义机器人探索函数，返回一个Promise\n// 每个机器人探索时间是随机的\nfunction launchExplorerBot(botName, planet) {\n  const explorationTime = Math.random() * 3000 + 500; // 随机探索时间 0.5-3.5秒\n  console.log(`🤖 ${botName} 已发射，目标：${planet}星球！`);\n  \n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      // 模拟10%的失败率\n      if (Math.random() > 0.9) {\n        console.log(`💥 ${botName} 在 ${planet} 遭遇小行星带，探索失败！`);\n        reject(`${botName}信号丢失`);\n      } else {\n        console.log(`🛰️ ${botName} 成功从 ${planet} 返回数据！耗时: ${(explorationTime/1000).toFixed(2)}s`);\n        resolve({\n          bot: botName,\n          planet: planet,\n          data: `来自${planet}的土壤样本`\n        });\n      }\n    }, explorationTime);\n  });\n}\n\n// 创建机器人探险任务列表\nconst bots = [\n  launchExplorerBot('AlphaBot', '火星'),\n  launchExplorerBot('BetaBot', '木星'),\n  launchExplorerBot('GammaBot', '土星')\n];\n\n// 目标1: 使用 Promise.all 等待所有机器人完成任务\nconsole.log(\"\\n--- [大赛监控中心] 等待所有机器人完成探索... ---\");\nPromise.all(bots)\n  .then(results => {\n    console.log(\"\\n🎉🎉🎉 [大赛结果] 所有机器人都已返航！大赛圆满成功！\");\n    results.forEach(r => {\n      console.log(`- ${r.bot} 带回了: ${r.data}`);\n    });\n  })\n  .catch(error => {\n    console.error(`\\n🚨🚨🚨 [大赛警报] 出现意外! ${error}，大赛被迫中止！`);\n  });\n\n// 目标2: 使用 Promise.race 找出最快返回的机器人\nconsole.log(\"\\n--- [先锋奖评选] 谁是第一个返回信号的英雄？ ---\");\nPromise.race(bots)\n  .then(firstBot => {\n    console.log(`\\n🏆🏆🏆 [先锋奖] 恭喜 ${firstBot.bot}！它第一个从 ${firstBot.planet} 返回信号，获得先锋奖！`);\n  })\n  .catch(error => {\n    // 注意：即使race失败，all仍然可能在进行中\n    console.warn(`\\n💔💔💔 [先锋奖评选] ${error}！最快的机器人不幸失联了...`);\n  });", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-4-Promise.all-race.md", "blockIndex": 4}
{"id": "js-sec-5-2-5", "title": "错误处理", "code": "// Level 1: 基本的 try...catch 结构\n\nconsole.log(\"程序开始运行...\");\n\ntry {\n  // 尝试执行一段可能会出错的代码\n  // 假设 aLiEnFunction 是一个不存在的函数\n  aLiEnFunction(); \n  console.log(\"这段代码不会被执行，因为它在错误之后。\");\n} catch (error) {\n  // 如果 try 代码块中发生错误，这里的代码就会被执行\n  console.log(\"噢不！捕获到了一个错误！\");\n  console.log(\"错误详情:\", error.message); // .message 是错误对象的一个属性\n}\n\nconsole.log(\"即使发生了错误，程序依然可以继续运行到这里。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-5-错误处理.md", "blockIndex": 0}
{"id": "js-sec-5-2-5", "title": "错误处理", "code": "// Level 2, Feature 1: finally 块\nfunction performTask(shouldThrowError) {\n  try {\n    console.log(\"🚀 开始执行任务...\");\n    if (shouldThrowError) {\n      throw new Error(\"任务执行中遇到意外的宇宙射线！\");\n    }\n    console.log(\"✅ 任务顺利完成！\");\n  } catch (error) {\n    console.log(\"💥 捕获到错误:\", error.message);\n  } finally {\n    // 无论是否出错，这里都会执行\n    console.log(\"🧹 正在进行任务收尾和清理工作...\");\n  }\n}\n\nconsole.log(\"--- 场景1: 任务成功 ---\");\nperformTask(false);\n\nconsole.log(\"\\n--- 场景2: 任务失败 ---\");\nperformTask(true);", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-5-错误处理.md", "blockIndex": 1}
{"id": "js-sec-5-2-5", "title": "错误处理", "code": "// Level 2, Feature 2: throw 自定义错误\nfunction calculateCircleArea(radius) {\n  if (typeof radius !== 'number' || radius < 0) {\n    // 如果半径不是一个正数，就抛出一个我们自定义的错误\n    throw new Error(\"半径必须是一个非负数！\");\n  }\n  return Math.PI * radius * radius;\n}\n\ntry {\n  // 尝试使用无效的半径\n  const area = calculateCircleArea(-5);\n  console.log(\"计算出的面积是:\", area);\n} catch (error) {\n  console.log(\"计算失败，原因:\", error.message);\n}\n\ntry {\n    // 尝试使用有效的半径\n    const validArea = calculateCircleArea(10);\n    console.log(\"有效半径计算出的面积是:\", validArea.toFixed(2));\n} catch(error) {\n    console.log(\"这里不应该执行，因为半径是有效的:\", error.message);\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-5-错误处理.md", "blockIndex": 2}
{"id": "js-sec-5-2-5", "title": "错误处理", "code": "// Level 3: 对比错误处理的有无\nfunction parseJsonData(jsonString) {\n  // JSON.parse 在解析无效字符串时会抛出错误\n  return JSON.parse(jsonString);\n}\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 不使用 try...catch，当遇到错误时，程序会中断（在某些环境中会直接崩溃）\ntry {\n    console.log(\"尝试解析一个错误的JSON...\");\n    const badData = parseJsonData(\"{'name': '小明', 'age': 18}\"); // 注意：JSON的键必须是双引号\n    console.log(\"解析结果:\", badData); // 这行代码不会执行\n} catch (e) {\n    console.log(\"在模拟的'错误用法'中，我们实际上捕获了它来展示效果。\");\n    console.log(\"若没有try...catch，程序到这里就会停止，下面的代码都不会运行。错误信息:\", e.message);\n}\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 使用 try...catch，优雅地处理错误，并让程序继续执行\ntry {\n  console.log(\"尝试用正确的方式解析错误的JSON...\");\n  const badData = parseJsonData(\"{'name': '小明', 'age': 18}\");\n  console.log(\"解析结果:\", badData);\n} catch (error) {\n  console.log(\"✅ 解析失败！但我们捕获了它。提供一个默认值或提示。\");\n  console.log(\"错误原因:\", error.message);\n  const defaultData = { name: \"游客\", age: 0 };\n  console.log(\"程序继续，使用默认数据:\", defaultData);\n}\n\nconsole.log(\"\\n程序可以继续执行其他任务...\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-5-错误处理.md", "blockIndex": 3}
{"id": "js-sec-5-2-5", "title": "错误处理", "code": "// Level 4: 外星语言翻译器\nfunction translateToKlingon(word, isDeviceOnline) {\n  console.log(`\\n--- 尝试翻译单词: \"${word}\" | 设备状态: ${isDeviceOnline ? '在线' : '离线'} ---`);\n  \n  // 模拟设备连接状态\n  if (!isDeviceOnline) {\n    throw new Error(\"翻译设备离线，无法连接到星际联邦网络！\");\n  }\n\n  const klingonDictionary = {\n    'hello': 'nuqneH',\n    'human': 'tera\\'ngan',\n    'ship': 'Duj',\n    'danger': 'Qo\\'',\n  };\n\n  const translation = klingonDictionary[word.toLowerCase()];\n\n  if (!translation) {\n    // 如果词典里没有这个词\n    throw new Error(`词汇库未收录单词 \"${word}\"。警告：不要乱说！`);\n  }\n\n  return translation;\n}\n\n// 主控程序：尝试使用翻译器\nfunction useTranslator(word, connectionStatus) {\n  try {\n    const result = translateToKlingon(word, connectionStatus);\n    console.log(`✅ 翻译成功! \"${word}\" 的克林贡语是: \"${result}\"`);\n  } catch (error) {\n    console.log(`👾 翻译模块警告: ${error.message}`);\n  } finally {\n    console.log(\"...翻译协议结束，通信信道关闭。\");\n  }\n}\n\n// 场景1: 成功翻译\nuseTranslator('hello', true);\n\n// 场景2: 翻译一个词典里没有的词\nuseTranslator('apple', true);\n\n// 场景3: 设备离线\nuseTranslator('ship', false);", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-2-5-错误处理.md", "blockIndex": 4}
{"id": "js-sec-5-3-1", "title": "async函数", "code": "// 定义一个async函数\nasync function getGreeting() {\n  // 即使我们返回一个普通的字符串...\n  return \"Hello, Async World!\";\n}\n\n// 调用async函数，它的返回值是一个Promise\nconst promise = getGreeting();\nconsole.log(\"调用async函数后立即得到的:\", promise);\n\n// 使用.then()来获取Promise成功后的结果\npromise.then(result => {\n  console.log(\"Promise resolved后的结果:\", result);\n});", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-1-async函数.md", "blockIndex": 0}
{"id": "js-sec-5-3-1", "title": "async函数", "code": "// 1. 返回一个非Promise值\nasync function getNumber() {\n  return 42; // 这个数字42会被包装成 Promise.resolve(42)\n}\n\ngetNumber().then(value => {\n  console.log(\"从getNumber获取的值:\", value);\n});\n\n// 2. 返回一个Promise\nasync function getDelayedMessage() {\n  // 直接返回一个现有的Promise\n  return new Promise(resolve => {\n    setTimeout(() => resolve(\"This message was delayed!\"), 1000);\n  });\n}\n\ngetDelayedMessage().then(message => {\n  console.log(\"从getDelayedMessage获取的消息:\", message);\n});\n\nconsole.log(\"async函数调用后，代码会继续执行...\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-1-async函数.md", "blockIndex": 1}
{"id": "js-sec-5-3-1", "title": "async函数", "code": "// 模拟一个需要2秒才能获取数据的API\nfunction fetchData() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve({ id: 1, name: \"Cosmo\", mission: \"Explore\" });\n    }, 2000);\n  });\n}\n\n// 使用async/await来处理这个异步操作\nasync function displayUserData() {\n  console.log(\"开始获取用户数据...\");\n  // await会暂停这里的执行，直到fetchData的Promise解决\n  const user = await fetchData(); \n  // Promise解决后，代码继续执行，user就是Promise的结果\n  console.log(\"数据获取成功!\");\n  console.log(`用户姓名: ${user.name}`);\n  console.log(`用户任务: ${user.mission}`);\n}\n\ndisplayUserData();\nconsole.log(\"displayUserData函数已调用，但内部的await会等待异步操作。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-1-async函数.md", "blockIndex": 2}
{"id": "js-sec-5-3-1", "title": "async函数", "code": "// 模拟一个异步获取用户名的函数\nasync function getUsername() {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(\"Galaxina\"), 500);\n  });\n}\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误：直接将async函数的返回值当作普通值使用\nconst usernamePromise = getUsername();\n// 这里打印出来的是一个待定的Promise对象，而不是字符串\"Galaxina\"\nconsole.log(`欢迎, ${usernamePromise}!`); \n// 解释：因为getUsername是异步的，它立即返回一个Promise，\n// 此时Promise内部的定时器还在运行，值尚未准备好。\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确：使用.then()或在另一个async函数中使用await\nasync function welcomeUser() {\n  console.log(\"准备欢迎用户...\");\n  const username = await getUsername(); // 等待Promise解决\n  console.log(`欢迎, ${username}!`); // 正确获取到值\n}\n\nwelcomeUser();\n// 解释：通过在另一个async函数中使用await，我们正确地暂停了代码，\n// 等待Promise完成后才使用它的结果，这符合异步编程的模式。", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-1-async函数.md", "blockIndex": 3}
{"id": "js-sec-5-3-1", "title": "async函数", "code": "// 模拟各种飞船子系统检查，每个都返回一个带延迟的Promise\nfunction checkEngine() {\n  console.log(\"🚀 正在检查引擎系统...\");\n  return new Promise(resolve => {\n    setTimeout(() => {\n      console.log(\"✅ 引擎系统正常！\");\n      resolve(true);\n    }, 1500);\n  });\n}\n\nfunction checkLifeSupport() {\n  console.log(\"🌬️ 正在检查生命支持系统...\");\n  return new Promise(resolve => {\n    setTimeout(() => {\n      console.log(\"✅ 生命支持系统正常！\");\n      resolve(true);\n    }, 2000);\n  });\n}\n\nfunction checkNavigation() {\n  console.log(\"🗺️ 正在校准导航系统...\");\n  // 模拟一个可能失败的检查\n  const isSuccess = Math.random() > 0.2; // 80%的成功率\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (isSuccess) {\n        console.log(\"✅ 导航系统校准完毕！\");\n        resolve(true);\n      } else {\n        console.error(\"❌ 导航系统校准失败！\");\n        reject(\"导航系统故障，无法连接至星图。\");\n      }\n    }, 1000);\n  });\n}\n\n// 主启动序列，使用async/await编排流程\nasync function launchSequence() {\n  try {\n    console.log(\"--- 飞船启动序列开始 ---\");\n    \n    const engineStatus = await checkEngine();\n    if (!engineStatus) throw new Error(\"引擎检查未通过\");\n\n    const lifeSupportStatus = await checkLifeSupport();\n    if (!lifeSupportStatus) throw new Error(\"生命支持检查未通过\");\n    \n    const navStatus = await checkNavigation();\n    if (!navStatus) throw new Error(\"导航检查未通过\");\n\n    console.log(\"\\n🎉 所有系统准备就绪！准备发射！\");\n    console.log(\"カウントダウン開始！3... 2... 1... 発射！🚀✨\");\n\n  } catch (error) {\n    console.error(\"\\n💥 发射中止！原因:\", error);\n    console.log(\"--- 请地面控制中心介入检查 ---\");\n  }\n}\n\n// 执行发射序列\nlaunchSequence();", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-1-async函数.md", "blockIndex": 4}
{"id": "js-sec-5-3-2", "title": "await表达式", "code": "// 模拟一个需要2秒才能完成的下载任务\nfunction simulateDownload() {\n  console.log(\"🚀 开始下载文件...\");\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(\"✅ 文件下载完成！\");\n    }, 2000); // 模拟2秒的延迟\n  });\n}\n\n// 必须在 async 函数中使用 await\nasync function getFile() {\n  console.log(\"准备调用下载函数...\");\n  const result = await simulateDownload(); // 程序会在这里暂停，直到Promise完成\n  console.log(\"下载函数执行完毕！\");\n  console.log(\"收到的结果:\", result);\n}\n\ngetFile();\n// 输出顺序:\n// 准备调用下载函数...\n// 🚀 开始下载文件...\n// (等待约2秒)\n// 下载函数执行完毕！\n// 收到的结果: ✅ 文件下载完成！", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-2-await表达式.md", "blockIndex": 0}
{"id": "js-sec-5-3-2", "title": "await表达式", "code": "// 模拟一个API请求，该请求会返回一个用户信息对象\nfunction fetchUserProfile() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve({ name: \"Alice\", level: 99 });\n    }, 1000);\n  });\n}\n\nasync function displayUser() {\n  console.log(\"正在获取用户信息...\");\n  // await直接拿到了Promise中的{ name: \"Alice\", level: 99 }对象\n  const user = await fetchUserProfile();\n  console.log(`欢迎回来, ${user.name}! 你的等级是 ${user.level}。`);\n}\n\ndisplayUser();\n// 输出:\n// 正在获取用户信息...\n// (等待1秒)\n// 欢迎回来, Alice! 你的等级是 99。", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-2-await表达式.md", "blockIndex": 1}
{"id": "js-sec-5-3-2", "title": "await表达式", "code": "// 模拟一个会失败的API请求\nfunction unstableApiRequest() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      // 模拟一个随机失败\n      if (Math.random() > 0.5) {\n        resolve(\"🎉 数据获取成功！\");\n      } else {\n        reject(new Error(\"💥 网络连接中断！\"));\n      }\n    }, 1000);\n  });\n}\n\nasync function fetchData() {\n  try {\n    console.log(\"尝试从不稳定的API获取数据...\");\n    const data = await unstableApiRequest();\n    console.log(\"成功信息:\", data);\n  } catch (error) {\n    console.error(\"捕获到错误:\", error.message);\n  } finally {\n    console.log(\"--- 请求结束 ---\");\n  }\n}\n\nfetchData();\n// 可能的输出 1:\n// 尝试从不稳定的API获取数据...\n// (等待1秒)\n// 成功信息: 🎉 数据获取成功！\n// --- 请求结束 ---\n\n// 可能的输出 2:\n// 尝试从不稳定的API获取数据...\n// (等待1秒)\n// 捕获到错误: 💥 网络连接中断！\n// --- 请求结束 ---", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-2-await表达式.md", "blockIndex": 2}
{"id": "js-sec-5-3-2", "title": "await表达式", "code": "// 完整的对比示例，包含所有必要的变量定义\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 展示常见错误\nfunction simulateTask() {\n  return new Promise(resolve => setTimeout(() => resolve(\"任务完成\"), 500));\n}\n\n// 下面的代码会直接导致 SyntaxError: await is only valid in async functions and the top level bodies of modules\n// 为了让整个脚本能运行，我们注释掉这部分错误代码，并用文字说明\n/*\n  console.log(\"准备开始任务...\");\n  const result = await simulateTask(); // 语法错误！\n  console.log(result);\n*/\nconsole.error(\"错误原因：`await` 只能在 `async` 函数内部或模块的顶层使用。在普通函数中直接使用会导致语法错误。\");\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 展示正确做法\n// 将 `await` 包装在一个 async 函数中\nasync function runTask() {\n  function simulateCorrectTask() {\n    return new Promise(resolve => setTimeout(() => resolve(\"✅ 正确的任务完成\"), 500));\n  }\n  \n  console.log(\"准备开始正确的任务...\");\n  const result = await simulateCorrectTask(); // 正确！在async函数内部使用\n  console.log(result);\n}\n\nrunTask();\n// 解释为什么这样是对的\nconsole.log(\"正确原因：我们将 `await` 表达式放在了 `async` 关键字声明的函数 `runTask` 内部，这完全符合语法规则。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-2-await表达式.md", "blockIndex": 3}
{"id": "js-sec-5-3-2", "title": "await表达式", "code": "// 模拟各种异步检查任务，每个任务耗时不同\nfunction simulateSystemCheck(systemName, delay) {\n  console.log(`...开始检查 [${systemName}] 系统...`);\n  return new Promise(resolve => {\n    setTimeout(() => {\n      console.log(`✅ [${systemName}] 系统正常!`);\n      resolve(true);\n    }, delay);\n  });\n}\n\n// 模拟一个可能失败的检查\nfunction scanForLifeForms(delay) {\n  console.log(`...正在扫描生命信号...`);\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (Math.random() > 0.2) { // 80% 概率成功\n        console.log(\"👽 未发现敌对生命信号。安全！\");\n        resolve(\"安全\");\n      } else {\n        console.error(\"🚨 警告！侦测到高能量读数！可能是危险生物！\");\n        reject(\"危险生物警告\");\n      }\n    }, delay);\n  });\n}\n\n// 主着陆流程\nasync function startLandingSequence() {\n  try {\n    console.log(\"--- 🚀 开始执行着陆序列 ---\");\n\n    // await确保了检查是按顺序一个接一个执行的\n    await simulateSystemCheck(\"引擎冷却\", 1000);\n    await simulateSystemCheck(\"护盾校准\", 1500);\n    await simulateSystemCheck(\"大气成分分析\", 2000);\n    \n    // 处理可能失败的扫描\n    const scanResult = await scanForLifeForms(1200);\n    console.log(`扫描结果: ${scanResult}。继续着陆流程...`);\n\n    console.log(\"--- ✨ 所有检查通过！飞船准备着陆！---\");\n    \n  } catch (error) {\n    console.error(`--- ❌ 着陆序列中断！原因: ${error} ---`);\n    console.log(\"--- 启动紧急规避程序！撤离当前空域！---\");\n  }\n}\n\n// 启动AI\nstartLandingSequence();", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-2-await表达式.md", "blockIndex": 4}
{"id": "js-sec-5-3-3", "title": "错误处理", "code": "console.log(\"程序开始运行...\");\n\ntry {\n  // 尝试调用一个不存在的函数，这会引发一个错误\n  nonExistentFunction(); \n} catch (error) {\n  // 如果try块中发生错误，这里的代码就会被执行\n  console.log(\"糟糕！捕捉到了一个错误！\");\n  console.log(\"错误信息:\", error.message); // error对象包含了错误的详细信息\n}\n\nconsole.log(\"程序继续运行，没有因为错误而崩溃。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-3-错误处理.md", "blockIndex": 0}
{"id": "js-sec-5-3-3", "title": "错误处理", "code": "function processData(shouldThrowError) {\n  console.log(`--- 开始处理数据 (是否会出错: ${shouldThrowError}) ---`);\n  try {\n    console.log(\"进入 try 块，尝试处理数据...\");\n    if (shouldThrowError) {\n      // 模拟一个处理错误\n      throw new Error(\"数据格式不正确！\");\n    }\n    console.log(\"数据处理成功！\");\n  } catch (error) {\n    console.log(`在 catch 块中捕获到错误: ${error.message}`);\n  } finally {\n    // 无论是否出错，finally块总会执行\n    console.log(\"进入 finally 块，执行清理操作（例如：关闭数据库连接）。\");\n  }\n  console.log(\"--- 数据处理结束 ---\\n\");\n}\n\n// 场景1: 没有发生错误\nprocessData(false);\n\n// 场景2: 发生错误\nprocessData(true);", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-3-错误处理.md", "blockIndex": 1}
{"id": "js-sec-5-3-3", "title": "错误处理", "code": "function calculateCircleArea(radius) {\n  console.log(`尝试计算半径为 ${radius} 的圆面积...`);\n  \n  if (typeof radius !== 'number') {\n    // 如果输入不是数字，就主动抛出一个类型错误\n    throw new TypeError(\"参数必须是数字！\");\n  }\n  \n  if (radius < 0) {\n    // 如果半径为负数，不符合业务逻辑，抛出一个自定义错误\n    throw new Error(\"半径不能为负数！\");\n  }\n  \n  const area = Math.PI * radius * radius;\n  console.log(`计算成功，面积是: ${area.toFixed(2)}`);\n  return area;\n}\n\ntry {\n  calculateCircleArea(10); // 正常情况\n  calculateCircleArea(-5); // 触发自定义错误\n} catch (error) {\n  console.error(`[错误捕获] 计算失败: ${error.message}`);\n}\n\ntry {\n  calculateCircleArea(\"hello\"); // 触发类型错误\n} catch (error) {\n  console.error(`[错误捕获] 计算失败: ${error.message}`);\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-3-错误处理.md", "blockIndex": 2}
{"id": "js-sec-5-3-3", "title": "错误处理", "code": "// 模拟一个可能失败的JSON解析函数\nfunction parseUserData(jsonString) {\n  // JSON.parse在遇到无效JSON时会抛出错误\n  return JSON.parse(jsonString);\n}\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误用法：直接调用，不处理潜在的错误\n// 如果jsonString格式错误，下面这行代码会导致整个程序崩溃。\n// 在这个可交互环境中，你可能只会看到一个错误信息，但在真实应用中，后续代码将全部停止执行。\ntry {\n    const invalidJson = '{\"name\": \"Alice\", \"age\": 30,}'; // 注意末尾多余的逗号，这是无效JSON\n    const user = parseUserData(invalidJson);\n    console.log(\"用户信息:\", user.name); // 这行代码永远不会执行\n} catch (error) {\n    console.log(\"程序因未捕获的错误而中断。错误信息:\", error.message);\n    console.log(\"❌ 这种方式非常危险，因为它没有错误处理机制。\");\n}\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确用法：使用 try...catch 包裹可能出错的代码\nfunction safeParseUserData(jsonString) {\n  try {\n    const user = JSON.parse(jsonString);\n    console.log(`✅ 解析成功！欢迎，${user.name}！`);\n    return user;\n  } catch (error) {\n    console.error(`❌ 解析失败！无效的数据格式。错误详情: ${error.message}`);\n    return null; // 返回一个默认值或null，让程序可以继续\n  }\n}\n\nconst validJson = '{\"name\": \"Bob\", \"age\": 25}';\nconst invalidJson = '{\"name\": \"Charlie\", \"age\": }'; // 故意写错的JSON\n\nsafeParseUserData(validJson);\nsafeParseUserData(invalidJson);\nconsole.log(\"✅ 程序优雅地处理了错误，并继续执行。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-3-错误处理.md", "blockIndex": 3}
{"id": "js-sec-5-3-3", "title": "错误处理", "code": "// 模拟一个外星语言词典\nconst alienDictionary = {\n  'hello': 'Gleep Glorp',\n  'world': 'Zorp',\n  'human': 'Squishy',\n  'danger': 'Klaatu Barada Nikto'\n};\n\n// 翻译函数，如果找不到单词会抛出自定义错误\nfunction translateToAlien(word) {\n  const lowerCaseWord = word.toLowerCase();\n  if (alienDictionary[lowerCaseWord]) {\n    return alienDictionary[lowerCaseWord];\n  } else {\n    // 找不到单词，抛出一个特定的错误\n    throw new Error(`未知信号: 无法翻译单词 \"${word}\"`);\n  }\n}\n\n// 主程序：尝试翻译一条来自地球的信息\nfunction broadcastMessage(message) {\n  console.log(`🚀 正在尝试向外星文明广播信息: \"${message}\"`);\n  const words = message.split(' ');\n  let translatedMessage = '';\n\n  for (const word of words) {\n    try {\n      // 尝试翻译每个单词\n      const translatedWord = translateToAlien(word);\n      translatedMessage += translatedWord + ' ';\n    } catch (error) {\n      // 捕获到翻译错误！\n      console.warn(`[翻译模块警告] ${error.message}`);\n      console.log(`...用[静态噪音]代替未知单词...`);\n      // 用一个占位符代替无法翻译的词\n      translatedMessage += '[STATIC_NOISE] ';\n    }\n  }\n  \n  console.log(`📡 广播已发送: \"${translatedMessage.trim()}\"\\n`);\n}\n\n// 场景1: 一条可以完全翻译的信息\nbroadcastMessage(\"Hello human\");\n\n// 场景2: 包含未知词汇的信息\nbroadcastMessage(\"Warning: Danger ahead\"); // 'Warning' 和 'ahead' 不在词典里", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-3-错误处理.md", "blockIndex": 4}
{"id": "js-sec-5-3-4", "title": "并发控制", "code": "// 模拟一个耗时任务，例如API请求或文件下载\nfunctioncreateTask(id) {\n  return () => {\n    console.log(`[${new Date().toLocaleTimeString()}] 任务 ${id} 开始执行...`);\n    return new Promise(resolve => {\n      setTimeout(() => {\n        console.log(`[${new Date().toLocaleTimeString()}] ✅ 任务 ${id} 执行完毕!`);\n        resolve(`任务 ${id} 的结果`);\n      }, 1000); // 每个任务耗时1秒\n    });\n  };\n}\n\n// 创建5个任务\nconst tasks = [\n  createTask(1),\n  createTask(2),\n  createTask(3),\n  createTask(4),\n  createTask(5),\n];\n\nconsole.log(\"💥 如果不控制并发，所有任务会立即启动：\");\n\n// 同时启动所有任务\ntasks.forEach(task => task());\n\n// 输出结果会显示，所有任务几乎在同一时间开始，然后在1秒后几乎同时结束。\n// [HH:MM:SS] 任务 1 开始执行...\n// [HH:MM:SS] 任务 2 开始执行...\n// [HH:MM:SS] 任务 3 开始执行...\n// [HH:MM:SS] 任务 4 开始执行...\n// [HH:MM:SS] 任务 5 开始执行...\n// (等待1秒)\n// [HH:MM:SS] ✅ 任务 1 执行完毕!\n// [HH:MM:SS] ✅ 任务 2 执行完毕!\n// [HH:MM:SS] ✅ 任务 3 执行完毕!\n// [HH:MM:SS] ✅ 任务 4 执行完毕!\n// [HH:MM:SS] ✅ 任务 5 执行完毕!", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-4-并发控制.md", "blockIndex": 0}
{"id": "js-sec-5-3-4", "title": "并发控制", "code": "// 模拟一个异步任务\nfunctioncreateAsyncTask(id) {\n  const duration = Math.floor(Math.random() * 500) + 500; // 随机耗时 0.5-1秒\n  return () => new Promise(resolve => {\n    console.log(`[${new Date().toLocaleTimeString()}] 任务 ${id} 开始 (预计耗时: ${duration}ms)`);\n    setTimeout(() => {\n      console.log(`[${new Date().toLocaleTimeString()}] ✅ 任务 ${id} 完成`);\n      resolve(id);\n    }, duration);\n  });\n}\n\n// 并发控制器\nasync function runWithConcurrency(tasks, limit) {\n  const results = [];\n  const running = []; // 存储正在运行的任务\n  const queue = [...tasks]; // 任务队列\n\n  function runNext() {\n    // 当队列为空或正在运行的任务达到上限时，不再启动新任务\n    if (queue.length === 0 || running.length >= limit) {\n      return;\n    }\n\n    const task = queue.shift();\n    const promise = task().then(result => {\n      // 任务完成后，从 running 数组中移除\n      const index = running.indexOf(promise);\n      if (index > -1) {\n        running.splice(index, 1);\n      }\n      results.push(result);\n      // 启动下一个任务\n      runNext();\n    });\n\n    running.push(promise);\n  }\n\n  // 初始启动任务，填满并发窗口\n  for (let i = 0; i < limit && i < tasks.length; i++) {\n    runNext();\n  }\n\n  // 等待所有任务完成\n  // 通过检查队列和正在运行的任务来判断\n  return new Promise(resolve => {\n    const interval = setInterval(() => {\n      if (queue.length === 0 && running.length === 0) {\n        clearInterval(interval);\n        resolve(results.sort((a, b) => a - b)); // 排序以方便查看\n      }\n    }, 100);\n  });\n}\n\nconst tasks = Array.from({ length: 8 }, (_, i) => createAsyncTask(i + 1));\nconst concurrencyLimit = 3;\n\nconsole.log(`🚀 启动任务调度器，并发限制为: ${concurrencyLimit}`);\n\nrunWithConcurrency(tasks, concurrencyLimit).then(finalResults => {\n  console.log(\"\\n🎉 所有任务都已完成！\");\n  console.log(\"任务执行结果:\", finalResults);\n});\n\n// 输出会显示，始终最多只有3个任务在同时运行。", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-4-并发控制.md", "blockIndex": 1}
{"id": "js-sec-5-3-4", "title": "并发控制", "code": "class ConcurrencyController {\n  constructor(limit) {\n    this.limit = limit;\n    this.queue = [];\n    this.runningCount = 0;\n    console.log(`控制器已创建，并发限制为 ${this.limit}`);\n  }\n\n  // 添加任务到队列\n  addTask(task) {\n    return new Promise((resolve, reject) => {\n      this.queue.push({ task, resolve, reject });\n      this.tryRunNext();\n    });\n  }\n\n  // 尝试执行下一个任务\n  tryRunNext() {\n    if (this.runningCount < this.limit && this.queue.length > 0) {\n      const { task, resolve, reject } = this.queue.shift();\n      this.runningCount++;\n      console.log(`[${new Date().toLocaleTimeString()}] 启动新任务... 当前运行数: ${this.runningCount}`);\n      \n      task()\n        .then(resolve, reject)\n        .finally(() => {\n          this.runningCount--;\n          console.log(`[${new Date().toLocaleTimeString()}] 一个任务完成。当前运行数: ${this.runningCount}`);\n          this.tryRunNext();\n        });\n    }\n  }\n}\n\n// 模拟任务\nfunction createDynamicTask(id) {\n  const duration = Math.floor(Math.random() * 1000) + 500;\n  return () => new Promise(resolve => {\n    console.log(`  -> 任务 ${id} 执行中 (耗时 ${duration}ms)`);\n    setTimeout(() => resolve(`任务 ${id} 结果`), duration);\n  });\n}\n\nconst controller = new ConcurrencyController(2);\n\n// 初始添加3个任务\nconsole.log(\"--- 初始添加3个任务 ---\");\ncontroller.addTask(createDynamicTask(1)).then(res => console.log(`✅ ${res}`));\ncontroller.addTask(createDynamicTask(2)).then(res => console.log(`✅ ${res}`));\ncontroller.addTask(createDynamicTask(3)).then(res => console.log(`✅ ${res}`));\n\n// 1秒后，动态添加更多任务\nsetTimeout(() => {\n  console.log(\"\\n--- 动态添加2个新任务 ---\");\n  controller.addTask(createDynamicTask(4)).then(res => console.log(`✅ ${res}`));\n  controller.addTask(createDynamicTask(5)).then(res => console.log(`✅ ${res}`));\n}, 1000);", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-4-并发控制.md", "blockIndex": 2}
{"id": "js-sec-5-3-4", "title": "并发控制", "code": "// 模拟一个会消耗资源的API请求\nfunction mockApiRequest(id) {\n  return new Promise(resolve => {\n    console.log(`发起请求 ${id}...`);\n    // 模拟网络延迟\n    setTimeout(() => {\n      resolve(`数据 ${id}`);\n    }, 800);\n  });\n}\n\nconst requestIds = Array.from({ length: 10 }, (_, i) => i + 1);\n\nasync function runComparison() {\n  console.log(\"=== 错误用法 ===\");\n  // ❌ 错误：使用 Promise.all 一次性发起所有请求\n  // 这会导致在短时间内创建大量网络连接，可能超出浏览器或服务器的限制。\n  console.log(\"💥 警告: 即将同时发起 10 个请求！\");\n  try {\n    const results = await Promise.all(requestIds.map(id => mockApiRequest(id)));\n    console.log(\"所有请求在几乎同一时间完成:\", results.length, \"个\");\n  } catch (error) {\n    console.error(\"请求失败:\", error);\n  }\n\n  await new Promise(r => setTimeout(r, 2000)); // 等待2秒，方便观察\n\n  console.log(\"\\n\\n=== 正确用法 ===\");\n  // ✅ 正确：使用并发控制器，限制同时最多只有3个请求\n  console.log(\"👍 优化: 使用并发控制，每次最多发起 3 个请求。\");\n  \n  class RequestScheduler {\n    constructor(limit) {\n      this.limit = limit;\n      this.queue = [];\n      this.runningCount = 0;\n    }\n    \n    add(requestFn) {\n      return new Promise((resolve, reject) => {\n        this.queue.push({ requestFn, resolve, reject });\n        this.tryNext();\n      });\n    }\n\n    tryNext() {\n      if (this.runningCount < this.limit && this.queue.length > 0) {\n        const { requestFn, resolve, reject } = this.queue.shift();\n        this.runningCount++;\n        console.log(`  [调度器] 批准一个新请求。当前并发数: ${this.runningCount}`);\n        requestFn()\n          .then(resolve, reject)\n          .finally(() => {\n            this.runningCount--;\n            this.tryNext();\n          });\n      }\n    }\n  }\n\n  const scheduler = new RequestScheduler(3);\n  const promises = requestIds.map(id => scheduler.add(() => mockApiRequest(id)));\n  const finalResults = await Promise.all(promises);\n  console.log(\"所有请求在控制下有序完成:\", finalResults.length, \"个\");\n}\n\nrunComparison();", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-4-并发控制.md", "blockIndex": 3}
{"id": "js-sec-5-3-4", "title": "并发控制", "code": "// 机器人探索任务的模拟\nclass MarsRover {\n  constructor(name) {\n    this.name = name;\n  }\n\n  // 模拟一个复杂的、多阶段的探索任务\n  async explore() {\n    console.log(`🤖 ${this.name}: 任务启动，离开着陆点...`);\n    \n    await this.performTask(\"分析土壤样本\", 1000 + Math.random() * 500);\n    await this.performTask(\"拍摄全景照片\", 1000 + Math.random() * 500);\n    await this.performTask(\"寻找水源迹象\", 1500 + Math.random() * 500);\n\n    const discoveries = [\"奇特的蓝色晶体\", \"远古生物化石\", \"一个废弃的咖啡杯\"];\n    const discovery = discoveries[Math.floor(Math.random() * discoveries.length)];\n    \n    console.log(`✨ ${this.name}: 任务完成！重大发现: ${discovery}!`);\n    return `${this.name} 报告: ${discovery}`;\n  }\n\n  // 辅助函数，模拟执行单个子任务\n  performTask(taskName, duration) {\n    console.log(`  🛰️  ${this.name}: 正在执行 -> ${taskName}...`);\n    return new Promise(resolve => setTimeout(resolve, duration));\n  }\n}\n\n// 并发控制器\nasync function deployFleet(rovers, limit) {\n  console.log(`--- 指挥中心: 启动火星部署！通讯带宽限制: ${limit} ---`);\n  const taskQueue = [...rovers];\n  const activeTasks = [];\n  const results = [];\n\n  const runNext = async () => {\n    if (taskQueue.length === 0) return;\n\n    const rover = taskQueue.shift();\n    const taskPromise = rover.explore().then(result => {\n      results.push(result);\n      // 当一个任务完成后，从活动任务中移除它，并尝试启动下一个\n      activeTasks.splice(activeTasks.indexOf(taskPromise), 1);\n      return runNext();\n    });\n    activeTasks.push(taskPromise);\n  };\n\n  // 初始部署，填满带宽\n  const initialDeploy = Array.from({ length: Math.min(limit, rovers.length) }, runNext);\n  await Promise.all(initialDeploy.concat(activeTasks));\n  \n  return results;\n}\n\n// --- 任务开始 ---\nconst roverNames = [\"勇气号\", \"机遇号\", \"好奇号\", \"毅力号\", \"祝融号\", \"探索者1号\", \"先锋号\", \"开拓者\", \"守护者\", \"发现号\"];\nconst fleet = roverNames.map(name => new MarsRover(name));\n\n// 以3个并发的限制部署整个机器人舰队\ndeployFleet(fleet, 3).then(missionReports => {\n  console.log(\"\\n\\n--- 任务简报 ---\");\n  console.log(\"所有机器人均已完成探索任务！\");\n  missionReports.forEach(report => console.log(`- ${report}`));\n  console.log(\"--- 指挥中心: 火星任务圆满成功！---\");\n});", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-4-并发控制.md", "blockIndex": 4}
{"id": "js-sec-5-3-5", "title": "实战应用", "code": "// 模拟一个需要2秒才能完成的异步任务（比如从服务器获取数据）\nfunction fetchData() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(\"叮！美味的披萨加热好了！🍕\");\n    }, 2000);\n  });\n}\n\n// 使用 async/await 来“等待”任务完成\nasync function prepareDinner() {\n  console.log(\"把披萨放进微波炉...\");\n  const result = await fetchData(); // 等待 fetchData() 完成\n  console.log(result); // 拿到结果后，再执行这行\n  console.log(\"开吃吧！\");\n}\n\nprepareDinner();", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-5-实战应用.md", "blockIndex": 0}
{"id": "js-sec-5-3-5", "title": "实战应用", "code": "// 模拟制作咖啡的步骤，每一步都需要时间\nfunction grindBeans() {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(\"1. 咖啡豆磨好了\"), 1000);\n  });\n}\n\nfunction brewCoffee() {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(\"2. 咖啡冲泡好了\"), 1500);\n  });\n}\n\nfunction addMilk() {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(\"3. 牛奶加好了\"), 500);\n  });\n}\n\nasync function makeLatte() {\n  console.log(\"开始制作拿铁...\");\n  \n  const step1 = await grindBeans();\n  console.log(step1);\n  \n  const step2 = await brewCoffee();\n  console.log(step2);\n  \n  const step3 = await addMilk();\n  console.log(step3);\n  \n  console.log(\"拿铁制作完成！☕️\");\n}\n\nmakeLatte();", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-5-实战应用.md", "blockIndex": 1}
{"id": "js-sec-5-3-5", "title": "实战应用", "code": "// 模拟一个可能会失败的异步操作\nfunction preheatOven() {\n  return new Promise((resolve, reject) => {\n    const isBroken = Math.random() > 0.5; // 模拟烤箱有50%几率出故障\n    setTimeout(() => {\n      if (isBroken) {\n        reject(\"❌ 糟糕！烤箱短路了！\");\n      } else {\n        resolve(\"✅ 烤箱预热成功！\");\n      }\n    }, 1000);\n  });\n}\n\nasync function bakeCookies() {\n  try {\n    console.log(\"准备烤饼干，开始预热烤箱...\");\n    const status = await preheatOven();\n    console.log(status);\n    console.log(\"放入饼干，开始烘焙...🍪\");\n  } catch (error) {\n    console.error(\"出错了，烘焙计划取消！\");\n    console.error(error); // 打印出具体的错误信息\n  }\n}\n\nbakeCookies();", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-5-实战应用.md", "blockIndex": 2}
{"id": "js-sec-5-3-5", "title": "实战应用", "code": "// 模拟一个异步获取用户信息的函数\nfunction fetchUser(userId) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve({ id: userId, name: \"Alice\" });\n    }, 1000);\n  });\n}\n\nasync function showUserInfo() {\n  console.log(\"=== 错误用法 ===\");\n  // ❌ 忘记使用 await\n  const userPromise = fetchUser(1);\n  // 这里得到的不是用户信息对象，而是一个待定的 Promise 对象\n  console.log(\"用户信息:\", userPromise); \n  // 解释：因为没有`await`，代码不会等待Promise解析，直接执行下一行，所以打印出的是Promise本身。\n\n  console.log(\"\\n=== 正确用法 ===\");\n  // ✅ 使用 await 等待 Promise 解析\n  const user = await fetchUser(1);\n  // 这里会等待1秒，直到Promise完成，user变量被赋值为 { id: 1, name: \"Alice\" }\n  console.log(\"用户信息:\", user);\n  // 解释：`await`会暂停函数的执行，直到Promise返回结果，这样我们就能直接使用解析后的值。\n}\n\nshowUserInfo();", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-5-实战应用.md", "blockIndex": 3}
{"id": "js-sec-5-3-5", "title": "实战应用", "code": "// 模拟游戏中的异步事件\nfunction enterCave() {\n  console.log(\"你鼓起勇气，走进了黑暗的洞穴... 🔦\");\n  return new Promise(resolve => setTimeout(() => resolve(\"你深入了洞穴，发现了一条岔路。\"), 1500));\n}\n\nfunction findTreasureChest() {\n  console.log(\"你选择了左边的路，仔细搜索...\");\n  return new Promise(resolve => setTimeout(() => resolve(\"✨ 哇！你找到了一个闪闪发光的宝箱！\"), 2000));\n}\n\nfunction fightGuardian() {\n  console.log(\"你尝试打开宝箱，突然一个石头守护者苏醒了！🗿\");\n  return new Promise((resolve, reject) => {\n    const playerPower = Math.floor(Math.random() * 10) + 1; // 你的力量是随机的\n    console.log(`你的力量是 ${playerPower}，守护者的力量是 5。`);\n    setTimeout(() => {\n      if (playerPower > 5) {\n        resolve(\"你击败了守护者，成功打开了宝箱！获得了[传说之剑]！🏆\");\n      } else {\n        reject(\"你的力量不足，被守护者赶出了洞穴... 下次再来吧！😩\");\n      }\n    }, 2500);\n  });\n}\n\n// 完整的探险流程\nasync function startAdventure() {\n  try {\n    const step1Result = await enterCave();\n    console.log(step1Result);\n\n    const step2Result = await findTreasureChest();\n    console.log(step2Result);\n\n    const step3Result = await fightGuardian();\n    console.log(step3Result);\n    \n    console.log(\"\\n🎉 恭喜！你完成了一次伟大的冒险，角色升了一级！\");\n\n  } catch (error) {\n    console.error(\"\\n冒險失敗... \" + error);\n  } finally {\n    console.log(\"\\n--- 探险日志记录完毕 ---\");\n  }\n}\n\n// 开始你的冒险吧！\nstartAdventure();", "lang": "javascript", "source": "web-learner/public/content/js-sec-5-3-5-实战应用.md", "blockIndex": 4}
{"id": "js-sec-6-1-1", "title": "元素选择", "code": "// 假设你的HTML页面中有这样一个元素: <h1 id=\"game-title\">欢迎来到我的游戏世界!</h1>\n\n// 使用 document.querySelector 通过 ID 选择器 (#) 来找到这个标题元素\nconst titleElement = document.querySelector('#game-title');\n\n// 如果找到了，它会返回该元素对象；如果没找到，会返回 null\nif (titleElement) {\n  console.log(\"成功找到了标题元素!\");\n  console.log(\"它的文本内容是:\", titleElement.textContent);\n} else {\n  console.log(\"糟糕，没有找到ID为 'game-title' 的元素。\");\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-1-元素选择.md", "blockIndex": 0}
{"id": "js-sec-6-1-1", "title": "元素选择", "code": "/*\n假设HTML是这样的:\n<div class=\"card\">苹果</div>\n<div class=\"card\">香蕉</div>\n<div class=\"card\">橘子</div>\n*/\n\n// querySelector 只会抓到第一个 \"card\"\nconst firstCard = document.querySelector('.card');\nconsole.log(\"--- 使用 querySelector ---\");\nconsole.log(\"只找到了第一个卡片:\", firstCard.textContent);\n\n\n// querySelectorAll 会抓到所有的 \"card\"\nconst allCards = document.querySelectorAll('.card');\nconsole.log(\"\\n--- 使用 querySelectorAll ---\");\nconsole.log(`找到了 ${allCards.length} 个卡片，它们组成了一个列表。`);\n\n// 我们可以像遍历数组一样遍历这个列表\nallCards.forEach((card, index) => {\n  console.log(`第 ${index + 1} 个卡片是: ${card.textContent}`);\n});", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-1-元素选择.md", "blockIndex": 1}
{"id": "js-sec-6-1-1", "title": "元素选择", "code": "/*\n假设HTML是这样的:\n<div id=\"player-stats\">\n  <p class=\"username\">英雄A</p>\n  <ul>\n    <li>生命值: <span class=\"stat-value\">100</span></li>\n    <li>攻击力: <span class=\"stat-value\">25</span></li>\n  </ul>\n  <button data-action=\"attack\">攻击</button>\n</div>\n*/\n\n// 1. 标签选择器 (p)\nconst paragraph = document.querySelector('p');\nconsole.log(\"通过标签 'p' 找到:\", paragraph.textContent);\n\n// 2. 类选择器 (.stat-value)\nconst statValues = document.querySelectorAll('.stat-value');\nconsole.log(`通过类 '.stat-value' 找到 ${statValues.length} 个统计数值。`);\n\n// 3. 后代选择器 (#player-stats li)\nconst listItems = document.querySelectorAll('#player-stats li');\nconsole.log(`通过后代选择器找到了 ${listItems.length} 个列表项。`);\n\n// 4. 属性选择器 ([data-action=\"attack\"])\nconst attackButton = document.querySelector('[data-action=\"attack\"]');\nconsole.log(\"通过属性选择器找到:\", attackButton.textContent, \"按钮\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-1-元素选择.md", "blockIndex": 2}
{"id": "js-sec-6-1-1", "title": "元素选择", "code": "/*\n假设HTML是这样的:\n<div class=\"enemy\">哥布林</div>\n<div class=\"enemy\">史莱姆</div>\n<div class=\"enemy\">野狼</div>\n*/\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 尝试直接修改 querySelectorAll 返回的列表的样式\nconst allEnemies = document.querySelectorAll('.enemy');\ntry {\n  // 这行会报错，因为 allEnemies 是一个元素列表，而不是单个元素\n  // 它没有 .style 属性\n  allEnemies.style.color = 'red'; \n} catch (error) {\n  console.log(\"果然出错了:\", error.message);\n  console.log(\"错误原因：你不能直接给一个元素列表设置样式，需要逐个设置。\");\n}\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 遍历列表，为每一个元素单独设置样式\nconst allEnemiesCorrect = document.querySelectorAll('.enemy');\nconsole.log(`准备为 ${allEnemiesCorrect.length} 个敌人设置样式...`);\nallEnemiesCorrect.forEach((enemy, index) => {\n  // 模拟修改样式，在控制台输出\n  console.log(`正在将第 ${index + 1} 个敌人 \"${enemy.textContent}\" 的颜色设置为红色。`);\n  // 在真实浏览器环境中，可以执行 enemy.style.color = 'red';\n});\nconsole.log(\"所有敌人已被标记！\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-1-元素选择.md", "blockIndex": 3}
{"id": "js-sec-6-1-1", "title": "元素选择", "code": "// 模拟HTML场景:\n// <div class=\"bush\"></div>\n// <div class=\"bush\"></div>\n// <div class=\"bush hiding-cat\"></div> <!-- 猫咪藏在这里! -->\n// <div class=\"bush\"></div>\n\nfunction setupGame() {\n  // 1. 创建一个代表游戏区域的虚拟父元素\n  const gameArea = document.createElement('div');\n  \n  // 2. 创建4个灌木丛\n  const bushesHTML = `\n    <div class=\"bush\" id=\"bush-1\"></div>\n    <div class=\"bush\" id=\"bush-2\"></div>\n    <div class=\"bush\" id=\"bush-3\"></div>\n    <div class=\"bush\" id=\"bush-4\"></div>\n  `;\n  gameArea.innerHTML = bushesHTML;\n\n  // 3. 随机选择一个灌木丛让猫咪藏进去\n  const allBushes = gameArea.querySelectorAll('.bush');\n  const hidingPlaceIndex = Math.floor(Math.random() * allBushes.length);\n  allBushes[hidingPlaceIndex].classList.add('hiding-cat');\n  \n  return gameArea;\n}\n\n// --- 游戏开始 ---\nconst gameArea = setupGame();\nconsole.log(\"游戏开始！一只猫咪藏在了某个灌木丛里...\");\n\n// 🚀 核心任务: 使用元素选择器找到猫咪！\n// 我们用一个复合选择器 .bush.hiding-cat 来精确定位\nconst catLocation = gameArea.querySelector('.bush.hiding-cat');\n\nif (catLocation) {\n  // catLocation.id 可以告诉我们是哪个灌木丛\n  console.log(\"🎉 找到了！猫咪在\", catLocation.id, \"号灌木丛里！喵~\");\n  console.log(\"这个灌木丛的class是:\", catLocation.className);\n} else {\n  console.log(\"😥 奇怪，猫咪跑丢了... 游戏设置可能出了点问题。\");\n}\n\n// 额外挑战：数一数有多少个安全的灌木丛\nconst safeBushes = gameArea.querySelectorAll('.bush:not(.hiding-cat)');\nconsole.log(`\\n这里有 ${safeBushes.length} 个没有猫的灌木丛，很安全。`);", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-1-元素选择.md", "blockIndex": 4}
{"id": "js-sec-6-1-2", "title": "内容修改", "code": "// 模拟一个网页上的 <p> 元素\n// 在真实浏览器中，你会用 document.getElementById('my-paragraph') 来获取元素\nlet mockParagraph = {\n  textContent: \"你好，世界！\"\n};\n\nconsole.log(\"修改前的内容:\", mockParagraph.textContent);\n\n// 修改元素的文本内容\nmockParagraph.textContent = \"你好，JavaScript！\";\n\nconsole.log(\"修改后的内容:\", mockParagraph.textContent);", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-2-内容修改.md", "blockIndex": 0}
{"id": "js-sec-6-1-2", "title": "内容修改", "code": "// 模拟一个网页上的 <div> 元素\nlet mockElement = {\n  textContent: \"\"\n};\n\nconsole.log(\"--- 使用 textContent ---\");\n\n// 尝试用 textContent 添加一个包含 <strong> 标签的字符串\nmockElement.textContent = \"这是<strong>加粗</strong>的文字吗？\";\n\n// 输出结果会发现，<strong> 标签被原样当成了文本，并没有加粗效果\nconsole.log(\"元素现在的 textContent:\", mockElement.textContent);\nconsole.log(\"结论：textContent 会忽略HTML标签，将其视为普通文本。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-2-内容修改.md", "blockIndex": 1}
{"id": "js-sec-6-1-2", "title": "内容修改", "code": "// 模拟一个网页上的 <div> 元素\nlet mockElement = {\n  innerHTML: \"\"\n};\n\nconsole.log(\"--- 使用 innerHTML ---\");\n\n// 使用 innerHTML 添加一个包含 <strong> 标签的字符串\nmockElement.innerHTML = \"这是<strong>加粗</strong>的文字！\";\n\n// 输出结果会发现，它能识别并“渲染”HTML标签\nconsole.log(\"元素现在的 innerHTML:\", mockElement.innerHTML);\nconsole.log(\"结论：innerHTML 能够解析并应用HTML标签。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-2-内容修改.md", "blockIndex": 2}
{"id": "js-sec-6-1-2", "title": "内容修改", "code": "// 假设这是用户输入的内容\nconst maliciousUserInput = \"你好！<script>alert('你被攻击了！')</script>\";\n\n// 模拟两个元素，一个用错误方式，一个用正确方式\nlet vulnerableElement = { innerHTML: \"\" };\nlet safeElement = { textContent: \"\" };\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 直接将用户输入赋值给 innerHTML\nvulnerableElement.innerHTML = maliciousUserInput;\nconsole.log(\"危险内容:\", vulnerableElement.innerHTML);\n// 解释：这样做会导致字符串中的 <script> 标签被浏览器解析和执行，\n// 这被称为跨站脚本攻击 (XSS)，非常危险。\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 使用 textContent 来处理用户输入的文本\nsafeElement.textContent = maliciousUserInput;\nconsole.log(\"安全内容:\", safeElement.textContent);\n// 解释：textContent 会将所有内容（包括 <script> 标签）都当作纯文本处理，\n// 标签不会被执行，从而避免了安全风险。", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-2-内容修改.md", "blockIndex": 3}
{"id": "js-sec-6-1-2", "title": "内容修改", "code": "// 模拟网页上显示宠物状态的元素\nconst petStatusDisplay = {\n  innerHTML: \"\"\n};\n\n// 定义我们的虚拟宠物\nlet codeCat = {\n  name: \"代码喵\",\n  mood: \"开心\", // 心情: 开心, 饥饿, 无聊\n  energy: 100\n};\n\n// 更新宠物状态显示的功能\nfunction updateDisplay() {\n  let statusHTML = \"\";\n  let moodEmoji = \"\";\n\n  if (codeCat.mood === \"开心\") {\n    moodEmoji = \"😺\";\n    statusHTML = `<strong>${codeCat.name}</strong> ${moodEmoji} 正开心地摇着尾巴！`;\n  } else if (codeCat.mood === \"饥饿\") {\n    moodEmoji = \"😿\";\n    statusHTML = `<strong>${codeCat.name}</strong> ${moodEmoji} 的肚子在咕咕叫，它饿了！`;\n  } else if (codeCat.mood === \"无聊\") {\n    moodEmoji = \"😼\";\n    statusHTML = `<strong>${codeCat.name}</strong> ${moodEmoji} 正无聊地看着你，想玩耍。`;\n  }\n  \n  statusHTML += `<br><em>能量值: ${codeCat.energy}/100</em>`;\n  \n  // 使用 innerHTML 来更新显示，因为我们想加入 <strong> 和 <br> 等HTML标签\n  petStatusDisplay.innerHTML = statusHTML;\n  console.log(petStatusDisplay.innerHTML.replace(/<br>/g, '\\n')); // 用换行符模拟<br>效果\n}\n\n// 模拟与宠物的互动\nfunction feedPet() {\n  console.log(\"\\n--- 你给代码喵喂了小鱼干 ---\");\n  codeCat.mood = \"开心\";\n  codeCat.energy = Math.min(100, codeCat.energy + 20); // 能量最多100\n  updateDisplay();\n}\n\nfunction playWithPet() {\n  console.log(\"\\n--- 你用逗猫棒和代码喵玩耍 ---\");\n  if (codeCat.energy > 15) {\n    codeCat.mood = \"开心\";\n    codeCat.energy -= 15;\n  } else {\n    codeCat.mood = \"无聊\";\n    console.log(\"代码喵能量不足，不想动了...\");\n  }\n  updateDisplay();\n}\n\n// 游戏开始\nconsole.log(\"--- 游戏开始！遇见你的新宠物 ---\");\nupdateDisplay();\nfeedPet();\nplayWithPet();\nplayWithPet();", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-2-内容修改.md", "blockIndex": 4}
{"id": "js-sec-6-1-3", "title": "属性操作", "code": "// 注意: 以下代码需要在浏览器环境中运行，可以复制到浏览器开发者工具的Console中执行。\n\n// 1. 创建一个虚拟的元素，就像创造一个机器人\nconst robot = document.createElement('div');\n\n// 2. 给机器人贴上一个名为 \"id\" 的名牌，值为 \"R2-D2\"\nrobot.setAttribute('id', 'R2-D2');\n\n// 3. 读取这个机器人 \"id\" 名牌上的值\nconst robotId = robot.getAttribute('id');\n\nconsole.log(`成功创建机器人，它的ID是: ${robotId}`); // 输出: 成功创建机器人，它的ID是: R2-D2\n\n// 4. 你可以检查这个虚拟元素，它现在看起来像 <div id=\"R2-D2\"></div>\nconsole.log(robot.outerHTML);", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-3-属性操作.md", "blockIndex": 0}
{"id": "js-sec-6-1-3", "title": "属性操作", "code": "// 注意: 以下代码需要在浏览器环境中运行。\n\n// 创建一个按钮元素\nconst actionButton = document.createElement('button');\nactionButton.textContent = '发射激光';\n\n// 使用 setAttribute 添加 class 和 id\nactionButton.setAttribute('class', 'laser-button primary');\nactionButton.setAttribute('id', 'main-laser-btn');\n\nconsole.log('按钮初始状态:', actionButton.outerHTML);\n// 输出: 按钮初始状态: <button class=\"laser-button primary\" id=\"main-laser-btn\">发射激光</button>\n\n// 模拟能量耗尽，禁用按钮\nactionButton.setAttribute('disabled', 'true');\nconsole.log('能量耗尽后:', actionButton.outerHTML);\n// 输出: 能量耗尽后: <button class=\"laser-button primary\" id=\"main-laser-btn\" disabled=\"true\">发射激光</button>\n\n// 能量恢复，移除 disabled 属性，让按钮恢复可用\nactionButton.removeAttribute('disabled');\nconsole.log('能量恢复后:', actionButton.outerHTML);\n// 输出: 能量恢复后: <button class=\"laser-button primary\" id=\"main-laser-btn\">发射激光</button>", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-3-属性操作.md", "blockIndex": 1}
{"id": "js-sec-6-1-3", "title": "属性操作", "code": "// 注意: 以下代码需要在浏览器环境中运行。\n\n// 创建一个代表游戏角色的元素\nconst player = document.createElement('div');\n\n// 使用 data-* 属性存储角色信息\nplayer.setAttribute('data-player-name', 'Zelda');\nplayer.setAttribute('data-level', '5');\nplayer.setAttribute('data-score', '12500');\n\n// 读取这些自定义数据\nconst playerName = player.getAttribute('data-player-name');\nconst playerScore = player.getAttribute('data-score');\n\nconsole.log(`${playerName} 的当前分数是: ${playerScore}`);\n// 输出: Zelda 的当前分数是: 12500\n\n// 角色升级\nconst currentLevel = parseInt(player.getAttribute('data-level'), 10);\nconst newLevel = currentLevel + 1;\nplayer.setAttribute('data-level', newLevel);\n\nconsole.log(`${playerName} 升级了! 当前等级: ${player.getAttribute('data-level')}`);\n// 输出: Zelda 升级了! 当前等级: 6", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-3-属性操作.md", "blockIndex": 2}
{"id": "js-sec-6-1-3", "title": "属性操作", "code": "// 注意: 以下代码需要在浏览器环境中运行。\n\nconst myBox = document.createElement('div');\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 尝试用点(.)操作符创建一个非标准属性\nmyBox.myCustomData = '秘密信息';\nconsole.log('通过点操作符设置后，JS对象上确实有该属性:', myBox.myCustomData);\n// 但是，这并没有在HTML上创建对应的属性！\nconsole.log('检查HTML属性 (getAttribute):', myBox.getAttribute('myCustomData')); // 输出: null\nconsole.log('检查HTML结构:', myBox.outerHTML); // 输出: <div></div> (属性没有出现)\n// 解释: 点操作符操作的是JavaScript对象的属性，而不是HTML标签的属性。这对于存储临时状态很有用，但它不会反映在HTML结构上，CSS选择器（如[myCustomData=\"...\"]）也无法选中它。\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 使用 setAttribute 创建自定义属性\nmyBox.setAttribute('my-custom-data', '公开情报');\nconsole.log('通过setAttribute设置后，JS对象上没有直接的同名属性:', myBox.myCustomData); // 仍然是'秘密信息'\n// 但是，HTML属性被正确创建了\nconsole.log('检查HTML属性 (getAttribute):', myBox.getAttribute('my-custom-data')); // 输出: 公开情报\nconsole.log('检查HTML结构:', myBox.outerHTML); // 输出: <div my-custom-data=\"公开情报\"></div>\n// 解释: setAttribute 直接操作HTML标签的属性。这是创建和修改HTML属性（特别是自定义属性和data-*属性）的标准和推荐方法。", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-3-属性操作.md", "blockIndex": 3}
{"id": "js-sec-6-1-3", "title": "属性操作", "code": "// 注意: 以下代码需要在浏览器环境中运行。\n\n// 创建一个代表我们英雄的虚拟元素\nconst heroCard = document.createElement('div');\nheroCard.setAttribute('id', 'hero-gimli');\nheroCard.setAttribute('data-name', 'Gimli');\nheroCard.setAttribute('data-class', '矮人战士');\nheroCard.setAttribute('data-level', '1');\nheroCard.setAttribute('data-hp', '20');\nheroCard.setAttribute('data-strength', '15');\nheroCard.setAttribute('data-weapon', '战斧');\n\n/**\n * 打印角色状态信息\n * @param {HTMLElement} character - 代表角色的元素\n */\nfunction displayStats(character) {\n  const name = character.getAttribute('data-name');\n  const level = character.getAttribute('data-level');\n  const hp = character.getAttribute('data-hp');\n  const strength = character.getAttribute('data-strength');\n  const weapon = character.getAttribute('data-weapon');\n\n  console.log(`\n    --- 角色状态卡 ---\n    姓名: ${name} (Lv. ${level})\n    职业: ${character.getAttribute('data-class')}\n    生命值: ${hp}\n    力量: ${strength}\n    武器: ${weapon}\n    --------------------\n  `);\n}\n\n/**\n * 角色升级函数\n * @param {HTMLElement} character - 代表角色的元素\n */\nfunction levelUp(character) {\n  const name = character.getAttribute('data-name');\n  console.log(`🎉 恭喜！ ${name} 升级了！ 🎉`);\n\n  // 1. 读取当前等级并 +1\n  let currentLevel = parseInt(character.getAttribute('data-level'), 10);\n  character.setAttribute('data-level', ++currentLevel);\n\n  // 2. 增加生命值和力量\n  let currentHp = parseInt(character.getAttribute('data-hp'), 10);\n  let currentStrength = parseInt(character.getAttribute('data-strength'), 10);\n  character.setAttribute('data-hp', currentHp + 10);\n  character.setAttribute('data-strength', currentStrength + 5);\n\n  // 3. 等级达到3级时，获得新武器！\n  if (currentLevel === 3) {\n    console.log(`✨ ${name} 获得了新的武器：风暴战锤！`);\n    character.setAttribute('data-weapon', '风暴战锤');\n  }\n}\n\n// 游戏开始，显示初始状态\nconsole.log(\"游戏开始，英雄登场！\");\ndisplayStats(heroCard);\n\n// 英雄经历了一场战斗，升级了！\nlevelUp(heroCard);\ndisplayStats(heroCard);\n\n// 再次升级！\nlevelUp(heroCard);\ndisplayStats(heroCard);\n\n// 第三次升级，看看会不会有惊喜！\nlevelUp(heroCard);\ndisplayStats(heroCard);", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-3-属性操作.md", "blockIndex": 4}
{"id": "js-sec-6-1-4", "title": "样式操作", "code": "// 在纯JavaScript环境中，我们用一个对象来模拟一个HTML元素\nconst myElement = {\n  id: 'greeting-text',\n  textContent: 'Hello, Coder!',\n  style: {} // 元素的style属性初始是一个空对象\n};\n\nconsole.log('修改前元素的样式:', myElement.style);\n\n// 使用点（.）语法来设置CSS属性\nmyElement.style.color = 'blue';\nmyElement.style.fontSize = '24px'; // 注意属性名的变化\n\nconsole.log('修改后元素的样式:', myElement.style);\nconsole.log(`现在，ID为 '${myElement.id}' 的元素文本 \"${myElement.textContent}\" 将会以蓝色、24px的大小显示。`);", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-4-样式操作.md", "blockIndex": 0}
{"id": "js-sec-6-1-4", "title": "样式操作", "code": "// 模拟一个按钮元素\nconst actionButton = {\n  id: 'submit-btn',\n  style: {\n    padding: '10px',\n    border: '1px solid black'\n  }\n};\n\nconsole.log('按钮初始样式:', actionButton.style);\n\n// 使用驼峰命名法修改CSS属性\nactionButton.style.backgroundColor = '#28a745'; // CSS: background-color\nactionButton.style.borderRadius = '5px';      // CSS: border-radius\nactionButton.style.borderBottomWidth = '4px'; // CSS: border-bottom-width\n\nconsole.log('按钮修改后样式:', actionButton.style);\nconsole.log('注意: background-color 和 border-radius 都被转换为了驼峰命名法。');", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-4-样式操作.md", "blockIndex": 1}
{"id": "js-sec-6-1-4", "title": "样式操作", "code": "// 模拟一个带有classList API的卡片元素\nconst userCard = {\n  className: 'card', // 初始类名\n  // 模拟一个简单的classList对象\n  classList: {\n    _classes: ['card'],\n    add: function(className) { if(!this._classes.includes(className)) this._classes.push(className); this._updateHost(); },\n    remove: function(className) { this._classes = this._classes.filter(c => c !== className); this._updateHost(); },\n    toggle: function(className) { this.contains(className) ? this.remove(className) : this.add(className); },\n    contains: function(className) { return this._classes.includes(className); },\n    _updateHost: function() { userCard.className = this._classes.join(' '); }\n  }\n};\n\nconsole.log('初始类名:', userCard.className);\n\n// 添加一个 'active' 类\nuserCard.classList.add('active');\nconsole.log(\"添加 'active' 后:\", userCard.className);\n\n// 添加一个 'dark-theme' 类\nuserCard.classList.add('dark-theme');\nconsole.log(\"添加 'dark-theme' 后:\", userCard.className);\n\n// 移除 'active' 类\nuserCard.classList.remove('active');\nconsole.log(\"移除 'active' 后:\", userCard.className);\n\n// 切换 'dark-theme' 类 (它现在存在，所以会被移除)\nuserCard.classList.toggle('dark-theme');\nconsole.log(\"切换 'dark-theme' (第一次) 后:\", userCard.className);", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-4-样式操作.md", "blockIndex": 2}
{"id": "js-sec-6-1-4", "title": "样式操作", "code": "// 模拟一个需要添加状态类的元素\nconst playerAvatar = {\n  className: 'avatar rounded',\n  // 模拟 classList\n  classList: {\n    _classes: ['avatar', 'rounded'],\n    add: function(cls) { if (!this._classes.includes(cls)) { this._classes.push(cls); } playerAvatar.className = this._classes.join(' '); },\n  }\n};\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误：直接用 `className` 字符串拼接来添加新类\nconsole.log(\"操作前:\", playerAvatar.className);\nplayerAvatar.className += ' is-online'; // 注意前面需要加空格，容易出错\nconsole.log(\"错误操作后:\", playerAvatar.className);\nconsole.log(\"问题：这种方式繁琐且容易出错，比如忘记加空格会导致类名变成 'avatar roundedis-online'。如果想移除一个类，字符串操作会更复杂。\");\n\n\n// 重置状态\nplayerAvatar.className = 'avatar rounded';\nplayerAvatar.classList._classes = ['avatar', 'rounded'];\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确：使用 `classList.add()` 来添加新类\nconsole.log(\"操作前:\", playerAvatar.className);\nplayerAvatar.classList.add('is-online');\nconsole.log(\"正确操作后:\", playerAvatar.className);\nconsole.log(\"优点：`classList.add` 方法清晰、安全，无需关心空格或重复添加的问题，是管理类名的最佳实践。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-4-样式操作.md", "blockIndex": 3}
{"id": "js-sec-6-1-4", "title": "样式操作", "code": "// 模拟一个代表宠物的HTML元素\nconst petElement = {\n  // style 对象用于存储CSS样式\n  style: {\n    border: '2px solid black',\n    padding: '15px',\n    display: 'inline-block',\n    fontFamily: 'monospace',\n    lineHeight: '1.2',\n    transition: 'all 0.3s' // 想象一下平滑的过渡效果\n  },\n  // innerHTML 用于显示宠物的ASCII艺术形象\n  innerHTML: ''\n};\n\n// 定义不同心情对应的样式和形象\nconst moods = {\n  happy: {\n    borderColor: 'hsl(120, 70%, 50%)', // 鲜绿色\n    backgroundColor: 'hsl(120, 70%, 95%)',\n    icon: `\n  /\\\\_/\\\\\n ( ^.^ )\n (> . <)`\n  },\n  sad: {\n    borderColor: 'hsl(210, 30%, 50%)', // 忧郁蓝\n    backgroundColor: 'hsl(210, 30%, 95%)',\n    icon: `\n  /\\\\_/\\\\\n ( ._. )\n (  v  )`\n  },\n  curious: {\n    borderColor: 'hsl(45, 100%, 50%)', // 好奇黄\n    backgroundColor: 'hsl(45, 100%, 95%)',\n    icon: `\n  /\\\\_/\\\\\n ( o.O )\n (  ?  )`\n  }\n};\n\n// 更新宠物外观的函数\nfunction setPetMood(mood) {\n  console.log(`\\n===== 代码猫的心情变成了: ${mood.toUpperCase()}! =====`);\n\n  const newLook = moods[mood];\n  if (!newLook) {\n    console.log('未知的心情，代码猫表示很困惑...');\n    return;\n  }\n\n  // 1. 使用JS动态修改 style 属性\n  petElement.style.borderColor = newLook.borderColor;\n  petElement.style.backgroundColor = newLook.backgroundColor;\n\n  // 2. 更新宠物的ASCII形象\n  petElement.innerHTML = newLook.icon;\n\n  // 3. 打印出宠物的当前状态\n  console.log('代码猫现在的样子:');\n  console.log(petElement.innerHTML);\n  console.log('它的\"窝\"的样式:', petElement.style);\n}\n\n// 让我们来改变代码猫的心情！\nsetPetMood('happy');   // 代码猫很高兴，因为你开始学习JS了\nsetPetMood('sad');     // 代码猫很难过，因为它发现了一个bug\nsetPetMood('curious'); // 代码猫很好奇，想知道你接下来要学什么", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-4-样式操作.md", "blockIndex": 4}
{"id": "js-sec-6-1-5", "title": "元素创建与插入", "code": "// 在浏览器环境中运行此代码\n\n// 1. 创建一个新的 <p> 元素 (就像捏一个黏土小人)\nconst newParagraph = document.createElement('p');\n\n// 2. 给这个元素设置一些内容\nnewParagraph.textContent = '我是一个由JavaScript创建的新段落！';\n\n// 3. 将它添加到 <body> 元素的末尾 (把它放进玩具屋)\n// 注意: 在真实网页中，这行代码会直接在页面上显示新段落\ndocument.body.appendChild(newParagraph);\n\n// 为了在控制台看到结果，我们打印出 body 的 HTML 结构\nconsole.log('<body> 的当前内容:', document.body.innerHTML);", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-5-元素创建与插入.md", "blockIndex": 0}
{"id": "js-sec-6-1-5", "title": "元素创建与插入", "code": "// 在浏览器环境中运行此代码\n\n// 创建一个 <a> 链接元素\nconst myLink = document.createElement('a');\n\n// 设置它的文本内容\nmyLink.textContent = '访问我的作品集';\n\n// 设置它的属性\nmyLink.href = 'https://example.com';\nmyLink.target = '_blank'; // 在新标签页打开\nmyLink.className = 'portfolio-link important'; // 可以设置多个class\n\n// 创建一个 <img> 图片元素\nconst myImage = document.createElement('img');\nmyImage.src = 'https://placehold.co/100x50/purple/white?text=Logo';\nmyImage.alt = '一个占位符Logo';\nmyImage.id = 'main-logo';\n\n// 将它们添加到 body 中\ndocument.body.appendChild(myLink);\ndocument.body.appendChild(myImage);\n\nconsole.log('创建的链接元素:', myLink.outerHTML);\nconsole.log('创建的图片元素:', myImage.outerHTML);\nconsole.log('最终 Body 的内容:', document.body.innerHTML);", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-5-元素创建与插入.md", "blockIndex": 1}
{"id": "js-sec-6-1-5", "title": "元素创建与插入", "code": "// 在浏览器环境中运行此代码\n\n// 1. 准备一个父容器和两个已存在的子元素\nconst parentDiv = document.createElement('div');\nconst firstP = document.createElement('p');\nfirstP.textContent = '我是老大';\nconst secondP = document.createElement('p');\nsecondP.textContent = '我是老二';\n\nparentDiv.appendChild(firstP);\nparentDiv.appendChild(secondP);\ndocument.body.appendChild(parentDiv);\n\nconsole.log('初始状态:', parentDiv.innerHTML);\n\n// 2. 使用 appendChild 添加一个新元素，它会成为老三\nconst lastP = document.createElement('p');\nlastP.textContent = '我是新来的小弟 (appendChild)';\nparentDiv.appendChild(lastP);\n\nconsole.log('appendChild后:', parentDiv.innerHTML);\n\n// 3. 使用 insertBefore 将一个元素插入到老大（firstP）的前面\nconst newBoss = document.createElement('p');\nnewBoss.textContent = '我才是新老大 (insertBefore)';\nparentDiv.insertBefore(newBoss, firstP);\n\nconsole.log('insertBefore后:', parentDiv.innerHTML);", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-5-元素创建与插入.md", "blockIndex": 2}
{"id": "js-sec-6-1-5", "title": "元素创建与插入", "code": "// 在浏览器环境中运行此代码\n\nconst container = document.createElement('div');\ncontainer.id = 'my-container';\ndocument.body.appendChild(container);\n\nconsole.log(\"=== 错误用法 ===\");\ntry {\n  // ❌ 错误: appendChild 的参数必须是元素节点(Node)，而不是一个字符串。\n  const htmlString = '<span>我是一个字符串</span>';\n  container.appendChild(htmlString);\n} catch (error) {\n  console.error('出错了:', error.message);\n  console.log('🤔 为什么错了? appendChild() 方法期望接收一个通过 createElement() 创建的真实DOM元素对象，而不是一串描述HTML的文本。');\n}\nconsole.log('错误尝试后，容器内容:', container.innerHTML);\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确: 先用 createElement 创建元素，再进行添加。\nconst realElement = document.createElement('span');\nrealElement.textContent = '我是一个真正的元素！';\ncontainer.appendChild(realElement);\n\nconsole.log('✅ 为什么对了? 我们创建了一个span元素节点对象，这正是 appendChild() 所需要的。');\nconsole.log('正确操作后，容器内容:', container.innerHTML);", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-5-元素创建与插入.md", "blockIndex": 3}
{"id": "js-sec-6-1-5", "title": "元素创建与插入", "code": "// 在浏览器环境中运行此代码\n\n// --- 场景设置 ---\nconst petArea = document.createElement('div');\npetArea.style.border = '2px dashed skyblue';\npetArea.style.padding = '20px';\npetArea.style.fontFamily = 'Arial, sans-serif';\ndocument.body.appendChild(petArea);\n\nconst petName = document.createElement('h2');\npetName.textContent = '🐶 我的宠物：旺财';\npetArea.appendChild(petName);\n\nconst moodContainer = document.createElement('div');\nmoodContainer.id = 'mood-container';\nmoodContainer.style.marginTop = '10px';\nmoodContainer.textContent = '心情：';\npetArea.appendChild(moodContainer);\n\nconsole.log(\"🌟 虚拟宠物小屋已建成！准备开始喂食... 🌟\");\n\n// --- 核心功能：喂食函数 ---\nfunction feedPet(food) {\n  let moodEmoji = '';\n  let moodText = '';\n\n  // 根据不同食物决定心情\n  switch (food) {\n    case '骨头':\n      moodEmoji = '🦴';\n      moodText = '开心得摇尾巴！';\n      break;\n    case '蔬菜':\n      moodEmoji = '🥦';\n      moodText = '虽然健康，但有点不情愿...';\n      break;\n    case '牛排':\n      moodEmoji = '🥩';\n      moodText = '天呐！是牛排！幸福感爆棚！';\n      break;\n    default:\n      moodEmoji = '❓';\n      moodText = '这是什么奇怪的东西？';\n  }\n\n  // 1. 创建一个新的心情气泡元素 (<span>)\n  const moodBubble = document.createElement('span');\n  moodBubble.textContent = moodEmoji;\n  moodBubble.title = moodText; // 鼠标悬停时显示心情文字\n  moodBubble.style.fontSize = '2rem';\n  moodBubble.style.margin = '0 5px';\n  moodBubble.style.cursor = 'pointer';\n  moodBubble.style.display = 'inline-block';\n  moodBubble.style.animation = 'fadeIn 0.5s'; // 添加一点小动画\n\n  // 2. 将新的心情气泡插入到心情容器中\n  moodContainer.appendChild(moodBubble);\n\n  console.log(`你喂了旺财一个【${food}】。看，它有了新的心情：${moodEmoji}`);\n}\n\n// 模拟用户进行几次喂食操作\nfeedPet('骨头');\nfeedPet('蔬菜');\nfeedPet('牛排');\n\n// 为了让动画效果更明显，我们可以在CSS中定义\nconst style = document.createElement('style');\nstyle.textContent = `\n  @keyframes fadeIn {\n    from { opacity: 0; transform: scale(0.5); }\n    to { opacity: 1; transform: scale(1); }\n  }\n`;\ndocument.head.appendChild(style);\n\nconsole.log(\"\\n--- 最终宠物状态 ---\");\nconsole.log(petArea.innerHTML);", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-5-元素创建与插入.md", "blockIndex": 4}
{"id": "js-sec-6-1-6", "title": "元素删除", "code": "// 模拟一个父元素<div>和一些子元素<p>\nconst parent = document.createElement('div');\nparent.innerHTML = `\n  <p id=\"p1\">段落一</p>\n  <p id=\"p2\">段落二（即将被删除）</p>\n  <p id=\"p3\">段落三</p>\n`;\ndocument.body.appendChild(parent); // 假装添加到页面上\n\n// 选中要删除的元素\nconst elementToRemove = parent.querySelector('#p2');\n\nconsole.log(\"删除前，父元素内容：\", parent.innerHTML.replace(/\\n\\s*/g, ''));\n\n// 直接在元素上调用 remove()\nelementToRemove.remove();\n\nconsole.log(\"删除后，父元素内容：\", parent.innerHTML.replace(/\\n\\s*/g, ''));\n\n// 清理模拟的DOM\ndocument.body.removeChild(parent);", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-6-元素删除.md", "blockIndex": 0}
{"id": "js-sec-6-1-6", "title": "元素删除", "code": "// 模拟DOM结构\nconst parent = document.createElement('div');\nparent.innerHTML = `\n  <p id=\"child1\">子元素1</p>\n  <p id=\"child2\">子元素2（目标）</p>\n`;\ndocument.body.appendChild(parent);\n\nconst childToRemove = parent.querySelector('#child2');\nconst parentElement = childToRemove.parentNode; // 获取父元素\n\nconsole.log(\"父元素是:\", parentElement.tagName);\nconsole.log(\"即将删除的子元素是:\", childToRemove.id);\n\n// 从父元素中删除子元素\nconst removedElement = parentElement.removeChild(childToRemove);\n\nconsole.log(\"被删除的元素是:\", removedElement.id);\nconsole.log(\"操作后，父元素还存在吗？\", !!document.querySelector('div'));\nconsole.log(\"操作后，父元素内容：\", parent.innerHTML.trim());\n\ndocument.body.removeChild(parent);", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-6-元素删除.md", "blockIndex": 1}
{"id": "js-sec-6-1-6", "title": "元素删除", "code": "// 模拟DOM\nconst container = document.createElement('div');\ncontainer.innerHTML = `\n    <div id=\"item-a\">项目A</div>\n    <div id=\"item-b\">项目B</div>\n`;\ndocument.body.appendChild(container);\n\n// 使用 remove()\nconst itemA = container.querySelector('#item-a');\nconsole.log(\"使用 remove() 删除 item-a\");\nitemA.remove(); // 无返回值\nconsole.log(\"container 内容:\", container.innerHTML.trim());\n\n\n// 使用 removeChild()\nconst itemB = container.querySelector('#item-b');\nconsole.log(\"\\n使用 removeChild() 删除 item-b\");\nconst deletedItemB = container.removeChild(itemB); // 返回被删除的元素\nconsole.log(\"removeChild() 返回了:\", deletedItemB.id);\nconsole.log(\"container 内容:\", container.innerHTML.trim());\n\ndocument.body.removeChild(container);", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-6-元素删除.md", "blockIndex": 2}
{"id": "js-sec-6-1-6", "title": "元素删除", "code": "// 模拟DOM\nconst list = document.createElement('ul');\nlist.innerHTML = `\n  <li id=\"task-1\">任务1</li>\n  <li id=\"task-2\">任务2</li>\n`;\ndocument.body.appendChild(list);\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 试图用 removeChild 删除一个不属于其直接子元素的元素\nconst otherList = document.createElement('ul');\nconst task1 = list.querySelector('#task-1');\ntry {\n  otherList.removeChild(task1);\n} catch (e) {\n  console.log(\"错误！\", e.message);\n  console.log(\"解释：不能在一个元素下删除另一个不相干的元素。\");\n}\n\n\nconsole.log(\"\\n=== 正确用法 vs 清空内容 ===\");\n// ✅ 正确删除一个元素\nconst task2 = list.querySelector('#task-2');\nlist.removeChild(task2);\nconsole.log(\"正确删除后，列表内容:\", list.innerHTML.trim());\n\n// 💡 对比：使用 innerHTML = '' 清空所有子元素\nlist.innerHTML = '<li>新任务</li>'; // 添加一个新任务以便演示\nconsole.log(\"\\n清空前:\", list.innerHTML);\nlist.innerHTML = '';\nconsole.log(\"使用 innerHTML='' 清空后:\", \"列表内容为空\");\nconsole.log(\"列表<ul>本身还在吗?\", !!document.querySelector('ul'));\n// 解释：`removeChild` 或 `remove` 是精确删除，而 `innerHTML = ''` 是清空一个元素的所有后代，但该元素本身仍然存在。\n\ndocument.body.removeChild(list);", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-6-元素删除.md", "blockIndex": 3}
{"id": "js-sec-6-1-6", "title": "元素删除", "code": "// --- 模拟场景 ---\n// 创建必要的DOM元素\ndocument.body.innerHTML = `\n  <div id=\"pizza-app\">\n    <h3>可选配料</h3>\n    <ul id=\"ingredients\">\n      <li data-name=\"蘑菇\">蘑菇 🍄 <button>添加</button></li>\n      <li data-name=\"青椒\">青椒 🌶️ <button>添加</button></li>\n      <li data-name=\"香肠\">香肠 🌭 <button>添加</button></li>\n    </ul>\n    <h3>你的披萨</h3>\n    <div id=\"pizza\">\n      <div id=\"toppings\"></div>\n      <div class=\"base\"></div>\n    </div>\n  </div>\n`;\n\nconst ingredientsList = document.getElementById('ingredients');\nconst pizzaToppings = document.getElementById('toppings');\n\n// 使用事件委托来处理所有按钮点击\ndocument.getElementById('pizza-app').addEventListener('click', function(e) {\n  // 如果点击的是“添加”按钮\n  if (e.target.tagName === 'BUTTON' && e.target.textContent === '添加') {\n    const ingredientItem = e.target.parentElement;\n    const name = ingredientItem.dataset.name;\n    \n    // 创建一个配料元素并添加到披萨上\n    const topping = document.createElement('div');\n    topping.className = 'topping';\n    topping.textContent = ingredientItem.textContent.replace(' 添加', '');\n    topping.dataset.name = name;\n    \n    // 添加一个移除按钮\n    const removeBtn = document.createElement('button');\n    removeBtn.textContent = '移除';\n    topping.appendChild(removeBtn);\n    \n    pizzaToppings.appendChild(topping);\n    console.log(`已添加 ${name} 到披萨上！`);\n  }\n  \n  // 如果点击的是“移除”按钮\n  if (e.target.tagName === 'BUTTON' && e.target.textContent === '移除') {\n    const toppingToRemove = e.target.parentElement;\n    const name = toppingToRemove.dataset.name;\n    \n    // 使用 remove() 直接删除配料元素\n    toppingToRemove.remove();\n    console.log(`已从披萨上移除 ${name}！`);\n  }\n});\n\n// 模拟一次点击\nconsole.log(\"--- 披萨制作开始 ---\");\nconst addButton = ingredientsList.querySelector('li[data-name=\"蘑菇\"] button');\naddButton.click(); // 模拟添加蘑菇\n\n// 模拟移除\nsetTimeout(() => {\n    const removeButton = pizzaToppings.querySelector('.topping[data-name=\"蘑菇\"] button');\n    if(removeButton) removeButton.click(); // 模拟移除蘑菇\n}, 1000);\n\n// 清理模拟的DOM\n// 在真实应用中不需要下面这行\n// setTimeout(() => document.body.innerHTML = '', 2000);", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-1-6-元素删除.md", "blockIndex": 4}
{"id": "js-sec-6-2-1", "title": "事件监听", "code": "// 模拟一个HTML按钮\ndocument.body.innerHTML = '<button id=\"myBtn\">点我</button>';\nconst myButton = document.getElementById('myBtn');\n\n// 1. 获取元素\n// const myButton = document.getElementById('myBtn');\n\n// 2. 添加事件监听器\n// 参数1: 事件类型 ('click')\n// 参数2: 回调函数 (事件发生时要做的事)\nmyButton.addEventListener('click', function() {\n  console.log(\"按钮被点击了！这是一个来自 addEventListener 的响应。\");\n});\n\n// 3. 在代码中模拟一次点击来触发事件\nconsole.log(\"正在等待用户点击按钮...\");\nmyButton.click(); // 这会触发上面定义的监听器\n\n// 清理模拟的DOM\ndocument.body.innerHTML = '';", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-1-事件监听.md", "blockIndex": 0}
{"id": "js-sec-6-2-1", "title": "事件监听", "code": "// 模拟HTML按钮\ndocument.body.innerHTML = '<button id=\"taskBtn\">完成任务</button>';\nconst taskButton = document.getElementById('taskBtn');\n\n// 监听器 1: 记录日志\ntaskButton.addEventListener('click', () => {\n  console.log(\"日志：任务按钮被点击。\");\n});\n\n// 监听器 2: 更新UI\ntaskButton.addEventListener('click', () => {\n  console.log(\"UI更新：按钮变为灰色，显示“已完成”。\");\n  // taskButton.disabled = true; // 在真实浏览器中会禁用按钮\n});\n\n// 监听器 3: 发送分析数据\ntaskButton.addEventListener('click', () => {\n  console.log(\"分析：发送'task_completed'事件到服务器。\");\n});\n\n// 模拟点击，所有监听器都会被触发\ntaskButton.click();\n\ndocument.body.innerHTML = '';", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-1-事件监听.md", "blockIndex": 1}
{"id": "js-sec-6-2-1", "title": "事件监听", "code": "// 模拟HTML\ndocument.body.innerHTML = '<div>这是一个可以关闭的弹窗</div>';\nconst popup = document.querySelector('div'); // 使用querySelector以匹配模拟的DOM\n\n// 定义一个具名函数作为回调，这样才能移除它\nfunction showWarning() {\n  console.log(\"警告：弹窗即将自动关闭！\");\n}\n\n// 添加监听：鼠标移入时显示警告\npopup.addEventListener('mouseenter', showWarning);\nconsole.log(\"监听器已添加。请将鼠标移入弹窗。\");\n\n// 模拟鼠标移入\npopup.dispatchEvent(new Event('mouseenter'));\n\n// 移除监听器\npopup.removeEventListener('mouseenter', showWarning);\nconsole.log(\"监听器已移除。\");\n\n// 再次模拟鼠标移入，这次什么都不会发生\nconsole.log(\"再次将鼠标移入弹窗...\");\npopup.dispatchEvent(new Event('mouseenter'));\nconsole.log(\"...没有任何日志输出，因为监听器已被成功移除。\");\n\ndocument.body.innerHTML = '';", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-1-事件监听.md", "blockIndex": 2}
{"id": "js-sec-6-2-1", "title": "事件监听", "code": "// 模拟HTML按钮\ndocument.body.innerHTML = '<button id=\"compareBtn\">对比按钮</button>';\nconst compareButton = document.getElementById('compareBtn');\n\nconsole.log(\"=== 错误/受限用法 (onclick) ===\");\n// ❌ 使用 onclick 属性\ncompareButton.onclick = function() {\n  console.log(\"第一个 onclick 处理器。\");\n};\n\n// 再次赋值会覆盖掉前一个！\ncompareButton.onclick = function() {\n  console.log(\"第二个 onclick 处理器，它覆盖了第一个！\");\n};\n// 模拟点击，只有最后一个赋值的函数会执行\ncompareButton.click();\nconsole.log(\"解释：onclick 属性只能容纳一个函数，新的赋值会覆盖旧的。\");\n\n\nconsole.log(\"\\n=== 正确/推荐用法 (addEventListener) ===\");\n// ✅ 使用 addEventListener\ncompareButton.addEventListener('click', function() {\n  console.log(\"第一个 addEventListener 监听器。\");\n});\n\ncompareButton.addEventListener('click', function() {\n  console.log(\"第二个 addEventListener 监听器，它不会覆盖第一个。\");\n});\n// 再次模拟点击，所有通过 addEventListener 添加的函数都会执行\ncompareButton.click();\nconsole.log(\"解释：addEventListener 允许为同一事件附加任意多个监听器。\");\n\ndocument.body.innerHTML = '';", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-1-事件监听.md", "blockIndex": 3}
{"id": "js-sec-6-2-1", "title": "事件监听", "code": "// --- 场景设置 ---\ndocument.body.innerHTML = '\n  <h3>迷你像素画板</h3>\n  <div id=\"pixel-board\" style=\"display: grid; grid-template-columns: repeat(10, 20px); width: 200px; border: 1px solid #ccc;\">\n    <!-- JS将在这里生成像素点 -->\n  </div>\n  <small>在画板上按住鼠标移动来绘画</small>\n';\nconst board = document.getElementById('pixel-board');\nlet isDrawing = false;\n\n// 生成 10x10 的像素格子\nfor (let i = 0; i < 100; i++) {\n  const pixel = document.createElement('div');\n  pixel.style.width = '20px';\n  pixel.style.height = '20px';\n  pixel.style.backgroundColor = '#eee';\n  pixel.style.border = '1px solid #fff';\n  board.appendChild(pixel);\n  \n  // 监听：当鼠标进入一个像素格子时\n  pixel.addEventListener('mouseover', function(event) {\n    // 如果鼠标是按下的状态，就给这个像素上色\n    if (isDrawing) {\n      event.target.style.backgroundColor = '#3498db';\n    }\n  });\n}\n\n// 监听：在整个画板上按下鼠标\nboard.addEventListener('mousedown', function(event) {\n  isDrawing = true;\n  console.log(\"开始绘画！\");\n  // 让被点击的第一个像素也上色\n  if (event.target !== board) {\n      event.target.style.backgroundColor = '#3498db';\n  }\n});\n\n// 监听：在整个窗口松开鼠标\nwindow.addEventListener('mouseup', function() {\n  if (isDrawing) {\n    isDrawing = false;\n    console.log(\"停止绘画！\");\n  }\n});\n\n// --- 模拟一次绘画动作 ---\nconsole.log(\"模拟用户在画板上按下鼠标，并划过几个像素...\");\nconst firstPixel = board.children[11];\nboard.dispatchEvent(new MouseEvent('mousedown', { bubbles: true }));\nfirstPixel.dispatchEvent(new MouseEvent('mouseover', { bubbles: true }));\nboard.children[12].dispatchEvent(new MouseEvent('mouseover', { bubbles: true }));\nwindow.dispatchEvent(new MouseEvent('mouseup'));\n\n// 清理\n// setTimeout(() => document.body.innerHTML = '', 2000);", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-1-事件监听.md", "blockIndex": 4}
{"id": "js-sec-6-2-2", "title": "事件对象", "code": "// 为了让代码在任何地方都能独立运行，我们用JS创建HTML元素\ndocument.body.innerHTML = '<button id=\"myButton\">点我一下</button>';\n\nconst myButton = document.getElementById('myButton');\n\n// 当按钮被点击时，handleClick函数会自动接收到 event 对象\nfunction handleClick(event) {\n  console.log(\"事件触发了！\");\n  console.log(\"这是自动传入的事件对象:\", event);\n  console.log(\"事件类型是:\", event.type); // \"click\"\n  console.log(\"事件发生在哪个元素上？\", event.target); // <button id=\"myButton\">\n}\n\nmyButton.addEventListener('click', handleClick);\n\nconsole.log(\"请点击上面的 '点我一下' 按钮，查看控制台输出。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-2-事件对象.md", "blockIndex": 0}
{"id": "js-sec-6-2-2", "title": "事件对象", "code": "// 场景：一个div容器里有一个按钮，我们只在容器上监听点击事件\ndocument.body.innerHTML = `\n  <div id=\"container\" style=\"padding: 20px; border: 2px solid blue;\">\n    我是容器(div)\n    <button id=\"innerButton\" style=\"margin-left: 10px;\">我是按钮(button)</button>\n  </div>\n`;\n\nconst container = document.getElementById('container');\n\ncontainer.addEventListener('click', function(event) {\n  console.log(\"事件监听器绑定在 div 上。\");\n  \n  // event.target 是你实际点击的那个东西\n  console.log(\"event.target:\", event.target.tagName, `(ID: ${event.target.id})`); \n  \n  // event.currentTarget 永远是绑定监听器的那个元素，即 div\n  console.log(\"event.currentTarget:\", event.currentTarget.tagName, `(ID: ${event.currentTarget.id})`);\n\n  console.log(\"---\");\n  console.log(\"尝试分别点击按钮和它外面的蓝色边框区域，观察区别。\");\n});", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-2-事件对象.md", "blockIndex": 1}
{"id": "js-sec-6-2-2", "title": "事件对象", "code": "document.body.innerHTML = `\n  <div id=\"tracker\" style=\"width: 300px; height: 150px; border: 2px dashed red; background-color: #f0f0f0;\">\n    在红色虚线框内移动鼠标\n  </div>\n`;\n\nconst tracker = document.getElementById('tracker');\n\ntracker.addEventListener('mousemove', function(event) {\n  // event.clientX 是鼠标相对于浏览器窗口左边的距离\n  const x = event.clientX;\n  // event.clientY 是鼠标相对于浏览器窗口顶边的距离\n  const y = event.clientY;\n\n  // 为了避免刷屏，我们不会一直打印，但可以更新元素内容\n  tracker.textContent = `鼠标坐标: X=${x}, Y=${y}`;\n  \n  // 在控制台输出一次，方便查看\n  console.clear(); // 清空控制台，避免信息泛滥\n  console.log(`鼠标在窗口中的位置: X=${x}, Y=${y}`);\n});", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-2-事件对象.md", "blockIndex": 2}
{"id": "js-sec-6-2-2", "title": "事件对象", "code": "document.body.innerHTML = '<input type=\"text\" id=\"keyInput\" placeholder=\"在此输入文字...\" />';\n\nconst keyInput = document.getElementById('keyInput');\n\nkeyInput.addEventListener('keydown', function(event) {\n  console.log(\"--- 键盘按键事件 ---\");\n  console.log(`你按下的键 (event.key): \"${event.key}\"`);\n  console.log(`对应的物理按键 (event.code): \"${event.code}\"`);\n  \n  if (event.key === 'Enter') {\n    console.warn(\"你按下了回车键！准备提交表单？\");\n  }\n});\n\nconsole.log(\"请点击输入框并尝试按不同的键（比如 a, Shift+a, Enter, 空格），观察控制台输出。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-2-事件对象.md", "blockIndex": 3}
{"id": "js-sec-6-2-2", "title": "事件对象", "code": "// 场景：一个购物清单，我们想知道用户点击了哪个具体的水果\ndocument.body.innerHTML = `\n  <h3>点击下面的水果：</h3>\n  <ul id=\"fruitList\" style=\"cursor: pointer;\">\n    <li>🍎 苹果</li>\n    <li>🍌 香蕉</li>\n    <li>🍓 草莓</li>\n  </ul>\n`;\n\nconst fruitList = document.getElementById('fruitList');\n\nfruitList.addEventListener('click', function(event) {\n  console.log(\"=== 错误用法 ===\");\n  // ❌ 错误：试图用 currentTarget 获取被点击项的文本\n  // event.currentTarget 永远是 <ul> 本身，所以 textContent 会包含所有 <li> 的内容\n  const allFruitsText = event.currentTarget.textContent;\n  console.log(\"currentTarget 的文本内容:\", allFruitsText.replace(/\\s+/g, ' ').trim());\n  console.log(\"为什么错了？因为它获取了整个列表的文本，而不是你点击的那一项。\");\n\n  console.log(\"\\n=== 正确用法 ===\");\n  // ✅ 正确：使用 target 来精确定位被点击的 <li> 元素\n  // event.target 就是你实际点击的那个 <li>\n  if (event.target.tagName === 'LI') {\n    const clickedFruitText = event.target.textContent;\n    console.log(\"你点击的水果是:\", clickedFruitText);\n    console.log(\"为什么对了？因为它准确地捕获到了事件的源头——被点击的 <li>。\");\n  }\n});", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-2-事件对象.md", "blockIndex": 4}
{"id": "js-sec-6-2-2", "title": "事件对象", "code": "// --- 准备工作：创建HTML和CSS ---\nconst boardSize = 10; // 10x10 的画板\nlet currentBrushColor = 'crimson'; // 默认画笔颜色\n\n// 创建一个调色板\nconst colors = ['crimson', 'dodgerblue', 'mediumseagreen', 'gold', 'slateblue', 'black', 'white'];\nlet paletteHTML = '<div><strong>选择颜色:</strong> ';\ncolors.forEach(color => {\n  paletteHTML += `<span class=\"color-box\" style=\"background-color:${color};\" data-color=\"${color}\"></span>`;\n});\npaletteHTML += '</div>';\n\n// 创建像素画板的格子\nlet boardHTML = '<div id=\"pixel-board\">';\nfor (let i = 0; i < boardSize * boardSize; i++) {\n  boardHTML += '<div class=\"pixel\"></div>';\n}\nboardHTML += '</div>';\n\n// 将画板和调色板添加到页面\ndocument.body.innerHTML = `\n  <style>\n    #pixel-board { display: grid; grid-template-columns: repeat(${boardSize}, 30px); border: 2px solid #333; width: ${boardSize * 30}px; }\n    .pixel { width: 30px; height: 30px; background-color: #eee; border: 1px solid #ddd; }\n    .pixel:hover { border-color: #999; }\n    .color-box { display: inline-block; width: 25px; height: 25px; border: 2px solid #fff; margin: 0 5px; cursor: pointer; vertical-align: middle; }\n    .color-box.selected { border-color: black; transform: scale(1.2); }\n  </style>\n  <h2>🎨 迷你像素画板 🎨</h2>\n  <div id=\"palette\">${paletteHTML}</div>\n  <p>点击下方格子进行绘画！</p>\n  ${boardHTML}\n`;\n\n// --- 核心交互逻辑 ---\nconst pixelBoard = document.getElementById('pixel-board');\nconst palette = document.getElementById('palette');\n\n// 1. 监听整个画板的点击事件\npixelBoard.addEventListener('click', function(event) {\n  // event.target 就是我们点击的那个 .pixel 元素！\n  const clickedPixel = event.target;\n\n  // 确保我们点击的是像素格，而不是格子之间的缝隙\n  if (clickedPixel.classList.contains('pixel')) {\n    clickedPixel.style.backgroundColor = currentBrushColor;\n    console.log(`🎨 你用 [${currentBrushColor}] 颜色在某个像素上画了一笔！艺术诞生了！`);\n  }\n});\n\n// 2. 监听调色板的点击事件，用于更换画笔颜色\npalette.addEventListener('click', function(event) {\n  const clickedColorBox = event.target;\n  \n  if (clickedColorBox.classList.contains('color-box')) {\n    // 获取颜色\n    currentBrushColor = clickedColorBox.dataset.color;\n    \n    // 更新视觉提示\n    document.querySelectorAll('.color-box').forEach(box => box.classList.remove('selected'));\n    clickedColorBox.classList.add('selected');\n    \n    console.log(`🖌️ 画笔颜色已切换为 [${currentBrushColor}]。准备挥洒创意吧！`);\n  }\n});\n\n// 初始化时给第一个颜色添加选中状态\ndocument.querySelector('.color-box').classList.add('selected');", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-2-事件对象.md", "blockIndex": 5}
{"id": "js-sec-6-2-3", "title": "事件冒泡与捕获", "code": "// 请在浏览器中运行以下代码。\n// 需要以下HTML结构:\n// <div id=\"grandparent\">\n//   <div id=\"parent\">\n//     <div id=\"child\">Click Me</div>\n//   </div>\n// </div>\n// 为了让代码块独立可运行，我们用JS动态创建这些元素。\n\n// 1. 创建DOM元素\nconst grandparent = document.createElement('div');\ngrandparent.id = 'grandparent';\ngrandparent.style.padding = '30px';\ngrandparent.style.backgroundColor = 'lightcoral';\n\nconst parent = document.createElement('div');\nparent.id = 'parent';\nparent.style.padding = '20px';\nparent.style.backgroundColor = 'lightblue';\n\nconst child = document.createElement('div');\nchild.id = 'child';\nchild.textContent = 'Click Me';\nchild.style.padding = '10px';\nchild.style.backgroundColor = 'lightgreen';\n\nparent.appendChild(child);\ngrandparent.appendChild(parent);\ndocument.body.appendChild(grandparent);\n\n// 2. 添加事件监听器\nchild.addEventListener('click', () => {\n  console.log('气泡 1: 我是 \"child\" DIV，我被点击了！');\n});\n\nparent.addEventListener('click', () => {\n  console.log('气泡 2: 我是 \"parent\" DIV，我的气泡也触发了！');\n});\n\ngrandparent.addEventListener('click', () => {\n  console.log('气泡 3: 我是 \"grandparent\" DIV，气泡最终到达了我这里！');\n});\n\nconsole.log(\"准备就绪！请点击页面上绿色的 'Click Me' 区域查看事件冒泡效果。\");\n// 点击后，你会看到控制台按顺序输出：child -> parent -> grandparent", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-3-事件冒泡与捕获.md", "blockIndex": 0}
{"id": "js-sec-6-2-3", "title": "事件冒泡与捕获", "code": "// 同样，我们用JS动态创建HTML结构。\ndocument.body.innerHTML = ''; // 清空页面，避免与上一个例子冲突\nconst grandparent = document.createElement('div');\ngrandparent.id = 'grandparent';\ngrandparent.style.padding = '30px';\ngrandparent.style.backgroundColor = 'lightcoral';\n\nconst parent = document.createElement('div');\nparent.id = 'parent';\nparent.style.padding = '20px';\nparent.style.backgroundColor = 'lightblue';\n\nconst child = document.createElement('div');\nchild.id = 'child';\nchild.textContent = 'Click Me';\nchild.style.padding = '10px';\nchild.style.backgroundColor = 'lightgreen';\n\nparent.appendChild(child);\ngrandparent.appendChild(parent);\ndocument.body.appendChild(grandparent);\n\n// 在捕获阶段监听 (useCapture = true)\ngrandparent.addEventListener('click', () => console.log('捕获阶段: Grandparent'), true);\nparent.addEventListener('click', () => console.log('捕获阶段: Parent'), true);\nchild.addEventListener('click', () => console.log('捕获阶段: Child (目标)'), true);\n\n// 在冒泡阶段监听 (useCapture = false, 默认)\ngrandparent.addEventListener('click', () => console.log('冒泡阶段: Grandparent'), false);\nparent.addEventListener('click', () => console.log('冒泡阶段: Parent'), false);\nchild.addEventListener('click', () => console.log('冒泡阶段: Child (目标)'), false);\n\nconsole.log(\"准备就绪！点击绿色区域，观察完整的事件流。\");\n// 预期输出顺序:\n// 捕获阶段: Grandparent\n// 捕获阶段: Parent\n// 捕获阶段: Child (目标)\n// 冒泡阶段: Child (目标)\n// 冒泡阶段: Parent\n// 冒泡阶段: Grandparent", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-3-事件冒泡与捕获.md", "blockIndex": 1}
{"id": "js-sec-6-2-3", "title": "事件冒泡与捕获", "code": "// 动态创建HTML结构\ndocument.body.innerHTML = '';\nconst parentDiv = document.createElement('div');\nparentDiv.id = 'parent';\nparentDiv.style.padding = '20px';\nparentDiv.style.backgroundColor = 'lightblue';\nparentDiv.textContent = '我是父容器，点击按钮试试。';\n\nconst button = document.createElement('button');\nbutton.id = 'myButton';\nbutton.textContent = '点我，但别打扰我父亲！';\nbutton.style.display = 'block';\nbutton.style.marginTop = '10px';\n\nparentDiv.appendChild(button);\ndocument.body.appendChild(parentDiv);\n\n// 父容器的监听器\nparentDiv.addEventListener('click', () => {\n  console.log('父容器的点击事件被触发了！哦不！');\n});\n\n// 按钮的监听器\nbutton.addEventListener('click', (event) => {\n  // 阻止事件继续向上传播\n  event.stopPropagation();\n  console.log('按钮被点击了！我已经阻止了事件冒泡，父容器不会知道这件事。');\n});\n\nconsole.log(\"准备就绪！点击按钮，观察父容器的事件是否被触发。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-3-事件冒泡与捕获.md", "blockIndex": 2}
{"id": "js-sec-6-2-3", "title": "事件冒泡与捕获", "code": "// 动态创建HTML结构\ndocument.body.innerHTML = '';\nconst modalOverlay = document.createElement('div');\nmodalOverlay.id = 'modal-overlay';\nmodalOverlay.style.position = 'fixed';\nmodalOverlay.style.top = '0';\nmodalOverlay.style.left = '0';\nmodalOverlay.style.width = '100%';\nmodalOverlay.style.height = '100%';\nmodalOverlay.style.backgroundColor = 'rgba(0,0,0,0.5)';\nmodalOverlay.style.display = 'flex';\nmodalOverlay.style.justifyContent = 'center';\nmodalOverlay.style.alignItems = 'center';\n\nconst modalContent = document.createElement('div');\nmodalContent.id = 'modal-content';\nmodalContent.style.padding = '30px';\nmodalContent.style.backgroundColor = 'white';\nmodalContent.textContent = '我是弹窗内容，点击我时，我不应该关闭。';\n\nmodalOverlay.appendChild(modalContent);\ndocument.body.appendChild(modalOverlay);\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误做法：直接在遮罩层上添加关闭事件\n// 解释：当点击弹窗内容(modalContent)时，点击事件会冒泡到遮罩层(modalOverlay)，\n// 从而触发了关闭逻辑，导致弹窗意外关闭。\nmodalOverlay.addEventListener('click', () => {\n  console.log('❌ 错误的方式：遮罩层被点击，弹窗关闭...即使我点的是内容！');\n  // modalOverlay.style.display = 'none'; // 实际会在这里隐藏弹窗\n});\n\nconsole.log(\"=== 正确用法 ===\");\n// ✅ 正确做法：检查事件的直接目标 (event.target)\n// 解释：我们只在点击事件的直接来源(e.target)是遮罩层本身时，才执行关闭操作。\n// e.currentTarget 指的是监听器所在的元素(modalOverlay)，\n// e.target 指的是用户实际点击的元素。\nmodalOverlay.addEventListener('click', (e) => {\n  if (e.target === e.currentTarget) {\n    console.log('✅ 正确的方式：只有当我直接点击遮罩层时，弹窗才会关闭。');\n    // modalOverlay.style.display = 'none';\n  } else {\n    console.log('✅ 正确的方式：你点击的是弹窗内容，所以弹窗不关闭。');\n  }\n});\n\nconsole.log(\"准备就绪！分别点击弹窗内容和弹窗外的灰色区域，观察控制台输出的不同。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-3-事件冒泡与捕获.md", "blockIndex": 3}
{"id": "js-sec-6-2-3", "title": "事件冒泡与捕获", "code": "// 动态创建游戏场景\ndocument.body.innerHTML = '';\nconst gameBoard = document.createElement('div');\ngameBoard.id = 'game-board';\ngameBoard.style.display = 'grid';\ngameBoard.style.gridTemplateColumns = 'repeat(3, 100px)';\ngameBoard.style.gap = '10px';\ngameBoard.style.padding = '10px';\ngameBoard.style.backgroundColor = '#8B4513';\ngameBoard.style.border = '5px solid #D2691E';\ngameBoard.style.borderRadius = '10px';\ndocument.body.appendChild(gameBoard);\n\nlet score = 0;\n\n// 创建地洞\nfor (let i = 0; i < 9; i++) {\n  const hole = document.createElement('div');\n  hole.classList.add('hole');\n  hole.style.width = '100px';\n  hole.style.height = '100px';\n  hole.style.backgroundColor = '#A0522D';\n  hole.style.borderRadius = '50%';\n  hole.style.position = 'relative';\n  hole.style.overflow = 'hidden';\n  gameBoard.appendChild(hole);\n}\n\n// 随机出现一只地鼠\nfunction popMole() {\n  const holes = document.querySelectorAll('.hole');\n  // 清除上一只地鼠\n  const existingMole = document.querySelector('.mole');\n  if (existingMole) existingMole.remove();\n\n  // 随机选一个洞\n  const randomIndex = Math.floor(Math.random() * holes.length);\n  const randomHole = holes[randomIndex];\n\n  // 创建地鼠\n  const mole = document.createElement('div');\n  mole.classList.add('mole');\n  mole.textContent = '🐹'; // 地鼠 emoji\n  mole.style.fontSize = '50px';\n  mole.style.textAlign = 'center';\n  mole.style.lineHeight = '100px';\n  mole.style.cursor = 'pointer';\n  mole.style.userSelect = 'none';\n  randomHole.appendChild(mole);\n}\n\n// 游戏开始！\nconsole.log(\"--- 欢迎来到打地鼠游戏！ ---\");\nconsole.log(\"点击 🐹 来得分！点击空地洞会发生什么呢？\");\n\n// 关键：只在父容器上添加一个事件监听器！\ngameBoard.addEventListener('click', (event) => {\n  // event.target 是我们实际点击的元素\n  const clickedElement = event.target;\n\n  // 检查我们是否点中了地鼠 (它有 'mole' class)\n  if (clickedElement.classList.contains('mole')) {\n    score++;\n    console.log(`💥 命中！你打中了地鼠！当前得分: ${score}`);\n    clickedElement.remove(); // 地鼠被打中后消失\n  } else if (clickedElement.classList.contains('hole')) {\n    console.log(\"💨 挥空了！你点到了一个空洞。\");\n  } else {\n    // 这种情况可能点到了 gameBoard 的 padding\n    console.log(\"🌳 你点到了草地...地鼠还在洞里呢。\");\n  }\n});\n\n// 每隔1.5秒出现一只新地鼠\nsetInterval(popMole, 1500);", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-3-事件冒泡与捕获.md", "blockIndex": 4}
{"id": "js-sec-6-2-4", "title": "事件委托", "code": "// 模拟一个DOM环境，以便在任何JS环境中运行\nfunction createMockElement(tagName, id = '', children = []) {\n  const element = {\n    tagName: tagName.toUpperCase(),\n    id: id,\n    children: children,\n    addEventListener: function(type, listener) {\n      this._listener = listener; // 存储监听器\n      console.log(`事件监听器已附加到 <${this.tagName.toLowerCase()} id=\"${this.id}\">`);\n    },\n    // 模拟点击事件，事件会从被点击的子元素“冒泡”到父元素\n    simulateClick: function(targetChild) {\n      const event = {\n        target: targetChild, // 真正被点击的元素\n        currentTarget: this, // 监听器所在的元素\n      };\n      console.log(`\\n模拟点击: <${targetChild.tagName.toLowerCase()}> 被点击了!`);\n      if (this._listener) {\n        this._listener(event);\n      }\n    }\n  };\n  children.forEach(child => child.parentElement = element);\n  return element;\n}\n\n// 创建我们的“容器”和“按钮”\nconst button1 = { tagName: 'BUTTON', id: 'btn-1', textContent: '按钮1' };\nconst button2 = { tagName: 'BUTTON', id: 'btn-2', textContent: '按钮2' };\nconst container = createMockElement('div', 'container', [button1, button2]);\n\n// 事件委托：只在父容器上设置一个监听器\ncontainer.addEventListener('click', (event) => {\n  // event.target 是我们实际点击的那个按钮\n  const clickedElement = event.target;\n  console.log(`事件在容器捕获! 真正被点击的是: ${clickedElement.textContent} (ID: ${clickedElement.id})`);\n});\n\n// 模拟点击第一个按钮\ncontainer.simulateClick(button1);\n// 模拟点击第二个按钮\ncontainer.simulateClick(button2);", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-4-事件委托.md", "blockIndex": 0}
{"id": "js-sec-6-2-4", "title": "事件委托", "code": "// 模拟一个更真实的DOM环境\nfunction createMockDOM() {\n  const dom = {\n    elements: {},\n    create: function(tagName, id, textContent) {\n      this.elements[id] = {\n        tagName: tagName.toUpperCase(),\n        id,\n        textContent,\n        parentElement: null,\n        matches(selector) { return selector === `#${this.id}`; }\n      };\n      return this.elements[id];\n    },\n    get: function(id) { return this.elements[id]; },\n    appendTo: function(childId, parentId) {\n      this.elements[childId].parentElement = this.elements[parentId];\n      this.elements[parentId].children = this.elements[parentId].children || [];\n      this.elements[parentId].children.push(this.elements[childId]);\n    }\n  };\n  return dom;\n}\n\nconst mockDOM = createMockDOM();\nconst list = mockDOM.create('ul', 'task-list', '');\nconst task1 = mockDOM.create('li', 'task-1', '学习 JavaScript');\nconst task2 = mockDOM.create('li', 'task-2', '阅读文档');\nmockDOM.appendTo('task-1', 'task-list');\nmockDOM.appendTo('task-2', 'task-list');\n\n// 在父元素 <ul> 上设置事件监听器\nlist.addEventListener = function(type, callback) {\n  this._listener = callback;\n  console.log('任务列表的事件监听器已设置!');\n};\n\nlist.simulateClick = function(targetId) {\n  const event = { target: mockDOM.get(targetId) };\n  this._listener(event);\n};\n\nlist.addEventListener('click', (event) => {\n  // 使用 .matches() 检查被点击的元素是否是我们想要的 <li>\n  if (event.target.tagName === 'LI') {\n    console.log(`任务 \"${event.target.textContent}\" 已完成!`);\n  }\n});\n\nconsole.log('--- 初始任务列表 ---');\nlist.simulateClick('task-1');\n\nconsole.log('\\n--- 动态添加一个新任务 ---');\nconst task3 = mockDOM.create('li', 'task-3', '编写代码');\nmockDOM.appendTo('task-3', 'task-list');\nconsole.log('新任务 \"编写代码\" 已添加，无需重新绑定事件。');\n\nconsole.log('\\n--- 点击新添加的任务 ---');\n// 新添加的元素也能被正确处理！\nlist.simulateClick('task-3');", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-4-事件委托.md", "blockIndex": 1}
{"id": "js-sec-6-2-4", "title": "事件委托", "code": "// 模拟一个有1000个子项的列表\nconst createHeavyList = (itemCount) => {\n  const parent = { tagName: 'UL', children: [] };\n  for (let i = 1; i <= itemCount; i++) {\n    parent.children.push({ tagName: 'LI', id: `item-${i}` });\n  }\n  return parent;\n};\n\nconst list = createHeavyList(1000);\n\n// 方法1: 事件委托 (高性能)\nfunction setupWithDelegation(parent) {\n  let listenerCount = 0;\n  parent.addEventListener = () => {\n    listenerCount++;\n  };\n  parent.addEventListener('click', () => {}); // 模拟添加事件\n  console.log(`[事件委托] 列表有 ${parent.children.length} 个子项，但只创建了 ${listenerCount} 个事件监听器。`);\n}\n\n// 方法2: 循环绑定 (低性能)\nfunction setupWithoutDelegation(parent) {\n  let listenerCount = 0;\n  parent.children.forEach(child => {\n    child.addEventListener = () => {\n      listenerCount++;\n    };\n    child.addEventListener('click', () => {}); // 模拟添加事件\n  });\n  console.log(`[循环绑定] 列表有 ${parent.children.length} 个子项，创建了 ${listenerCount} 个事件监听器。`);\n}\n\nconsole.log(\"比较两种方法的性能开销：\");\nsetupWithDelegation(list);\nsetupWithoutDelegation(list);\nconsole.log(\"\\n结论: 事件委托在处理大量子元素时，内存和性能优势非常明显。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-4-事件委托.md", "blockIndex": 2}
{"id": "js-sec-6-2-4", "title": "事件委托", "code": "// 模拟一个简单的DOM操作环境\nconst createMockList = () => {\n  let items = {\n    'item-1': { id: 'item-1', textContent: '苹果' },\n    'item-2': { id: 'item-2', textContent: '香蕉' }\n  };\n  let listeners = {};\n\n  return {\n    addItem: (id, text) => {\n      console.log(`...添加新项目: ${text}`);\n      items[id] = { id, textContent: text };\n    },\n    bindListener: (id, callback) => {\n      listeners[id] = callback;\n    },\n    clickItem: (id) => {\n      console.log(`> 模拟点击 ${items[id].textContent}`);\n      if (listeners[id]) {\n        listeners[id]({ target: items[id] });\n      } else {\n        console.log(`!! <${items[id].textContent}> 上没有找到监听器!`);\n      }\n    },\n    getItems: () => Object.values(items)\n  };\n};\n\n// =========================================================\nconsole.log(\"=== 错误用法: 为每个已知元素单独绑定 ===\");\n// ❌ 这种方法无法处理动态添加的元素\nconst wrongList = createMockList();\n// 初始时为每个存在的元素绑定事件\nwrongList.getItems().forEach(item => {\n  wrongList.bindListener(item.id, (e) => {\n    console.log(`好吃! 你点击了 ${e.target.textContent}。`);\n  });\n});\n\nwrongList.clickItem('item-1'); // 正常工作\nwrongList.addItem('item-3', '橙子'); // 动态添加一个新水果\nwrongList.clickItem('item-3'); // 失败！因为“橙子”被添加时，我们没有为它绑定事件。\nconsole.log(\"错误原因：事件监听器是在新元素被添加 *之前* 绑定的，新元素错过了绑定过程。\");\n\n// =========================================================\nconsole.log(\"\\n=== 正确用法: 使用事件委托 ===\");\n// ✅ 在父元素上设置一次监听器，一劳永逸\nconst correctList = {\n  items: {\n    'item-1': { id: 'item-1', textContent: '苹果' },\n    'item-2': { id: 'item-2', textContent: '香蕉' }\n  },\n  // 模拟父元素的事件监听\n  listener: (event) => {\n    // 检查被点击的是否是目标子元素\n    if (event.target.id.startsWith('item-')) {\n      console.log(`太棒了! 你点击了 ${event.target.textContent}。`);\n    }\n  },\n  clickItem: function(id) {\n    console.log(`> 模拟点击 ${this.items[id].textContent}`);\n    this.listener({ target: this.items[id] });\n  },\n  addItem: function(id, text) {\n    console.log(`...添加新项目: ${text}`);\n    this.items[id] = { id, textContent: text };\n  }\n};\n\ncorrectList.clickItem('item-2'); // 正常工作\ncorrectList.addItem('item-3', '橙子'); // 动态添加一个新水果\ncorrectList.clickItem('item-3'); // 依然正常工作！\nconsole.log(\"正确原因：事件监听器在父元素上，无论子元素如何增删，只要点击事件冒泡到父元素，就能被捕获和处理。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-4-事件委托.md", "blockIndex": 3}
{"id": "js-sec-6-2-4", "title": "事件委托", "code": "// 模拟一个像素画板游戏\nclass PixelArtPad {\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n    this.grid = this.createGrid(width, height);\n    this.currentColor = '🔴'; // 默认颜色是红色\n    this.eventListener = null; // 父容器的监听器\n\n    console.log(`🎨 一个 ${width}x${height} 的像素画板已创建!`);\n  }\n\n  // 创建像素格子数据\n  createGrid(width, height) {\n    const grid = {};\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const id = `pixel-${x}-${y}`;\n        grid[id] = { id, x, y, color: '⚪️', type: 'pixel' };\n      }\n    }\n    return grid;\n  }\n\n  // 在画板容器上设置事件监听器\n  attachListener() {\n    // 事件委托的核心：监听器在父容器上\n    this.eventListener = (event) => {\n      const target = event.target;\n      // 确保我们点击的是一个像素，而不是容器背景\n      if (target && target.type === 'pixel') {\n        console.log(`🖌️ 你在坐标 (${target.x}, ${target.y}) 使用 ${this.currentColor} 进行了绘制!`);\n        target.color = this.currentColor;\n        this.render();\n      } else if (target && target.type === 'color-palette') {\n        this.currentColor = target.color;\n        console.log(`🎨 颜色已切换为: ${this.currentColor}`);\n      }\n    };\n    console.log('事件监听器已附加到整个画板，而不是每个像素。');\n  }\n\n  // 模拟点击事件\n  simulateClick(targetId) {\n    // 模拟点击画板上的一个像素或调色板\n    const target = this.grid[targetId] || this.palette[targetId];\n    if (!target) {\n      console.log('无效点击目标！');\n      return;\n    }\n    const event = { target };\n    this.eventListener(event);\n  }\n\n  // 模拟调色板\n  createPalette() {\n    this.palette = {\n      'color-red': { id: 'color-red', color: '🔴', type: 'color-palette' },\n      'color-blue': { id: 'color-blue', color: '🔵', type: 'color-palette' },\n      'color-green': { id: 'color-green', color: '🟢', type: 'color-palette' },\n    };\n  }\n\n  // 在控制台渲染画板\n  render() {\n    console.log('--- 当前画板状态 ---');\n    let output = '';\n    for (let y = 0; y < this.height; y++) {\n      for (let x = 0; x < this.width; x++) {\n        output += this.grid[`pixel-${x}-${y}`].color + ' ';\n      }\n      output += '\\n';\n    }\n    console.log(output);\n  }\n}\n\n// --- 开始游戏 ---\nconst myPad = new PixelArtPad(5, 5);\nmyPad.createPalette();\nmyPad.attachListener(); // 设置事件委托\nmyPad.render();\n\n// 模拟用户操作\nmyPad.simulateClick('pixel-2-2'); // 在中间点一下\nmyPad.simulateClick('color-blue'); // 切换到蓝色\nmyPad.simulateClick('pixel-0-0'); // 在左上角点一下\nmyPad.simulateClick('pixel-4-4'); // 在右下角点一下", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-4-事件委托.md", "blockIndex": 4}
{"id": "js-sec-6-2-5", "title": "常用事件类型", "code": "// 模拟一个按钮对象\nconst myButton = {\n  // 定义一个处理点击事件的函数\n  // 这个函数被称为“事件处理程序”或“事件监听器”\n  onclick: function() {\n    console.log(\"按钮被点击了！你好，世界！\");\n  }\n};\n\n// 模拟用户点击按钮的行为\nfunction simulateClick(button) {\n  console.log(\"用户正在点击...\");\n  // 检查按钮是否有onclick处理程序，如果有就执行它\n  if (button.onclick) {\n    button.onclick();\n  }\n}\n\n// 执行模拟点击\nsimulateClick(myButton);", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-5-常用事件类型.md", "blockIndex": 0}
{"id": "js-sec-6-2-5", "title": "常用事件类型", "code": "// 模拟一个神奇的魔法石\nconst magicStone = {\n  // 当鼠标进入时，魔法石发光\n  onmouseover: () => {\n    console.log(\"🌟 魔法石感应到你的靠近，开始发光！\");\n  },\n  // 当鼠标离开时，光芒减弱\n  onmouseout: () => {\n    console.log(\"✨ 魔法石的光芒变暗了。\");\n  },\n  // 当点击时，释放能量\n  onclick: () => {\n    console.log(\"💥 你点击了魔法石，一道能量迸发出来！\");\n  }\n};\n\n// 模拟一系列用户鼠标操作\nfunction simulateMouseActions(element) {\n  console.log(\"--- 开始模拟鼠标与魔法石的互动 ---\");\n\n  console.log(\"\\n1. 鼠标指针移入...\");\n  if (element.onmouseover) element.onmouseover();\n\n  console.log(\"\\n2. 用户决定点击！\");\n  if (element.onclick) element.onclick();\n\n  console.log(\"\\n3. 鼠标指针移出...\");\n  if (element.onmouseout) element.onmouseout();\n\n  console.log(\"\\n--- 模拟结束 ---\");\n}\n\nsimulateMouseActions(magicStone);", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-5-常用事件类型.md", "blockIndex": 1}
{"id": "js-sec-6-2-5", "title": "常用事件类型", "code": "// 模拟一个游戏角色的控制器\nconst gameController = {\n  // 按下按键时的处理逻辑\n  onkeydown: (event) => {\n    console.log(`[KeyDown] 按下了键: \"${event.key}\"`);\n    if (event.key === 'ArrowUp') {\n      console.log(\"角色跳跃！슝~\");\n    } else if (event.key === ' ') {\n      console.log(\"角色正在蓄力...\");\n    }\n  },\n  // 释放按键时的处理逻辑\n  onkeyup: (event) => {\n    console.log(`[KeyUp] 释放了键: \"${event.key}\"`);\n    if (event.key === ' ') {\n      console.log(\"大招释放！💥\");\n    }\n  }\n};\n\n// 模拟用户玩游戏\nfunction simulateKeyboardInput(controller) {\n  console.log(\"--- 玩家开始操作 ---\");\n  \n  // 模拟按下向上箭头\n  controller.onkeydown({ key: 'ArrowUp' });\n  // 模拟释放向上箭头\n  controller.onkeyup({ key: 'ArrowUp' });\n\n  console.log(\"---\");\n\n  // 模拟按住空格键蓄力，然后释放\n  controller.onkeydown({ key: ' ' }); // 按下\n  controller.onkeyup({ key: ' ' });   // 释放\n  \n  console.log(\"--- 操作结束 ---\");\n}\n\nsimulateKeyboardInput(gameController);", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-5-常用事件类型.md", "blockIndex": 2}
{"id": "js-sec-6-2-5", "title": "常用事件类型", "code": "console.log(\"=== 错误用法 ===\");\n// ❌ 错误：使用 keydown 来处理需要单次触发的“更换弹夹”动作\n// 这会导致如果用户按住 'R' 键不放，会一直提示更换弹夹，不符合逻辑。\nconst playerActionsWrong = {\n  isReloading: false,\n  handleKeyDown: (key) => {\n    if (key === 'A') {\n      console.log(\"biu~ 持续射击！\");\n    } else if (key === 'R') {\n      // 错误点：只要按住R键，就会不停地触发换弹夹\n      console.log(\"❌ 开始更换弹夹！（如果按住会一直提示）\");\n    }\n  }\n};\nconsole.log(\"模拟玩家按住 R 键 0.5 秒...\");\nplayerActionsWrong.handleKeyDown('R');\nplayerActionsWrong.handleKeyDown('R'); // 模拟持续按住\nplayerActionsWrong.handleKeyDown('R'); // 模拟持续按住\nconsole.log(\"解释：使用 keydown 会导致“更换弹夹”这个单次动作被重复触发，逻辑错误。\");\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确：使用 keydown 处理持续性动作，使用 keyup 处理单次动作\nconst playerActionsRight = {\n  isReloading: false,\n  handleKeyDown: (key) => {\n    if (key === 'A') {\n      console.log(\"✅ biu~ 持续射击！\");\n    }\n  },\n  handleKeyUp: (key) => {\n    if (key === 'R' && !playerActionsRight.isReloading) {\n        playerActionsRight.isReloading = true;\n        console.log(\"✅ 更换弹夹！咔嚓！(只触发一次)\");\n        // 模拟换弹夹需要时间\n        setTimeout(() => {\n          playerActionsRight.isReloading = false;\n          console.log(\"✅ 弹夹更换完毕！\");\n        }, 50); // 使用很短的超时来模拟\n    }\n  }\n};\nconsole.log(\"模拟玩家按下 A 键，然后按下并释放 R 键...\");\nplayerActionsRight.handleKeyDown('A'); // 持续射击\nplayerActionsRight.handleKeyDown('A');\nplayerActionsRight.handleKeyUp('R'); // 按下并释放R，触发换弹夹\nconsole.log(\"解释：keydown 适合“按住时持续生效”的动作，而 keyup 适合“释放时触发一次”的动作。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-5-常用事件类型.md", "blockIndex": 3}
{"id": "js-sec-6-2-5", "title": "常用事件类型", "code": "// 游戏状态和地图\nconst gameState = {\n  player: { x: 1, y: 1 },\n  treasureCollected: false,\n  map: [\n    ['#', '#', '#', '#', '#', '#', '#'],\n    ['#', 'P', ' ', '#', ' ', ' ', '#'],\n    ['#', ' ', ' ', ' ', ' ', '#', '#'],\n    ['#', ' ', '#', '#', ' ', '$', '#'],\n    ['#', ' ', ' ', ' ', ' ', ' ', '#'],\n    ['#', '#', '#', '#', '#', 'E', '#'],\n  ]\n};\n\n// 渲染地图到控制台\nfunction renderMap() {\n  console.log(\"\\n--- 神秘洞穴 ---\");\n  // 清空旧的玩家位置标记\n  for (let y = 0; y < gameState.map.length; y++) {\n    for (let x = 0; x < gameState.map[y].length; x++) {\n      if (gameState.map[y][x] === 'P') {\n        gameState.map[y][x] = ' ';\n      }\n    }\n  }\n  // 放置新的玩家位置\n  const { x, y } = gameState.player;\n  gameState.map[y][x] = 'P';\n\n  // 打印地图\n  gameState.map.forEach(row => console.log(row.join(' ')));\n  console.log(\"使用 w/a/s/d 移动. 你的目标是拿到'$'然后到达'E'!\");\n}\n\n// 模拟键盘事件处理器\nfunction handleKeyPress(key) {\n  console.log(`\\n你按下了 '${key}' 键...`);\n  const { player } = gameState;\n  let nextX = player.x;\n  let nextY = player.y;\n\n  if (key === 'w') nextY--; // 上\n  if (key === 's') nextY++; // 下\n  if (key === 'a') nextX--; // 左\n  if (key === 'd') nextX++; // 右\n  \n  const destination = gameState.map[nextY][nextX];\n\n  // 碰撞检测\n  if (destination === '#') {\n    console.log(\"哎哟！你撞到了墙壁。\");\n    return;\n  }\n  \n  // 更新玩家位置\n  player.x = nextX;\n  player.y = nextY;\n  \n  // 检查目标格子\n  if (destination === '$') {\n    console.log(\"🎉 哇！你找到了闪闪发光的宝藏！\");\n    gameState.treasureCollected = true;\n  } else if (destination === 'E') {\n    if (gameState.treasureCollected) {\n      console.log(\"🏆 恭喜！你带着宝藏成功逃离了洞穴！你赢了！\");\n    } else {\n      console.log(\"🤔 你找到了出口，但是似乎忘记了什么重要的东西... (去找'$'!)\");\n    }\n  } else {\n    console.log(\"你移动到了一个新的位置。\");\n  }\n  \n  renderMap();\n}\n\n// --- 游戏开始 ---\nconsole.log(\"欢迎来到《逃离神秘洞穴》！\");\nrenderMap();\n\n// 模拟玩家的一系列操作\nhandleKeyPress('s'); // 向下\nhandleKeyPress('d'); // 向右\nhandleKeyPress('d'); // 向右\nhandleKeyPress('d'); // 向右\nhandleKeyPress('s'); // 向下\nhandleKeyPress('s'); // 向下，找到宝藏\nhandleKeyPress('d'); // 向右\nhandleKeyPress('s'); // 向下\nhandleKeyPress('d'); // 向右，到达出口", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-5-常用事件类型.md", "blockIndex": 4}
{"id": "js-sec-6-2-6", "title": "自定义事件", "code": "// Level 1: 最简单的自定义事件\n\n// 1. 选择一个元素作为事件目标\nconst eventTarget = document.body;\n\n// 2. 在目标上监听我们自定义的事件 'partyTime'\neventTarget.addEventListener('partyTime', () => {\n  console.log('🎉 Party Time! Let\\'s celebrate!');\n});\n\n// 3. 创建一个新的自定义事件实例\nconst myEvent = new CustomEvent('partyTime');\n\n// 4. 在目标上派发（触发）这个事件\neventTarget.dispatchEvent(myEvent);\n\n// 控制台输出:\n// 🎉 Party Time! Let's celebrate!", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-6-自定义事件.md", "blockIndex": 0}
{"id": "js-sec-6-2-6", "title": "自定义事件", "code": "// Level 2, Feature 1: 传递数据\n\nconst gameConsole = document.body;\n\n// 监听 'newAchievement' 事件，并准备接收数据\ngameConsole.addEventListener('newAchievement', (event) => {\n  // 通过 event.detail 访问传递过来的数据\n  const achievementData = event.detail;\n  console.log(`🏆 新成就解锁!`);\n  console.log(`   名称: ${achievementData.name}`);\n  console.log(`   分数: ${achievementData.score}点`);\n  console.log(`   稀有度: ${achievementData.rarity}`);\n});\n\n// 创建事件时，通过 detail 属性传入一个对象\nconst achievementEvent = new CustomEvent('newAchievement', {\n  detail: {\n    name: '代码魔法师',\n    score: 100,\n    rarity: '史诗'\n  }\n});\n\n// 派发事件\ngameConsole.dispatchEvent(achievementEvent);\n\n// 控制台输出:\n// 🏆 新成就解锁!\n//    名称: 代码魔法师\n//    分数: 100点\n//    稀有度: 史诗", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-6-自定义事件.md", "blockIndex": 1}
{"id": "js-sec-6-2-6", "title": "自定义事件", "code": "// Level 2, Feature 2: 事件冒泡\n\n// 为了在Node.js环境或浏览器无DOM环境下模拟，我们使用EventTarget\n// 在浏览器中，你可以直接使用 document.createElement('div')\nclass MockElement extends EventTarget {\n    constructor(name, parent = null) {\n        super();\n        this.name = name;\n        this.parent = parent;\n    }\n    // 重写 dispatchEvent 以模拟冒泡\n    dispatchEvent(event) {\n        let target = this;\n        // 调用自身的监听器\n        super.dispatchEvent(event);\n        // 如果 bubbles 为 true 且有父元素，则在父元素上继续派发\n        if (event.bubbles && target.parent) {\n            target.parent.dispatchEvent(event);\n        }\n    }\n}\n\nconst parentBox = new MockElement('parentBox');\nconst childBox = new MockElement('childBox', parentBox);\n\n// 在父元素上监听\nparentBox.addEventListener('customBubble', (event) => {\n  console.log(`[父元素] 捕获到了来自 ${event.target.name} 的冒泡事件！`);\n});\n\n// 在子元素上监听\nchildBox.addEventListener('customBubble', (event) => {\n  console.log(`[子元素] 事件从我这里开始！`);\n});\n\n// 创建一个可冒泡的事件\nconst bubbleEvent = new CustomEvent('customBubble', { bubbles: true });\n\nconsole.log('派发事件...');\n// 从子元素开始派发\nchildBox.dispatchEvent(bubbleEvent);\n\n// 控制台输出:\n// 派发事件...\n// [子元素] 事件从我这里开始！\n// [父元素] 捕获到了来自 childBox 的冒泡事件！", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-6-自定义事件.md", "blockIndex": 2}
{"id": "js-sec-6-2-6", "title": "自定义事件", "code": "// 假设我们有一个玩家(Player)和一个UI管理器(UIManager)\n// 它们都需要在分数变化时做出反应\n\nconsole.log(\"=== 错误用法: 紧耦合 ===\");\n// ❌ 玩家对象直接依赖并调用UI管理器的方法\nconst UIManager_Bad = {\n  updateScoreboard: (score) => {\n    console.log(`[UI] 分数已更新: ${score}`);\n  }\n};\n\nconst Player_Bad = {\n  score: 0,\n  addScore: function(points) {\n    this.score += points;\n    console.log(`[玩家] 获得了 ${points} 分！`);\n    // 直接调用，Player必须知道UIManager_Bad的存在和它的方法名\n    UIManager_Bad.updateScoreboard(this.score);\n  }\n};\nPlayer_Bad.addScore(10);\n// 这种方式的问题是：如果UI管理器的名字或方法改变，玩家代码也必须修改。\n// 如果想添加另一个模块（如音效模块）来响应分数变化，还得修改Player的代码。\n\n\nconsole.log(\"\\n=== 正确用法: 使用自定义事件解耦 ===\");\n// ✅ 玩家只需派发事件，不关心谁在监听\nconst eventBus = new EventTarget(); // 使用一个共享的事件中心\n\nconst UIManager_Good = {\n  init: function() {\n    eventBus.addEventListener('scoreChanged', (event) => {\n      this.updateScoreboard(event.detail.newScore);\n    });\n  },\n  updateScoreboard: (score) => {\n    console.log(`[UI] 分数已更新: ${score}`);\n  }\n};\n\nconst SoundManager_Good = {\n    init: function() {\n        eventBus.addEventListener('scoreChanged', (event) => {\n            if (event.detail.points > 0) {\n                this.playSound('score-up');\n            }\n        });\n    },\n    playSound: (soundName) => {\n        console.log(`[音效] 播放声音: ${soundName}.mp3`);\n    }\n};\n\nconst Player_Good = {\n  score: 0,\n  addScore: function(points) {\n    this.score += points;\n    console.log(`[玩家] 获得了 ${points} 分！`);\n    // 派发事件，将新分数和增加的分数作为数据传递\n    const scoreEvent = new CustomEvent('scoreChanged', {\n      detail: { newScore: this.score, points: points }\n    });\n    eventBus.dispatchEvent(scoreEvent);\n  }\n};\n\n// 初始化监听模块\nUIManager_Good.init();\nSoundManager_Good.init();\n\n// 玩家得分\nPlayer_Good.addScore(50);\n// 现在，玩家模块完全不知道UI或音效模块的存在。\n// 我们可以轻松添加或删除任意数量的监听器，而无需修改玩家代码。\n\n// 控制台输出:\n// === 错误用法: 紧耦合 ===\n// [玩家] 获得了 10 分！\n// [UI] 分数已更新: 10\n//\n// === 正确用法: 使用自定义事件解耦 ===\n// [玩家] 获得了 50 分！\n// [UI] 分数已更新: 50\n// [音效] 播放声音: score-up.mp3", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-6-自定义事件.md", "blockIndex": 3}
{"id": "js-sec-6-2-6", "title": "自定义事件", "code": "// 场景: 虚拟宠物互动系统\n\n// 创建一个全局的事件中心，让宠物和护理系统通过它来通信\nconst petEventBus = new EventTarget();\n\n// 宠物护理系统，它只关心事件\nconst petCareSystem = {\n  init: function() {\n    console.log(\"宠物护理系统已启动，正在监听宠物状态...\");\n    petEventBus.addEventListener('petStateChange', this.handleStateChange);\n  },\n  handleStateChange: (event) => {\n    const { petName, mood, message, hunger, happiness } = event.detail;\n    console.log(`\\n======= 宠物状态警报! =======`);\n    console.log(`宠物: ${petName}`);\n    console.log(`心情: ${mood}`);\n    console.log(`留言: \"${message}\"`);\n    console.log(`(当前饥饿度: ${hunger}, 快乐度: ${happiness})`);\n    console.log(`==============================\\n`);\n  }\n};\n\n// 虚拟宠物对象\nconst myVirtualPet = {\n  name: '皮卡丘',\n  hunger: 50,\n  happiness: 50,\n\n  live: function() {\n    console.log(`${this.name} 开始了新的一天! (饥饿度: ${this.hunger}, 快乐度: ${this.happiness})`);\n    setInterval(() => {\n      // 模拟时间和状态变化\n      this.hunger += 5;\n      this.happiness -= 3;\n      \n      console.log(`...时间流逝... (饿: ${this.hunger}, 乐: ${this.happiness})`);\n\n      // 检查状态并派发事件\n      if (this.hunger > 80) {\n        this.emitStateChangeEvent('饿坏了', 'Pika Pika! 我要吃东西！');\n        this.hunger = 80; // 防止重复触发\n      }\n      if (this.happiness < 20) {\n        this.emitStateChangeEvent('不开心', 'Pika... 我想玩...');\n        this.happiness = 20; // 防止重复触发\n      }\n    }, 2000); // 每2秒更新一次状态\n  },\n\n  feed: function() {\n    console.log(`你喂了 ${this.name} 一些食物.`);\n    this.hunger -= 30;\n    this.happiness += 10;\n    if (this.hunger < 0) this.hunger = 0;\n    this.emitStateChangeEvent('满足', 'Pikaaa-chuuuu! 好吃!');\n  },\n\n  play: function() {\n    console.log(`你和 ${this.name} 玩了游戏.`);\n    this.happiness += 30;\n    this.hunger += 10;\n    if (this.happiness > 100) this.happiness = 100;\n    this.emitStateChangeEvent('超开心', 'PI-KA-CHU!!!');\n  },\n\n  emitStateChangeEvent: function(mood, message) {\n    const stateEvent = new CustomEvent('petStateChange', {\n      detail: {\n        petName: this.name,\n        mood: mood,\n        message: message,\n        hunger: this.hunger,\n        happiness: this.happiness\n      }\n    });\n    petEventBus.dispatchEvent(stateEvent);\n  }\n};\n\n// --- 启动模拟 ---\npetCareSystem.init();\nmyVirtualPet.live();\n\n// 模拟用户与宠物互动 (在几秒后执行)\nsetTimeout(() => {\n  myVirtualPet.play();\n}, 3000);\n\nsetTimeout(() => {\n  myVirtualPet.feed();\n}, 9000);\n\n// 你可以观察控制台输出，看到宠物状态随时间变化，\n// 并在特定条件下自动触发事件，护理系统会作出响应。\n// 用户的互动也会触发事件。", "lang": "javascript", "source": "web-learner/public/content/js-sec-6-2-6-自定义事件.md", "blockIndex": 4}
{"id": "js-sec-7-1-1", "title": "解构赋值进阶", "code": "// 假设这是一个游戏角色的数据\nconst player = {\n  name: \"Link\",\n  stats: {\n    hp: 100,\n    mp: 50\n  }\n};\n\n// 进阶解构：直接从嵌套的 stats 对象中提取 hp\nconst { stats: { hp } } = player;\n\nconsole.log(`角色的生命值是: ${hp}`); // 输出: 角色的生命值是: 100\n// console.log(stats); // 错误！stats 只是路径，并没有被定义为变量", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-1-解构赋值进阶.md", "blockIndex": 0}
{"id": "js-sec-7-1-1", "title": "解构赋值进阶", "code": "const character = {\n  id: 1,\n  nickname: 'Zelda',\n  equipment: {\n    weapon: {\n      name: 'Master Sword',\n      damage: 99\n    }\n  }\n};\n\n// 目标：直接获取武器名称，并将其重命名为 weaponName\nconst { equipment: { weapon: { name: weaponName } } } = character;\n\nconsole.log(`角色 \"${character.nickname}\" 的武器是: ${weaponName}`);\n// console.log(equipment); // 报错, equipment 只是路径\n// console.log(weapon); // 报错, weapon 只是路径\n// console.log(name); // 报错, name 已被重命名为 weaponName", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-1-解构赋值进阶.md", "blockIndex": 1}
{"id": "js-sec-7-1-1", "title": "解构赋值进阶", "code": "const settings = {\n  theme: 'dark',\n  // 注意：这里没有定义 fontSize\n};\n\n// 解构 settings 对象\n// 为 fontSize 提供默认值 16px\n// 为 notification 提供默认值 true\nconst { theme, fontSize = '16px', notification = true } = settings;\n\nconsole.log(`主题: ${theme}`);\nconsole.log(`字体大小: ${fontSize}`); // 由于 settings 中没有，将使用默认值\nconsole.log(`通知是否开启: ${notification}`);", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-1-解构赋值进阶.md", "blockIndex": 2}
{"id": "js-sec-7-1-1", "title": "解构赋值进阶", "code": "// 假设这是从 API 获取的用户数据，profile 字段可能是可选的\nconst userWithProfile = { name: 'Alice', profile: { age: 30 } };\nconst userWithoutProfile = { name: 'Bob', profile: null };\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 尝试从一个 null 的 profile 中解构 age\ntry {\n  const { profile: { age } } = userWithoutProfile;\n  console.log(age);\n} catch (error) {\n  console.error(\"出错了:\", error.message);\n  // 解释：这里会抛出 TypeError，因为你不能从 null 或 undefined 中读取属性 'age'。\n}\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 在可能不存在的对象路径上提供一个默认的空对象 {}\n// 这样即使 user.profile 是 null 或 undefined，解构也会作用于这个空对象 {}\nconst { profile: { age = 25 } = {} } = userWithoutProfile;\n\nconsole.log(`Bob 的年龄 (使用默认值): ${age}`);\n// 解释：我们为 profile 设置了默认值 {}。\n// 当 userWithoutProfile.profile 为 null 时，解构会尝试从 {} 中获取 age。\n// 由于 {} 中没有 age，age 会取它自己的默认值 25。这样就安全地避免了错误。", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-1-解构赋值进阶.md", "blockIndex": 3}
{"id": "js-sec-7-1-1", "title": "解构赋值进阶", "code": "// 飞船数据对象，结构可能很复杂\nconst spaceship = {\n  name: 'Stardust Cruiser',\n  engine: {\n    type: 'Warp Drive',\n    status: 'active'\n  },\n  navigation: {\n    target: 'Alpha Centauri',\n    eta: '3 days'\n    // 注意：这里缺少 astra (星图) 信息\n  },\n  crew: ['Captain Eva', 'Dr. Alex', 'Engineer Rio']\n};\n\n// 一个函数，用来生成驾驶舱的显示信息\nfunction getCockpitDisplay(ship) {\n  // 使用高级解构一次性提取所有需要的信息！\n  const {\n    name: shipName,                                  // 重命名 'name' 为 'shipName'\n    engine: { status: engineStatus },                // 嵌套提取引擎状态\n    navigation: {\n      target: navTarget,                             // 嵌套提取导航目标\n      astra: starMap = 'Not Available'               // 嵌套提取，并为缺失的星图提供默认值\n    },\n    crew: [captain, ...otherCrew]                    // 数组解构：提取第一个船员为机长，其余为其他船员\n  } = ship;\n\n  console.log(`🚀 飞船状态报告: ${shipName} 🚀`);\n  console.log(`------------------------------------`);\n  console.log(`引擎状态: ${engineStatus === 'active' ? '🟢 运行中' : '🔴 已关闭'}`);\n  console.log(`导航目标: 正在前往 ${navTarget}`);\n  console.log(`星图数据: ${starMap}`);\n  console.log(`机长: ${captain}`);\n  console.log(`其他船员 (${otherCrew.length}人): ${otherCrew.join(', ')}`);\n  console.log(`------------------------------------`);\n}\n\n// 调用函数，传入飞船数据\ngetCockpitDisplay(spaceship);", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-1-解构赋值进阶.md", "blockIndex": 4}
{"id": "js-sec-7-1-2", "title": "展开运算符", "code": "// 想象有两支探险队\nconst teamAlpha = ['爱丽丝', '鲍勃'];\nconst teamBravo = ['查理', '大卫'];\n\n// 使用展开运算符 (...) 将两支队伍合并成一支超级探险队\nconst superTeam = [...teamAlpha, ...teamBravo, '伊芙'];\n\nconsole.log('原始队伍 A:', teamAlpha);\nconsole.log('原始队伍 B:', teamBravo);\nconsole.log('合并后的超级队伍:', superTeam);\n// 输出: 合并后的超级队伍: [ '爱丽丝', '鲍勃', '查理', '大卫', '伊芙' ]", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-2-展开运算符.md", "blockIndex": 0}
{"id": "js-sec-7-1-2", "title": "展开运算符", "code": "// 假设我们有一个函数，用来计算一组数字中的最大值\n// Math.max() 需要的是独立的数字参数，而不是一个数组\nconst scores = [88, 95, 102, 76];\n\n// 不使用展开运算符，会报错或得到错误结果\nconst wrongMax = Math.max(scores); \nconsole.log('错误方式的结果:', wrongMax); // 输出: NaN\n\n// 使用展开运算符，将数组元素“展开”为独立的参数\n// 等价于调用 Math.max(88, 95, 102, 76)\nconst correctMax = Math.max(...scores);\nconsole.log('正确方式找到的最高分:', correctMax); // 输出: 102", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-2-展开运算符.md", "blockIndex": 1}
{"id": "js-sec-7-1-2", "title": "展开运算符", "code": "const playerBaseStats = {\n  name: '英雄',\n  level: 1,\n  hp: 100,\n};\n\nconst equipmentStats = {\n  armor: 50,\n  weaponDamage: 25,\n  hp: 20 // 装备额外增加20点HP\n};\n\n// 使用展开运算符合并基础属性和装备属性\n// 注意：如果属性名相同（如hp），后面的会覆盖前面的\nconst finalPlayerStats = { ...playerBaseStats, ...equipmentStats, speed: 30 };\n\nconsole.log('基础属性:', playerBaseStats);\nconsole.log('装备属性:', equipmentStats);\nconsole.log('最终完整属性:', finalPlayerStats);\n// 输出: 最终完整属性: { name: '英雄', level: 1, hp: 20, armor: 50, weaponDamage: 25, speed: 30 }", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-2-展开运算符.md", "blockIndex": 2}
{"id": "js-sec-7-1-2", "title": "展开运算符", "code": "// 完整的对比示例，包含所有必要的变量定义\nconsole.log(\"=== 错误用法：误以为是深拷贝 ===\");\n// ❌ 假设我们有一个玩家对象，其中包含一个嵌套的'skills'对象\nconst playerOriginal = {\n  name: '法师',\n  stats: {\n    mana: 200,\n    intelligence: 80\n  }\n};\n\n// 使用展开运算符创建一个副本\nconst playerShallowCopy = { ...playerOriginal };\n\n// 尝试只修改副本的法力值\nplayerShallowCopy.stats.mana = 50; \n\nconsole.log('修改副本后，副本的法力值:', playerShallowCopy.stats.mana); // 输出: 50\nconsole.log('😱 修改副本后，原始对象的法力值也被改变了:', playerOriginal.stats.mana); // 输出: 50\n// 解释: 这是因为 playerOriginal.stats 和 playerShallowCopy.stats 指向的是内存中同一个对象。\n\nconsole.log(\"\\n=== 正确用法：正确处理嵌套对象 ===\");\n// ✅ 如果要更新嵌套对象，需要对每一层都使用展开运算符\nconst playerToUpdate = {\n  name: '法师',\n  stats: {\n    mana: 200,\n    intelligence: 80\n  }\n};\n\n// 创建一个真正的新对象，并更新嵌套属性\nconst playerUpdatedCorrectly = {\n  ...playerToUpdate, // 复制顶层属性\n  stats: {\n    ...playerToUpdate.stats, // 复制嵌套的stats对象属性\n    mana: 50 // 只覆盖mana属性\n  }\n};\n\nconsole.log('正确更新后，新对象的法力值:', playerUpdatedCorrectly.stats.mana); // 输出: 50\nconsole.log('✅ 正确更新后，原始对象的法力值未受影响:', playerToUpdate.stats.mana); // 输出: 200\n// 解释: 通过在嵌套层级也使用展开运算符，我们为'stats'创建了一个新的对象，从而避免了修改原始数据。", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-2-展开运算符.md", "blockIndex": 3}
{"id": "js-sec-7-1-2", "title": "展开运算符", "code": "// 宠物合成器函数\nfunction createHybridPet(petA, petB) {\n  console.log(`🌀 开始合成... ${petA.name} 和 ${petB.name} 进入了融合舱！`);\n\n  // 名字融合：取第一个宠物名字的前半部分和第二个宠物名字的后半部分\n  const nameA_part = petA.name.slice(0, Math.ceil(petA.name.length / 2));\n  const nameB_part = petB.name.slice(Math.floor(petB.name.length / 2));\n  const hybridName = nameA_part + nameB_part;\n\n  // 使用展开运算符合并技能，并用 Set 去除重复技能\n  const combinedSkills = [...new Set([...petA.skills, ...petB.skills])];\n\n  // 使用展开运算符构建新宠物对象\n  // 基础属性来自宠物A，但名字和技能是新合成的\n  // 同时，我们给新宠物一个独特的“混合”类型\n  const hybridPet = {\n    ...petA, // 继承宠物A的基础属性（如emoji, hp）\n    name: hybridName,\n    type: '混合型',\n    skills: combinedSkills,\n    parents: [petA.name, petB.name] // 记录父母\n  };\n\n  console.log(`✨ 合成成功！诞生了新的宠物: ${hybridPet.emoji} ${hybridPet.name}!`);\n  return hybridPet;\n}\n\n// 两个基础宠物\nconst fireDragon = {\n  name: '火爆龙',\n  emoji: '🐉',\n  type: '火系',\n  hp: 120,\n  skills: ['喷火', '龙之爪', '咆哮']\n};\n\nconst waterTurtle = {\n  name: '水箭龟',\n  emoji: '🐢',\n  type: '水系',\n  hp: 150,\n  skills: ['水枪', '缩壳', '咆哮']\n};\n\n// 开始合成！\nconst steamDragonTurtle = createHybridPet(fireDragon, waterTurtle);\n\nconsole.log(\"\\n--- 新宠物档案 ---\");\nconsole.log(steamDragonTurtle);\n/*\n输出:\n--- 新宠物档案 ---\n{\n  emoji: '🐉',\n  type: '混合型',\n  hp: 120,\n  name: '火爆龟',\n  skills: [ '喷火', '龙之爪', '咆哮', '水枪', '缩壳' ],\n  parents: [ '火爆龙', '水箭龟' ]\n}\n*/", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-2-展开运算符.md", "blockIndex": 4}
{"id": "js-sec-7-1-3", "title": "Set与Map", "code": "// === Set: 自动去重的集合 ===\n// 想象一个不允许有重复贴纸的贴纸簿\n\nconst stickerBook = new Set();\nstickerBook.add('🚀');\nstickerBook.add('🌟');\nstickerBook.add('🚀'); // 尝试添加一个重复的贴纸\n\nconsole.log(\"我的贴纸簿里有什么?\", stickerBook);\nconsole.log(\"贴纸数量:\", stickerBook.size); // 重复的 '🚀' 被自动忽略了\n\n// === Map: 什么都能当钥匙的柜子 ===\n// 想象一个可以用任何物品（照片、石头）当钥匙的储物柜\n\nconst magicCabinet = new Map();\nconst keyPhoto = { id: 1, url: 'family.jpg' }; // 这是一把“照片”钥匙\nconst keyStone = { type: 'granite' }; // 这是一块“石头”钥匙\n\nmagicCabinet.set(keyPhoto, '珍贵的家庭回忆');\nmagicCabinet.set(keyStone, '一块发光的魔法石');\n\nconsole.log(\"用照片钥匙能打开什么?\", magicCabinet.get(keyPhoto));\nconsole.log(\"柜子里有多少东西?\", magicCabinet.size);", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-3-Set与Map.md", "blockIndex": 0}
{"id": "js-sec-7-1-3", "title": "Set与Map", "code": "// 创建一个派对邀请名单，确保每个人只被邀请一次\nconst partyList = new Set();\n\n// 添加客人\npartyList.add('Alice');\npartyList.add('Bob');\npartyList.add('Charlie');\n\nconsole.log('初始名单:', partyList);\n\n// 尝试重复邀请 Bob\nconsole.log('尝试再次邀请 Bob...');\npartyList.add('Bob'); // 这个操作不会有任何效果\nconsole.log('名单大小依然是:', partyList.size);\nconsole.log('最终名单:', partyList);\n\n// 检查某人是否在名单上\nconsole.log('Bob在名单上吗?', partyList.has('Bob')); // true\nconsole.log('David在名单上吗?', partyList.has('David')); // false\n\n// Charlie临时有事，从名单中移除\npartyList.delete('Charlie');\nconsole.log('Charlie还在名单上吗?', partyList.has('Charlie')); // false\nconsole.log('更新后的名单:', partyList);", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-3-Set与Map.md", "blockIndex": 1}
{"id": "js-sec-7-1-3", "title": "Set与Map", "code": "// 为不同的英雄角色（对象）储存他们的专属技能（值）\nconst heroSkillMap = new Map();\n\nconst heroA = { name: 'Captain Invincible' };\nconst heroB = { name: 'Doctor Strange' };\nconst heroC = { name: 'The Flash' };\n\n// 使用英雄对象本身作为键\nheroSkillMap.set(heroA, 'Super Strength');\nheroSkillMap.set(heroB, 'Mystic Arts');\nheroSkillMap.set(heroC, 'Super Speed');\n\nconsole.log(`${heroA.name}的技能是:`, heroSkillMap.get(heroA));\nconsole.log(`${heroB.name}的技能是:`, heroSkillMap.get(heroB));\n\n// 键可以是函数\nconst specialMove = () => 'Ultimate Power!';\nheroSkillMap.set(specialMove, '这是一个终极技能的描述');\nconsole.log('函数键对应的值:', heroSkillMap.get(specialMove));\n\n// 键可以是数字\nheroSkillMap.set(404, 'Secret Not Found');\nconsole.log('数字键404对应的值:', heroSkillMap.get(404));", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-3-Set与Map.md", "blockIndex": 2}
{"id": "js-sec-7-1-3", "title": "Set与Map", "code": "const user1 = { name: 'Alice' };\nconst user2 = { name: 'Bob' };\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 尝试使用普通对象，将对象作为键\nconst userRolesObject = {};\nuserRolesObject[user1] = 'Admin';\nuserRolesObject[user2] = 'Moderator';\n\n// 为什么是错的:\n// 对象的键会被强制转换为字符串。当 user1 和 user2 被用作键时，\n// 它们都会被转换为 \"[object Object]\"。\n// 因此，第二次赋值会覆盖第一次的！\nconsole.log(\"对象键被转换后的样子:\", Object.keys(userRolesObject));\nconsole.log(\"对象中只有一个值:\", userRolesObject);\nconsole.log(\"尝试获取user1的角色:\", userRolesObject[user1]); // 结果是 'Moderator'，而不是 'Admin'！\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 使用 Map，将对象作为键\nconst userRolesMap = new Map();\nuserRolesMap.set(user1, 'Admin');\nuserRolesMap.set(user2, 'Moderator');\n\n// 为什么是对的:\n// Map 会保留键的原始类型和值。user1 和 user2 是两个不同的对象引用，\n// 所以它们被视为两个独立的键。\nconsole.log(\"Map的大小:\", userRolesMap.size); // 正确地显示为 2\nconsole.log(\"获取user1的角色:\", userRolesMap.get(user1)); // 正确地返回 'Admin'\nconsole.log(\"获取user2的角色:\", userRolesMap.get(user2)); // 正确地返回 'Moderator'", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-3-Set与Map.md", "blockIndex": 3}
{"id": "js-sec-7-1-3", "title": "Set与Map", "code": "// --- 奇幻生物图鉴系统 ---\n\n// 1. 定义我们遇到的生物实例\nconst fireDragon = { id: 1, name: 'Ignis' };\nconst waterSprite = { id: 2, name: 'Aqua' };\nconst anotherFireDragon = { id: 3, name: 'Fuego' }; // 这是另一只火龙\n\n// 2. 使用 Set 记录发现的生物种类（确保不重复）\nconst discoveredCreatureTypes = new Set();\nconsole.log(\"🌍 探险开始！图鉴种类为空:\", discoveredCreatureTypes);\n\n// 3. 使用 Map 存储每只生物的详细档案，用生物对象本身作为钥匙\nconst creaturePokedex = new Map();\n\n// 4. 探险函数，模拟遇到并记录生物\nfunction encounterCreature(creature, type, mood, favoriteFood) {\n  console.log(`\\n Encountered a ${type} creature named ${creature.name}!`);\n\n  // 记录这只生物的详细信息\n  creaturePokedex.set(creature, {\n    type: type,\n    mood: mood,\n    favoriteFood: favoriteFood\n  });\n  console.log(`✅ ${creature.name}的档案已存入图鉴Map。`);\n\n  // 将它的种类添加到种类Set中\n  if (!discoveredCreatureTypes.has(type)) {\n    console.log(`🎉 哇！发现了一个新种类: ${type}!`);\n  }\n  discoveredCreatureTypes.add(type);\n  console.log(`📚 当前已发现的种类Set:`, discoveredCreatureTypes);\n}\n\n// 5. 开始我们的探险旅程！\nencounterCreature(fireDragon, '🔥 Fire', 'Grumpy', 'Spicy Peppers');\nencounterCreature(waterSprite, '💧 Water', 'Playful', 'Seaweed Candy');\nencounterCreature(anotherFireDragon, '🔥 Fire', 'Excited', 'Volcanic Rocks'); // 种类是火，但这是个新个体\n\n// 6. 查看图鉴信息\nconsole.log(\"\\n--- 探险结束，查看图鉴 ---\");\nconsole.log(`总共发现了 ${discoveredCreatureTypes.size} 个独特的生物种类。`);\n\n// 检查特定生物的档案\nconst ignisData = creaturePokedex.get(fireDragon);\nif (ignisData) {\n  console.log(`查询 ${fireDragon.name} 的档案:\n    - 心情: ${ignisData.mood}\n    - 最爱食物: ${ignisData.favoriteFood}`);\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-3-Set与Map.md", "blockIndex": 4}
{"id": "js-sec-7-1-4", "title": "Symbol类型", "code": "// 使用 Symbol() 函数创建一个新的 Symbol 值\nconst sym1 = Symbol();\nconst sym2 = Symbol();\n\n// 你可以为 Symbol 添加一个描述，便于调试\nconst symWithDescription = Symbol('这是一个描述');\n\nconsole.log(sym1); // 输出: Symbol()\nconsole.log(symWithDescription); // 输出: Symbol(这是一个描述)\n\n// 即使描述相同，创建的 Symbol 也是完全不同的\nconst symFoo1 = Symbol('foo');\nconst symFoo2 = Symbol('foo');\n\nconsole.log('两个描述相同的Symbol是否相等？', symFoo1 === symFoo2); // 输出: false", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-4-Symbol类型.md", "blockIndex": 0}
{"id": "js-sec-7-1-4", "title": "Symbol类型", "code": "// 创建两个描述相同的 Symbol\nconst id1 = Symbol('user_id');\nconst id2 = Symbol('user_id');\n\nconsole.log('id1 === id2:', id1 === id2); // 输出: false\n\n// 将 Symbol 作为对象属性的键\nconst user = {\n  name: 'Alice'\n};\n\nuser[id1] = '12345';\nuser[id2] = '67890'; // 这不会覆盖 user[id1]，因为 id1 和 id2 是不同的 Symbol\n\nconsole.log('用户信息:', user);\n// 输出: { name: 'Alice', [Symbol(user_id)]: '12345', [Symbol(user_id)]: '67890' }\nconsole.log('通过id1获取值:', user[id1]); // 输出: 12345\nconsole.log('通过id2获取值:', user[id2]); // 输出: 67890", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-4-Symbol类型.md", "blockIndex": 1}
{"id": "js-sec-7-1-4", "title": "Symbol类型", "code": "const secretKey = Symbol('这是一个秘密');\n\nconst character = {\n  name: 'Gandalf',\n  level: 99,\n  [secretKey]: 'You shall not pass!' // 使用 Symbol 作为属性键\n};\n\nconsole.log('--- 常规遍历方法 ---');\n// for...in 循环会忽略 Symbol 属性\nfor (let key in character) {\n  console.log(`for...in 找到的键: ${key}`); // 只会输出 name 和 level\n}\n\n// Object.keys() 也会忽略\nconsole.log('Object.keys():', Object.keys(character)); // 输出: ['name', 'level']\n\n// JSON.stringify() 同样会忽略\nconsole.log('JSON 序列化:', JSON.stringify(character)); // 输出: {\"name\":\"Gandalf\",\"level\":99}\n\nconsole.log('\\n--- 获取 Symbol 属性的专门方法 ---');\n// 必须使用 Object.getOwnPropertySymbols() 来获取 Symbol 属性\nconst symbolKeys = Object.getOwnPropertySymbols(character);\nconsole.log('找到的 Symbol 键:', symbolKeys); // 输出: [Symbol(这是一个秘密)]\n\n// 获取 Symbol 属性的值\nconsole.log('秘密信息是:', character[symbolKeys[0]]); // 输出: You shall not pass!", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-4-Symbol类型.md", "blockIndex": 2}
{"id": "js-sec-7-1-4", "title": "Symbol类型", "code": "// 完整的对比示例，包含所有必要的变量定义\nconsole.log(\"=== 错误用法 ❌ ===\");\ntry {\n  // 错误：Symbol 是一个原始类型，不能像构造函数一样使用 `new`\n  const sym = new Symbol('test');\n  console.log(sym);\n} catch (error) {\n  console.log('错误原因:', error.message); // 输出: Symbol is not a constructor\n}\nconsole.log(\"解释: Symbol() 是一个普通函数，不是类，所以不能用 `new` 关键字调用。\");\n\n\nconsole.log(\"\\n=== 正确用法 ✅ ===\");\n// 正确：直接调用 Symbol() 函数\nconst correctSym = Symbol('test');\nconst user = {};\n\n// 使用 Symbol 作为唯一的属性键，避免与可能存在的 'id' 字符串键冲突\nuser[correctSym] = 'unique-user-id-123';\nuser['id'] = 'common-id-456';\n\nconsole.log('正确的Symbol:', correctSym); // 输出: Symbol(test)\nconsole.log('对象内容:', user); // 输出: { id: 'common-id-456', [Symbol(test)]: 'unique-user-id-123' }\nconsole.log(\"解释: 正确的方式是直接调用 Symbol()。它创建了一个唯一的值，可以安全地用作对象属性，而不会与 'id' 这样的常规字符串属性发生冲突。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-4-Symbol类型.md", "blockIndex": 3}
{"id": "js-sec-7-1-4", "title": "Symbol类型", "code": "// --- 游戏本体代码 (你不能修改这部分) ---\nfunction createCharacter(name, level) {\n  return {\n    name: name,\n    level: level,\n    attack: level * 10,\n    introduce: function() {\n      console.log(`我是 ${this.name}，等级 ${this.level}！`);\n    }\n  };\n}\n\nconst myHero = createCharacter('火焰骑士', 15);\n\n\n// --- “魔法森林”扩展包代码 (你的代码) ---\n\n// 1. 定义一个独一无二的 Symbol 来代表我们的新技能\nconst ENCHANTMENT_NATURE_POWER = Symbol('Nature Power');\n\n// 2. 创建一个附魔函数，它会给角色添加新技能\nfunction enchantWithNature(character) {\n  // 使用 Symbol 作为 key，绝对不会和 'name', 'level', 'attack' 等冲突\n  character[ENCHANTMENT_NATURE_POWER] = {\n    skillName: '藤蔓缠绕',\n    damage: 50,\n    apply: function() {\n      console.log(`🌿 ${character.name} 发动了【${this.skillName}】！造成 ${this.damage} 点自然伤害！`);\n    }\n  };\n  console.log(`✨ ${character.name} 获得了“自然之力”附魔！`);\n}\n\n// 3. 为我们的英雄附魔\nenchantWithNature(myHero);\n\n// --- 游戏主循环 ---\n\nconsole.log('\\n--- 角色状态检查 ---');\nmyHero.introduce();\nconsole.log('基础攻击力:', myHero.attack);\n\n// 游戏本体的常规遍历代码，完全看不到我们的附魔属性\nconsole.log('角色公开属性:', Object.keys(myHero));\n\n\nconsole.log('\\n--- 扩展包技能触发 ---');\n// 我们可以通过我们自己定义的 Symbol 来安全地访问和使用新技能\nif (myHero[ENCHANTMENT_NATURE_POWER]) {\n  myHero[ENCHANTMENT_NATURE_POWER].apply();\n} else {\n  console.log(`${myHero.name} 没有学会“自然之力”。`);\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-4-Symbol类型.md", "blockIndex": 4}
{"id": "js-sec-7-1-5", "title": "Proxy与Reflect", "code": "// 目标对象：一个普通的书本信息\nconst book = {\n  title: \"The Lord of the Rings\",\n  author: \"J.R.R. Tolkien\"\n};\n\n// 创建一个代理处理器\nconst handler = {\n  // 'get' 是一个“陷阱”，用于拦截属性读取操作\n  get: function(target, property) {\n    console.log(`正在访问属性: ${property}`);\n    // 使用 Reflect.get 来安全地获取原始对象的属性值\n    return Reflect.get(target, property);\n  }\n};\n\n// 创建 book 对象的代理\nconst proxyBook = new Proxy(book, handler);\n\n// 通过代理访问属性\nconsole.log(proxyBook.title); \n// 输出: 正在访问属性: title\n// 输出: The Lord of the Rings\n\nconsole.log(proxyBook.author);\n// 输出: 正在访问属性: author\n// 输出: J.R.R. Tolkien", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-5-Proxy与Reflect.md", "blockIndex": 0}
{"id": "js-sec-7-1-5", "title": "Proxy与Reflect", "code": "// 一个存储用户配置的对象\nconst userConfig = {\n  theme: 'dark',\n  fontSize: 14\n};\n\n// 代理处理器，为不存在的配置提供默认值\nconst configHandler = {\n  get: function(target, property) {\n    console.log(`尝试获取配置: '${property}'`);\n    if (property in target) {\n      return Reflect.get(target, property);\n    } else {\n      // 如果属性不存在，返回一个友好的默认提示\n      console.log(`'${property}' 配置项不存在，返回默认值 'default'`);\n      return 'default';\n    }\n  }\n};\n\nconst proxyConfig = new Proxy(userConfig, configHandler);\n\n// 访问存在的属性\nconsole.log(`主题: ${proxyConfig.theme}`);\n// 输出: 尝试获取配置: 'theme'\n// 输出: 主题: dark\n\n// 访问不存在的属性\nconsole.log(`语言: ${proxyConfig.language}`);\n// 输出: 尝试获取配置: 'language'\n// 输出: 'language' 配置项不存在，返回默认值 'default'\n// 输出: 语言: default", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-5-Proxy与Reflect.md", "blockIndex": 1}
{"id": "js-sec-7-1-5", "title": "Proxy与Reflect", "code": "// 目标用户对象\nconst user = {\n  name: \"Alice\",\n  age: 30\n};\n\n// 代理处理器，用于验证年龄\nconst validationHandler = {\n  set: function(target, property, value) {\n    if (property === 'age') {\n      if (typeof value !== 'number' || value <= 0) {\n        // 如果值无效，抛出错误，阻止赋值\n        console.error(\"错误：年龄必须是一个正数！\");\n        return false; // 表示赋值失败\n      }\n    }\n    // 对于有效值或其他属性，使用 Reflect.set 完成赋值\n    console.log(`设置属性 ${property} 为 ${value}`);\n    return Reflect.set(target, property, value);\n  }\n};\n\nconst proxyUser = new Proxy(user, validationHandler);\n\n// 尝试进行一次有效的赋值\nproxyUser.age = 31;\nconsole.log(\"用户的新年龄:\", user.age);\n// 输出: 设置属性 age 为 31\n// 输出: 用户的新年龄: 31\n\n// 尝试进行一次无效的赋值\nproxyUser.age = -5;\nconsole.log(\"尝试无效赋值后，用户的年龄:\", user.age);\n// 输出: 错误：年龄必须是一个正数！\n// 输出: 尝试无效赋值后，用户的年龄: 31 (年龄没有被改变)", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-5-Proxy与Reflect.md", "blockIndex": 2}
{"id": "js-sec-7-1-5", "title": "Proxy与Reflect", "code": "// 准备一个带有 setter 的目标对象\nconst userWithSetter = {\n  _name: \"Guest\",\n  get name() {\n    return this._name;\n  },\n  set name(value) {\n    console.log(\"内置的 setter 被调用了！\");\n    this._name = `User: ${value}`;\n  }\n};\n\n\nconsole.log(\"=== 错误用法 (可能破坏 this 指向和 setter) ===\");\n// ❌ 错误做法：在 handler 中直接操作 target\nconst wrongHandler = {\n  set: function(target, property, value) {\n    console.log(\"Proxy 'set' 拦截: 直接修改 target\");\n    // 直接赋值会调用 setter，但如果 setter 内部依赖 this，\n    // 且 this 被期望为代理对象时，这里会出问题。\n    // 在这个简单例子中能工作，但在更复杂场景（如继承）下会失败。\n    target[property] = value; \n    return true;\n  }\n};\nconst wrongProxy = new Proxy(userWithSetter, wrongHandler);\nwrongProxy.name = \"Alice\";\nconsole.log(\"错误用法后的名字:\", wrongProxy.name);\n// 解释：直接使用 `target[property] = value` 绕过了Proxy的上下文（receiver），\n// 在处理带有 getter/setter 或继承的原型链时，可能导致 `this` 指向不正确，从而引发错误。\n\n\nconsole.log(\"\\n=== 正确用法 (使用 Reflect) ===\");\n// ✅ 正确做法：使用 Reflect.set 保证操作的正确性\nconst correctHandler = {\n  set: function(target, property, value, receiver) {\n    console.log(\"Proxy 'set' 拦截: 使用 Reflect.set\");\n    // Reflect.set 会正确地处理 this 指向（传入 receiver），并返回操作是否成功的布尔值。\n    // 这是在 Proxy 陷阱中执行默认操作的标准方式。\n    return Reflect.set(target, property, value, receiver);\n  }\n};\nconst correctProxy = new Proxy(userWithSetter, correctHandler);\ncorrectProxy.name = \"Bob\";\nconsole.log(\"正确用法后的名字:\", correctProxy.name);\n// 解释：`Reflect.set` 就像是内部 `[[Set]]` 操作的函数版本。它不仅完成了赋值，\n// 还正确地将 `receiver` (通常是代理对象本身) 作为 `this` 的上下文传递给目标对象的 setter，\n// 确保了操作的完整性和安全性。", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-5-Proxy与Reflect.md", "blockIndex": 3}
{"id": "js-sec-7-1-5", "title": "Proxy与Reflect", "code": "// 我们的虚拟宠物的基础属性\nconst myPet = {\n  name: \"皮卡丘\",\n  hunger: 50, // 饥饿度 (0-100)\n  happiness: 50, // 快乐度 (0-100)\n};\n\n// 宠物心情处理器\nconst petHandler = {\n  get(target, prop) {\n    if (prop === 'mood') {\n      // 'mood' 是一个虚拟属性，根据饥饿和快乐度动态计算\n      if (target.hunger > 70 && target.happiness < 30) {\n        return \"😭 饿得快哭了，也不开心...\";\n      } else if (target.hunger > 70) {\n        return \"😫 好饿啊，快给我吃的！\";\n      } else if (target.happiness < 30) {\n        return \"😞 有点不开心，求关注。\";\n      }\n      return \"😊 心情不错！\";\n    }\n    \n    // 对于不存在的属性，给一个有趣的反馈\n    if (!(prop in target)) {\n      return `🤔 ${target.name}歪了歪头，不明白 '${prop}' 是什么意思。`;\n    }\n\n    return Reflect.get(target, prop);\n  },\n\n  set(target, prop, value) {\n    // 拦截对饥饿度的修改\n    if (prop === 'hunger') {\n      if (value < target.hunger) {\n        console.log(`🍴 给 ${target.name} 喂食... 饥饿度降低！`);\n      } else {\n        console.log(`🏃 ${target.name} 玩耍了一会儿，更饿了...`);\n      }\n      target.hunger = Math.max(0, Math.min(100, value)); // 确保值在0-100之间\n      return true;\n    }\n\n    // 拦截对快乐度的修改\n    if (prop === 'happiness') {\n       if (value > target.happiness) {\n        console.log(`💖 和 ${target.name} 玩耍... 快乐度提升！`);\n      } else {\n        console.log(`😢 ${target.name} 感到被冷落了...`);\n      }\n      target.happiness = Math.max(0, Math.min(100, value)); // 确保值在0-100之间\n      return true;\n    }\n    \n    return Reflect.set(target, prop, value);\n  }\n};\n\n// 创建我们的智能宠物代理\nconst smartPet = new Proxy(myPet, petHandler);\n\nconsole.log(`你好，我的名字是 ${smartPet.name}`);\nconsole.log(`当前心情: ${smartPet.mood}`); // 访问虚拟属性\n\nconsole.log(\"\\n--- 开始互动 ---\");\n\nsmartPet.hunger -= 30; // 喂食\nsmartPet.happiness += 20; // 玩耍\n\nconsole.log(`\\n互动后，${smartPet.name} 的饥饿度: ${smartPet.hunger}`);\nconsole.log(`互动后，${smartPet.name} 的快乐度: ${smartPet.happiness}`);\nconsole.log(`现在的心情: ${smartPet.mood}`);\n\nconsole.log(\"\\n--- 尝试奇怪的操作 ---\");\nconsole.log(smartPet.color); // 访问不存在的属性", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-1-5-Proxy与Reflect.md", "blockIndex": 4}
{"id": "js-sec-7-2-1", "title": "模块导出export", "code": "// 假设这是文件: 'mathUtils.js'\n// 我们在这里定义并导出内容\n\n// 导出一个变量\nexport const PI = 3.14159;\n\n// 导出一个函数\nexport function circleArea(radius) {\n  return PI * radius * radius;\n}\n\n// --- 为了让这个代码块能独立运行并展示结果 ---\n// 在真实的模块文件中，你通常不会在顶层写这些 console.log。\n// 但为了教学演示，我们在这里打印一下导出的内容，证明它们是存在的。\nconsole.log(\"在 'mathUtils.js' 模块中:\");\nconsole.log(\"导出的常量 PI:\", PI);\nconst area = circleArea(10);\nconsole.log(\"调用导出的函数 circleArea(10):\", area);\nconsole.log(\"✅ 这个模块已准备好导出 'PI' 和 'circleArea'。\");\n// 在另一个文件中，你就可以这样使用: import { PI, circleArea } from './mathUtils.js';", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-2-1-模块导出export.md", "blockIndex": 0}
{"id": "js-sec-7-2-1", "title": "模块导出export", "code": "// 假设这是文件: 'stringUtils.js'\n\n// 语法1: 在声明时直接导出\nexport const version = \"1.0\";\n\nexport function toUpperCase(str) {\n  return str.toUpperCase();\n}\n\n// 语法2: 集中在文件末尾导出\nfunction toLowerCase(str) {\n  return str.toLowerCase();\n}\nconst author = \"JS Expert\";\n\n// 使用一个 export 语句导出多个\nexport { toLowerCase, author };\n\n\n// --- 教学演示 ---\nconsole.log(\"模块 'stringUtils.js' 准备了以下命名导出项：\");\nconsole.log(\"- version:\", version);\nconsole.log(\"- toUpperCase:\", toUpperCase(\"hello\"));\nconsole.log(\"- toLowerCase:\", toLowerCase(\"WORLD\"));\nconsole.log(\"- author:\", author);\nconsole.log(\"在其他文件中可以通过 `import { version, toUpperCase, toLowerCase, author } from './stringUtils.js'` 来使用它们。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-2-1-模块导出export.md", "blockIndex": 1}
{"id": "js-sec-7-2-1", "title": "模块导出export", "code": "// 假设这是文件: 'userProfile.js'\n\nclass User {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  getInfo() {\n    return `用户: ${this.name}, 年龄: ${this.age}`;\n  }\n}\n\n// 将 User 类作为默认导出\nexport default User;\n\n\n// --- 教学演示 ---\nconsole.log(\"模块 'userProfile.js' 提供了一个默认导出。\");\n// 模拟创建一个实例来验证\nconst defaultExportedClass = User;\nconst testUser = new defaultExportedClass(\"Alice\", 30);\nconsole.log(\"导出的内容是一个类，我们可以用它创建实例:\");\nconsole.log(testUser.getInfo());\nconsole.log(\"在其他文件中，可以这样导入: `import MyUser from './userProfile.js'`，其中 'MyUser' 是可以自定义的名称。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-2-1-模块导出export.md", "blockIndex": 2}
{"id": "js-sec-7-2-1", "title": "模块导出export", "code": "// === 错误用法 ===\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 语法错误：一个模块中不能有多个 export default\n// export default function greet() { console.log(\"Hello\"); }\n// export default const name = \"World\"; // 这会直接导致语法错误\n\n// 为了让代码块能运行，我们将错误代码注释掉并解释\nconsole.log(\"❌ 错误：一个文件只能有一个 'export default'。\");\nconsole.log(\"   它代表模块的“主要”输出。如果你需要导出多个东西，应该使用命名导出。\");\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确做法：结合使用一个默认导出和多个命名导出\n// 假设这是文件: 'formatter.js'\n\n// 默认导出：最常用的格式化函数\nfunction formatCurrency(amount) {\n  return `$${amount.toFixed(2)}`;\n}\nexport default formatCurrency;\n\n// 命名导出：其他辅助函数\nexport function formatDate(date) {\n  return date.toISOString().split('T')[0];\n}\nexport const version = \"2.1\";\n\n// --- 教学演示 ---\nconsole.log(\"✅ 正确：一个模块可以同时拥有一个默认导出和多个命名导出。\");\nconst mainExport = formatCurrency;\nconsole.log(\"默认导出 (formatCurrency):\", mainExport(12.3));\nconsole.log(\"命名导出 (formatDate):\", formatDate(new Date()));\nconsole.log(\"命名导出 (version):\", version);\nconsole.log(\"导入时可以这样写: `import format, { formatDate, version } from './formatter.js';`\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-2-1-模块导出export.md", "blockIndex": 3}
{"id": "js-sec-7-2-1", "title": "模块导出export", "code": "// 假设这是文件: 'characterUtils.js'\n// =======================================\n// 这个模块提供了创建游戏角色所需的一切！\n\n// 默认导出: 核心的角色类，这是模块的主要功能\nclass Character {\n  constructor(name, race, strength, dexterity, intelligence) {\n    this.name = name;\n    this.race = race;\n    this.stats = { strength, dexterity, intelligence };\n    this.hp = 10 + Math.floor(strength / 2); // 生命值基于力量\n    this.inventory = [];\n  }\n\n  introduce() {\n    console.log(`⚔️ 我是 ${this.name}，一个勇敢的${this.race}！我的力量是 ${this.stats.strength}！`);\n  }\n\n  addToInventory(item) {\n    this.inventory.push(item);\n    console.log(`🎒 ${this.name} 的背包里新增了: ${item}`);\n  }\n}\n// 在真实模块中，你会写: export default Character;\n\n// 命名导出: 一些有用的工具函数\nconst fantasyNames = [\"艾拉瑞亚\", \"格罗姆\", \"莉安德拉\", \"索林\"];\nfunction generateRandomName() {\n  console.log(\"🔮 命运之轮正在转动，为你选择一个名字...\");\n  return fantasyNames[Math.floor(Math.random() * fantasyNames.length)];\n}\n// 在真实模块中，你会写: export { generateRandomName };\n\nfunction rollD20() {\n  console.log(\"🎲 投掷20面骰子...\");\n  return Math.floor(Math.random() * 20) + 1;\n}\n// 在真实模块中，你会写: export { rollD20 };\n\n\n// --- 模拟在另一个文件 'game.js' 中使用这个模块 ---\nconsole.log(\"🚀 欢迎来到奇幻世界！开始创建你的游戏角色！\\n\");\n\n// 假设我们已经导入:\n// import Character, { generateRandomName, rollD20 } from './characterUtils.js';\n\n// 使用命名导出的函数生成名字\nconst playerName = generateRandomName();\n\n// 使用默认导出的 Character 类和命名导出的 rollD20 函数创建英雄\nconst myHero = new Character(\n  playerName,\n  \"精灵弓箭手\",\n  rollD20(), // 力量\n  rollD20(), // 敏捷\n  rollD20()  // 智力\n);\n\nmyHero.introduce();\nmyHero.addToInventory(\"精灵长弓\");\nmyHero.addToInventory(\"一袋金币\");\n\nconsole.log(\"\\n--- ✨ 角色创建完毕 ---\");\nconsole.log(\"你的英雄信息:\", JSON.stringify(myHero, null, 2));", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-2-1-模块导出export.md", "blockIndex": 4}
{"id": "js-sec-7-2-2", "title": "模块导入import", "code": "// 为了让这个示例能独立运行，我们使用一种特殊技巧(Blob和import())来模拟一个外部文件。\n// 在实际开发中，你会直接写 `import greet from './greeter.js';`\n\n// 模拟一个名为 'greeter.js' 的文件，它有一个默认导出的函数\nconst greeterModuleContent = `export default function greet(name) { return \\`Hello, \\${name}!\\`; }`;\nconst blob = new Blob([greeterModuleContent], { type: 'application/javascript' });\nconst greeterModuleUrl = URL.createObjectURL(blob);\n\n// 动态导入模块并使用其功能\nimport(greeterModuleUrl).then((greeterModule) => {\n  const greet = greeterModule.default;\n  const message = greet('World');\n  console.log(message);\n});\n\n// 输出:\n// Hello, World!", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-2-2-模块导入import.md", "blockIndex": 0}
{"id": "js-sec-7-2-2", "title": "模块导入import", "code": "// 模拟一个名为 'constants.js' 的文件，它导出了多个常量\nconst constantsModuleContent = `\n  export const PI = 3.14159;\n  export const E = 2.718;\n  export function calculateCircumference(radius) {\n    return 2 * PI * radius;\n  }\n`;\nconst blob = new Blob([constantsModuleContent], { type: 'application/javascript' });\nconst constantsModuleUrl = URL.createObjectURL(blob);\n\n// 动态导入模块\nimport(constantsModuleUrl).then(({ PI, E, calculateCircumference }) => {\n  // 1. 按需导入 PI 和 E\n  console.log('圆周率 PI:', PI);\n  console.log('自然常数 E:', E);\n\n  // 2. 导入函数并使用\n  const circumference = calculateCircumference(10);\n  console.log('半径为10的圆周长:', circumference);\n});\n\n// 假如我们自己的代码里已经有一个叫PI的变量，可以这样使用别名\nimport(constantsModuleUrl).then(({ PI: MathPI, E }) => {\n  const PI = 'My Personal Identifier';\n  console.log('--- 使用别名 ---');\n  console.log('我自己的 PI:', PI);\n  console.log('从模块导入并重命名的 MathPI:', MathPI);\n});\n\n// 输出:\n// 圆周率 PI: 3.14159\n// 自然常数 E: 2.718\n// 半径为10的圆周长: 62.8318\n// --- 使用别名 ---\n// 我自己的 PI: My Personal Identifier\n// 从模块导入并重命名的 MathPI: 3.14159", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-2-2-模块导入import.md", "blockIndex": 1}
{"id": "js-sec-7-2-2", "title": "模块导入import", "code": "// 模拟一个名为 'mathUtils.js' 的工具库\nconst mathUtilsModuleContent = `\n  export const PI = 3.14159;\n  export function add(a, b) { return a + b; }\n  export function subtract(a, b) { return a - b; }\n`;\nconst blob = new Blob([mathUtilsModuleContent], { type: 'application/javascript' });\nconst mathUtilsModuleUrl = URL.createObjectURL(blob);\n\n// 动态导入整个模块到一个命名空间对象 `MathUtils` 中\nimport(mathUtilsModuleUrl).then((MathUtils) => {\n  console.log('导入的整个模块内容:', MathUtils);\n  \n  const sum = MathUtils.add(5, 3);\n  console.log('5 + 3 =', sum);\n  \n  const difference = MathUtils.subtract(10, 4);\n  console.log('10 - 4 =', difference);\n  \n  console.log('模块中的 PI:', MathUtils.PI);\n});\n\n// 输出:\n// 导入的整个模块内容: [Module: null] { add: [Function: add], subtract: [Function: subtract], PI: 3.14159 }\n// 5 + 3 = 8\n// 10 - 4 = 6\n// 模块中的 PI: 3.14159", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-2-2-模块导入import.md", "blockIndex": 2}
{"id": "js-sec-7-2-2", "title": "模块导入import", "code": "// 注意：静态import语法 (import ... from ...) 在普通脚本或函数中会直接导致语法错误。\n// 下面的代码块通过展示动态import()作为正确用法来对比这个概念。\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 静态 import 只能在模块的顶层使用，不能在函数或代码块内部。\n// 下面的代码如果直接在 .js 文件中运行会立即抛出 SyntaxError。\nfunction attemptToImport() {\n  // import { PI } from './math.js'; // SyntaxError: 'import' and 'export' may only appear at the top level.\n  console.log(\"这段代码永远不会执行，因为上面的import会引发语法错误。\");\n}\nconsole.log(\"错误原因：静态 import 设计用于在代码执行前就确定模块依赖关系，所以必须写在最外层。\");\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 如果你确实需要在特定条件下或在函数内部加载模块，应该使用动态 import()，它返回一个 Promise。\nasync function correctlyImport() {\n  console.log(\"准备动态加载模块...\");\n  \n  // 模拟一个模块\n  const moduleContent = `export const message = \"模块加载成功！\";`;\n  const blob = new Blob([moduleContent], { type: 'application/javascript' });\n  const moduleUrl = URL.createObjectURL(blob);\n\n  try {\n    const myModule = await import(moduleUrl);\n    console.log(myModule.message);\n  } catch (error) {\n    console.error(\"加载模块失败:\", error);\n  }\n}\nconsole.log(\"正确做法：使用动态 import() 函数可以在任何地方按需加载模块。\");\ncorrectlyImport();\n\n// 输出:\n// === 错误用法 ===\n// 错误原因：静态 import 设计用于在代码执行前就确定模块依赖关系，所以必须写在最外层。\n//\n// === 正确用法 ===\n// 正确做法：使用动态 import() 函数可以在任何地方按需加载模块。\n// 准备动态加载模块...\n// 模块加载成功！", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-2-2-模块导入import.md", "blockIndex": 3}
{"id": "js-sec-7-2-2", "title": "模块导入import", "code": "// === 模拟模块文件 ===\n\n// 1. 'core.js': 提供机甲核心\nconst coreModuleContent = `\n  export default function getCore(type) {\n    if (type === 'fusion') return { name: '核聚变核心', power: 100 };\n    return { name: '标准能量核心', power: 50 };\n  }\n`;\n\n// 2. 'weapons.js': 提供武器选项\nconst weaponsModuleContent = `\n  export const laserCannon = { name: '激光加农炮', damage: 40 };\n  export const plasmaRifle = { name: '等离子步枪', damage: 30 };\n`;\n\n// 3. 'skins.js': 提供涂装方案\nconst skinsModuleContent = `\n  export const availableSkins = ['沙漠迷彩', '深空暗影', '赤红彗星'];\n  export function applySkin(mech, skinName) {\n    mech.skin = availableSkins.includes(skinName) ? skinName : '默认涂装';\n    return mech;\n  }\n`;\n\n// === 主程序：机甲建造车间 ===\n\nasync function buildMech(coreType, weapon, skin) {\n  console.log(`🤖 开始建造新的机甲，代号：${skin.replace('迷彩','').replace('暗影','').replace('彗星','')}...`);\n\n  // 创建模块的URL以便动态导入\n  const coreBlob = new Blob([coreModuleContent], { type: 'application/javascript' });\n  const weaponsBlob = new Blob([weaponsModuleContent], { type: 'application/javascript' });\n  const skinsBlob = new Blob([skinsModuleContent], { type: 'application/javascript' });\n\n  const coreUrl = URL.createObjectURL(coreBlob);\n  const weaponsUrl = URL.createObjectURL(weaponsBlob);\n  const skinsUrl = URL.createObjectURL(skinsBlob);\n\n  // 并行导入所有需要的模块\n  const [coreModule, weaponsModule, skinsModule] = await Promise.all([\n    import(coreUrl),\n    import(weaponsUrl),\n    import(skinsUrl)\n  ]);\n  \n  // 从模块中提取所需功能\n  const getCore = coreModule.default;\n  const { laserCannon, plasmaRifle } = weaponsModule;\n  const { applySkin } = skinsModule;\n\n  // 开始组装\n  console.log(\"🔩 正在安装核心...\");\n  let myMech = {\n    core: getCore(coreType),\n    weapons: [],\n  };\n\n  console.log(\"🔫 加载武器系统...\");\n  if (weapon === 'laser') {\n    myMech.weapons.push(laserCannon);\n  } else {\n    myMech.weapons.push(plasmaRifle);\n  }\n  \n  console.log(\"🎨 进行涂装...\");\n  myMech = applySkin(myMech, skin);\n\n  console.log(\"\\n✨ 机甲建造完成！规格如下：✨\");\n  console.log(JSON.stringify(myMech, null, 2));\n}\n\n// 让我们来建造一台超酷的机甲！\nbuildMech('fusion', 'laser', '赤红彗星');\n\n// 输出:\n// 🤖 开始建造新的机甲，代号：赤红...\n// 🔩 正在安装核心...\n// 🔫 加载武器系统...\n// 🎨 进行涂装...\n//\n// ✨ 机甲建造完成！规格如下：✨\n// {\n//   \"core\": {\n//     \"name\": \"核聚变核心\",\n//     \"power\": 100\n//   },\n//   \"weapons\": [\n//     {\n//       \"name\": \"激光加农炮\",\n//       \"damage\": 40\n//     }\n//   ],\n//   \"skin\": \"赤红彗星\"\n// }", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-2-2-模块导入import.md", "blockIndex": 4}
{"id": "js-sec-7-2-3", "title": "默认导出", "code": "// 假设这是文件: greetings.js\n// 我们定义一个函数并将其作为默认导出\nconst createGreeting = (name) => {\n  return `你好, ${name}! 欢迎来到 JavaScript 世界。`;\n};\n// 在真实文件中，你会写: export default createGreeting;\n\n\n// 假设这是文件: main.js\n// 在真实文件中，你会写: import myGreetingFunction from './greetings.js';\n// 为了演示，我们直接使用上面定义的函数\nconst myGreetingFunction = createGreeting;\n\n// 现在我们可以使用这个导入的函数了\nconst message = myGreetingFunction(\"探险家\");\nconsole.log(message);\n// 输出: 你好, 探险家! 欢迎来到 JavaScript 世界。", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-2-3-默认导出.md", "blockIndex": 0}
{"id": "js-sec-7-2-3", "title": "默认导出", "code": "// 模拟文件: anonymous-module.js\n// 我们可以直接导出一个匿名的箭头函数\nconst anonymousGreeter = (name) => `Hello, ${name}! This is an anonymous function.`;\n// 真实语法: export default (name) => `Hello, ${name}! This is an anonymous function.`;\n\n// 也可以导出一个匿名的对象\nconst anonymousConfig = {\n    version: '1.0.0',\n    author: 'Anonymous'\n};\n// 真实语法: export default { version: '1.0.0', author: 'Anonymous' };\n\n\n// 模拟文件: main.js\n// 导入匿名的函数\nconst greeter = anonymousGreeter;\nconsole.log(greeter('Alice'));\n// 输出: Hello, Alice! This is an anonymous function.\n\n// 导入匿名的对象\nconst config = anonymousConfig;\nconsole.log(`App Version: ${config.version} by ${config.author}`);\n// 输出: App Version: 1.0.0 by Anonymous", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-2-3-默认导出.md", "blockIndex": 1}
{"id": "js-sec-7-2-3", "title": "默认导出", "code": "// 模拟文件: user-profile.js\n// 定义一个类作为默认导出\nclass UserProfile {\n  constructor(name, level) {\n    this.name = name;\n    this.level = level;\n  }\n  getInfo() {\n    return `${this.name} (Level ${this.level})`;\n  }\n}\n// 真实语法: export default UserProfile;\n\n\n// 模拟文件: app.js\n// 我们可以用任何我们喜欢的名字来导入它\nconst Profile = UserProfile; // 命名为 Profile\nconst Player = UserProfile;  // 或者命名为 Player\n\nconst user1 = new Profile('Byte Explorer', 99);\nconst user2 = new Player('Code Ninja', 50);\n\nconsole.log('使用 \"Profile\" 名称导入:', user1.getInfo());\nconsole.log('使用 \"Player\" 名称导入:', user2.getInfo());\n// 输出:\n// 使用 \"Profile\" 名称导入: Byte Explorer (Level 99)\n// 使用 \"Player\" 名称导入: Code Ninja (Level 50)", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-2-3-默认导出.md", "blockIndex": 2}
{"id": "js-sec-7-2-3", "title": "默认导出", "code": "// 模拟文件: mixed-exports.js\nconst mainFunction = () => \"这是默认导出的主要功能。\";\nconst helperFunction = () => \"这是一个命名导出的辅助工具。\";\n// 真实语法:\n// export default mainFunction;\n// export { helperFunction };\n\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误1: 尝试用花括号导入默认导出\ntry {\n  // 模拟: import { mainFunction } from './mixed-exports.js';\n  // 这会失败，因为 mainFunction 是默认导出，不是命名导出\n  const { mainFunction: wrongImport1 } = { default: mainFunction, helperFunction };\n  // 在真实模块环境中，上面的导入会得到 undefined\n  if (typeof wrongImport1 === 'undefined') {\n    console.log(\"错误1: 无法用 {} 导入默认导出，得到 undefined。\");\n  }\n} catch (e) {\n  console.log(\"错误1: \", e.message);\n}\n\n// ❌ 错误2: 尝试不用花括号导入命名导出\ntry {\n  // 模拟: import helperFunction from './mixed-exports.js';\n  // 这会把默认导出的内容赋值给 helperFunction 变量，而不是导入真正的 helperFunction\n  const wrongImport2 = mainFunction;\n  console.log(\"错误2: 'import helperFunction' 实际上导入了默认导出:\", wrongImport2());\n} catch (e) {\n  console.log(\"错误2: \", e.message);\n}\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确: 同时导入默认导出和命名导出\n// 模拟: import MyMain, { helperFunction } from './mixed-exports.js';\nconst MyMain = mainFunction;\nconst { helperFunction: correctHelper } = { helperFunction };\n\nconsole.log(\"默认导出 (重命名为 MyMain):\", MyMain());\nconsole.log(\"命名导出 (helperFunction):\", correctHelper());\n// 输出:\n// === 错误用法 ===\n// 错误1: 无法用 {} 导入默认导出，得到 undefined。\n// 错误2: 'import helperFunction' 实际上导入了默认导出: 这是默认导出的主要功能。\n//\n// === 正确用法 ===\n// 默认导出 (重命名为 MyMain): 这是默认导出的主要功能。\n// 命名导出 (helperFunction): 这是一个命名导出的辅助工具。", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-2-3-默认导出.md", "blockIndex": 3}
{"id": "js-sec-7-2-3", "title": "默认导出", "code": "// 模拟文件: spaceship-factory.js\n// 这个模块的核心功能就是定义和导出一个飞船类\nclass Spaceship {\n  constructor(name, pilot) {\n    this.name = name;\n    this.pilot = pilot;\n    this.fuel = 100;\n    this.isLaunched = false;\n    console.log(`🔧 飞船 \"${this.name}\" 建造完毕，舰长是 ${this.pilot}！`);\n  }\n\n  launch() {\n    if (this.fuel <= 0) {\n      console.log(`💥 发射失败！ \"${this.name}\" 燃料耗尽了！`);\n      return;\n    }\n    this.isLaunched = true;\n    this.fuel -= 10;\n    console.log(`🚀 倒计时 3...2...1... 发射！ \"${this.name}\" 号已升空，目标星辰大海！`);\n  }\n\n  reportStatus() {\n    const status = this.isLaunched ? '在轨飞行中' : '停靠在港口';\n    console.log(\n      `📊 状态报告: 飞船 \"${this.name}\", 舰长: ${this.pilot}, 燃料: ${this.fuel}%, 状态: ${status}`\n    );\n  }\n}\n// 真实语法: export default Spaceship;\n\n\n// 模拟文件: mission-control.js\n// 我们的主程序，负责启动任务\n// 真实语法: import MyCoolShip from './spaceship-factory.js';\nconst MyCoolShip = Spaceship;\n\nconsole.log(\"--- 星际任务控制中心 ---\");\n\n// 创建第一艘飞船，并用我们喜欢的名字 MyCoolShip 来接收导入的类\nconst voyager = new MyCoolShip(\"旅行者号\", \"柯克\");\nvoyager.reportStatus();\nvoyager.launch();\nvoyager.reportStatus();\n\nconsole.log(\"\\n--- 第二舰队准备 ---\");\n\n// 创建第二艘飞船，展示了类的可复用性\nconst enterprise = new MyCoolShip(\"企业号\", \"皮卡德\");\nenterprise.reportStatus();\n// 输出:\n// --- 星际任务控制中心 ---\n// 🔧 飞船 \"旅行者号\" 建造完毕，舰长是 柯克！\n// 📊 状态报告: 飞船 \"旅行者号\", 舰长: 柯克, 燃料: 100%, 状态: 停靠在港口\n// 🚀 倒计时 3...2...1... 发射！ \"旅行者号\" 号已升空，目标星辰大海！\n// 📊 状态报告: 飞船 \"旅行者号\", 舰长: 柯克, 燃料: 90%, 状态: 在轨飞行中\n//\n// --- 第二舰队准备 ---\n// 🔧 飞船 \"企业号\" 建造完毕，舰长是 皮卡德！\n// 📊 状态报告: 飞船 \"企业号\", 舰长: 皮卡德, 燃料: 100%, 状态: 停靠在港口", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-2-3-默认导出.md", "blockIndex": 4}
{"id": "js-sec-7-2-4", "title": "动态导入", "code": "// 模拟一个名为 'math.js' 的模块\nconst mathModuleCode = `\n  export const add = (a, b) => a + b;\n  export default function multiply(a, b) { return a * b; }\n`;\nconst blob = new Blob([mathModuleCode], { type: 'application/javascript' });\nconst moduleUrl = URL.createObjectURL(blob);\n\n// 使用动态导入加载这个模拟的模块\nimport(moduleUrl)\n  .then(mathModule => {\n    console.log(\"模块加载成功!\");\n    \n    // 使用命名导出 (named export)\n    const sum = mathModule.add(5, 3);\n    console.log(\"调用命名导出 add(5, 3):\", sum);\n\n    // 使用默认导出 (default export)\n    const product = mathModule.default(5, 3);\n    console.log(\"调用默认导出 multiply(5, 3):\", product);\n  })\n  .catch(err => {\n    console.error(\"模块加载失败:\", err);\n  })\n  .finally(() => {\n    // 清理创建的URL对象\n    URL.revokeObjectURL(moduleUrl);\n  });", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-2-4-动态导入.md", "blockIndex": 0}
{"id": "js-sec-7-2-4", "title": "动态导入", "code": "// 模拟一个名为 'userProfile.js' 的模块\nconst userProfileCode = `\n  export function getGreeting(name) {\n    return \\`Hello, \\${name}! Welcome back.\\`;\n  }\n`;\nconst blob = new Blob([userProfileCode], { type: 'application/javascript' });\nconst moduleUrl = URL.createObjectURL(blob);\n\nasync function showGreeting(username) {\n  try {\n    console.log(\"准备动态加载用户问候模块...\");\n    const userProfileModule = await import(moduleUrl);\n    const message = userProfileModule.getGreeting(username);\n    console.log(message);\n  } catch (error) {\n    console.error(\"加载模块时出错:\", error);\n  } finally {\n    URL.revokeObjectURL(moduleUrl);\n  }\n}\n\nshowGreeting(\"Explorer\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-2-4-动态导入.md", "blockIndex": 1}
{"id": "js-sec-7-2-4", "title": "动态导入", "code": "// 模拟两个不同的模块：一个用于管理员，一个用于普通用户\nconst adminModuleCode = `export default () => '欢迎进入管理员控制台！';`;\nconst guestModuleCode = `export default () => '你好，访客！请先登录。';`;\n\nconst adminBlob = new Blob([adminModuleCode], { type: 'application/javascript' });\nconst guestBlob = new Blob([guestModuleCode], { type: 'application/javascript' });\n\nconst adminModuleUrl = URL.createObjectURL(adminBlob);\nconst guestModuleUrl = URL.createObjectURL(guestBlob);\n\nasync function loadDashboard(userRole) {\n  console.log(`用户角色: ${userRole}，正在加载对应模块...`);\n  let messageFunction;\n  \n  if (userRole === 'admin') {\n    const { default: getAdminMessage } = await import(adminModuleUrl);\n    messageFunction = getAdminMessage;\n  } else {\n    const { default: getGuestMessage } = await import(guestModuleUrl);\n    messageFunction = getGuestMessage;\n  }\n  \n  console.log(messageFunction());\n  \n  // 清理\n  URL.revokeObjectURL(adminModuleUrl);\n  URL.revokeObjectURL(guestModuleUrl);\n}\n\n// 模拟不同用户登录\nloadDashboard('admin');\nsetTimeout(() => loadDashboard('guest'), 100); // 延迟一点以看清两次输出", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-2-4-动态导入.md", "blockIndex": 2}
{"id": "js-sec-7-2-4", "title": "动态导入", "code": "// 模拟一个模块\nconst utilityModuleCode = `export const magicNumber = 42;`;\nconst blob = new Blob([utilityModuleCode], { type: 'application/javascript' });\nconst moduleUrl = URL.createObjectURL(blob);\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误：直接尝试访问模块内容\n// 解释：`import()` 立即返回一个Promise，而不是模块本身。\n// 在Promise完成（resolved）之前，模块内容是不可用的。\ntry {\n  const utilityModule = import(moduleUrl);\n  // 下面这行会抛出错误，因为 utilityModule 是一个Promise，没有 magicNumber 属性\n  console.log(utilityModule.magicNumber); \n} catch(e) {\n  console.error(\"出错了！错误信息:\", e.message);\n  console.log(\"👆 看到 'undefined' 或错误是正常的，因为我们在一个Promise上访问属性。\");\n}\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确：使用 async/await 等待Promise完成\n// 解释：我们创建了一个异步函数，并使用 `await` 关键字暂停执行，\n// 直到 `import()` Promise 解析出模块对象，然后才能安全地访问其属性。\nasync function correctlyLoadModule() {\n  try {\n    const utilityModule = await import(moduleUrl);\n    console.log(\"成功获取模块内容:\", utilityModule.magicNumber);\n  } catch(e) {\n    console.error(\"加载失败:\", e);\n  } finally {\n    URL.revokeObjectURL(moduleUrl);\n  }\n}\ncorrectlyLoadModule();", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-2-4-动态导入.md", "blockIndex": 3}
{"id": "js-sec-7-2-4", "title": "动态导入", "code": "// 模拟外星语言翻译模块\n// 模块1: Glooporian (黏液族) - 它们的语言是冒泡声\nconst gloopTranslatorCode = `\n  export default function translate(message) {\n    const translation = message.split('').map(char => 'gloop-').join('');\n    return \\`[黏液族语破译]: ${translation} (听起来像友好的冒泡声)\\`;\n  }\n`;\n// 模块2: Siliconoid (硅基生命) - 它们通过晶体振动沟通\nconst siliconTranslatorCode = `\n  export default function translate(message) {\n    const translation = message.split('').reverse().join('');\n    return \\`[硅基体频率分析]: ${translation} (一种高频水晶谐振)\\`;\n  }\n`;\n\n// 创建模块的内存URL\nconst gloopBlob = new Blob([gloopTranslatorCode], { type: 'application/javascript' });\nconst siliconBlob = new Blob([siliconTranslatorCode], { type: 'application/javascript' });\nconst gloopModuleUrl = URL.createObjectURL(gloopBlob);\nconst siliconModuleUrl = URL.createObjectURL(siliconBlob);\n\nconst alienEncounters = [\n  { type: 'Glooporian', message: 'Hello' },\n  { type: 'Siliconoid', message: 'Danger' },\n  { type: 'Unknown', message: '???' }\n];\n\nasync function communicateWithAlien(encounter) {\n  console.log(`\\n--- 遭遇新生物: ${encounter.type} ---`);\n  console.log(`原始信息: \"${encounter.message}\"`);\n  \n  let translatorUrl;\n  if (encounter.type === 'Glooporian') {\n    translatorUrl = gloopModuleUrl;\n  } else if (encounter.type === 'Siliconoid') {\n    translatorUrl = siliconModuleUrl;\n  } else {\n    console.log(\"[AI提示]: 未知生物类型，无法加载翻译模块。请保持警惕！\");\n    return;\n  }\n  \n  try {\n    console.log(`[AI]: 正在为 ${encounter.type} 加载专用翻译模块...`);\n    const { default: translate } = await import(translatorUrl);\n    const translatedMessage = translate(encounter.message);\n    console.log(translatedMessage);\n  } catch (error) {\n    console.error(\"[AI警告]: 翻译模块加载失败！通讯中断。\", error);\n  }\n}\n\nasync function startAdventure() {\n  console.log(\"🚀 开始星球探索...\");\n  for (const encounter of alienEncounters) {\n    await communicateWithAlien(encounter);\n  }\n  console.log(\"\\n--- 探索结束 ---\");\n  \n  // 清理内存中的模块URL\n  URL.revokeObjectURL(gloopModuleUrl);\n  URL.revokeObjectURL(siliconModuleUrl);\n}\n\nstartAdventure();", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-2-4-动态导入.md", "blockIndex": 4}
{"id": "js-sec-7-3-1", "title": "try-catch-finally", "code": "console.log(\"程序开始运行...\");\n\ntry {\n  // 我们尝试调用一个不存在的函数，这一定会引发错误\n  console.log(\"正在尝试执行危险操作...\");\n  nonExistentFunction(); \n  console.log(\"这行代码不会被执行，因为上面出错了。\");\n} catch (error) {\n  // 如果 try 块中发生错误，代码会立即跳转到这里\n  console.log(\"噢！我们抓住了一个错误！\");\n  console.log(\"错误信息:\", error.message);\n}\n\nconsole.log(\"程序并没有崩溃，而是继续执行到了这里。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-3-1-try-catch-finally.md", "blockIndex": 0}
{"id": "js-sec-7-3-1", "title": "try-catch-finally", "code": "function testFinally(shouldThrowError) {\n  try {\n    console.log(\"进入 try 块...\");\n    if (shouldThrowError) {\n      // 抛出一个自定义错误\n      throw new Error(\"一个预料之中的错误发生了！\");\n    }\n    console.log(\"try 块成功执行完毕。\");\n    // 即使这里有 return，finally 依然会执行\n    return \"从 try 返回\"; \n  } catch (error) {\n    console.error(\"进入 catch 块，捕获到错误:\", error.message);\n    // 即使这里有 return，finally 依然会执行\n    return \"从 catch 返回\";\n  } finally {\n    // 无论如何，这个 console.log 都会被打印出来\n    console.log(\"进入 finally 块，执行清理工作...\");\n  }\n}\n\nconsole.log(\"--- 场景1: 没有发生错误 ---\");\nconst result1 = testFinally(false);\nconsole.log(\"函数最终返回值:\", result1);\n\nconsole.log(\"\\n--- 场景2: 发生了错误 ---\");\nconst result2 = testFinally(true);\nconsole.log(\"函数最终返回值:\", result2);", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-3-1-try-catch-finally.md", "blockIndex": 1}
{"id": "js-sec-7-3-1", "title": "try-catch-finally", "code": "try {\n  // 让我们制造一个引用错误 (ReferenceError)\n  let user = { name: \"Alice\" };\n  console.log(user.profile.age); // user.profile 是 undefined，再访问 .age 就会报错\n} catch (error) {\n  console.log(\"捕获到了一个错误！下面是它的详细信息：\");\n  console.log(\"------------------------------------\");\n  // error.name: 错误的类型\n  console.log(\"错误类型 (name):\", error.name); \n  // error.message: 错误的具体描述\n  console.log(\"错误信息 (message):\", error.message);\n  // error.stack: 错误的堆栈跟踪，显示了错误发生的位置\n  console.log(\"堆栈跟踪 (stack):\", error.stack);\n  console.log(\"------------------------------------\");\n  console.log(\"我们可以根据这些信息来修复bug或者给用户友好提示。\");\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-3-1-try-catch-finally.md", "blockIndex": 2}
{"id": "js-sec-7-3-1", "title": "try-catch-finally", "code": "// 一个模拟从服务器获取数据的函数，但数据可能是坏的\nfunction parseUserData(jsonString) {\n  // JSON.parse 对于格式错误的字符串会抛出错误\n  return JSON.parse(jsonString);\n}\n\nconsole.log(\"=== 错误用法 ❌ ===\");\n// 假设我们从服务器收到了一个损坏的JSON字符串\nconst badJson = '{\"name\": \"Bob\", \"age\": 40'; // 结尾缺少 '}'\n\ntry {\n    console.log(\"程序开始，尝试解析坏数据...\");\n    const user = parseUserData(badJson); // 这一行会抛出错误\n    console.log(\"用户数据:\", user); // 这行永远不会执行\n    console.log(\"后续重要代码1\"); // 这行永远不会执行\n    console.log(\"后续重要代码2\"); // 这行永远不会执行\n} catch(e) {\n    // 虽然这里有个空的try-catch，但它包裹的范围太小了，没有抓住真正的错误。\n    // 真正的错误发生在函数内部，而函数调用本身没有被包裹。\n    // 为了演示目的，我们注释掉这个错误的try-catch，直接展示裸奔代码的后果。\n}\n\n// 如果我们直接调用 parseUserData(badJson) 而不包裹它，程序会在这里崩溃。\n// 为了让整个示例能运行，我们用一个 catch 来模拟程序崩溃的效果。\ntry {\n    parseUserData(badJson);\n} catch(e) {\n    console.error(\"程序在解析时崩溃了！错误:\", e.message);\n    console.error(\"后面的所有代码都不会执行，这可能会导致应用白屏或功能中断。\");\n}\n\n\nconsole.log(\"\\n=== 正确用法 ✅ ===\");\nconst goodJson = '{\"name\": \"Charlie\", \"age\": 25}';\n\nfunction processDataSafely(jsonString) {\n    console.log(`正在尝试处理数据: ${jsonString}`);\n    try {\n        const user = parseUserData(jsonString);\n        console.log(\"✅ 数据解析成功! 用户:\", user.name);\n    } catch (error) {\n        console.error(\"❌ 数据解析失败! 但程序不会崩溃。\");\n        console.error(\"我们可以记录这个错误，并给用户一个友好的提示，比如 '数据加载失败，请稍后重试'。\");\n    }\n    console.log(\"...无论成功与否，处理流程继续...\");\n}\n\nprocessDataSafely(goodJson); // 处理正确的数据\nprocessDataSafely(badJson);  // 处理错误的数据\nconsole.log(\"程序优雅地处理了所有情况，并顺利执行到最后。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-3-1-try-catch-finally.md", "blockIndex": 3}
{"id": "js-sec-7-3-1", "title": "try-catch-finally", "code": "// 你的高科技外星信号翻译器\nfunction translateAlienSignal(signal) {\n  console.log(`\\n--- 接收到新信号: \"${signal}\" ---`);\n  \n  try {\n    console.log(\"启动量子解码器，尝试解析信号结构...\");\n    // 信号标准格式是JSON，我们尝试解析它\n    const data = JSON.parse(signal);\n    console.log(\"✅ 解码成功！正在分析内容...\");\n    \n    // 根据信号类型执行不同操作\n    if (data.type === 'greeting' && data.from) {\n      console.log(`👽 [友好消息] 来自 ${data.from} 星球: \"${data.message}\"`);\n    } else if (data.type === 'warning') {\n      console.log(`🚨 [紧急警报] 来源 ${data.from || '未知'}: \"${data.message}\"`);\n      console.log(\"    请舰长立刻注意！\");\n    } else {\n      // 捕获一个我们自己定义的“逻辑错误”\n      throw new Error(\"无法识别的信号协议！\");\n    }\n    \n  } catch (error) {\n    // 错误处理中心，根据不同错误类型做出反应\n    if (error instanceof SyntaxError) {\n      // JSON.parse 失败会抛出 SyntaxError\n      console.error(\"❌ 解码失败！信号可能已在传输中损坏，或只是宇宙背景噪音。\");\n      console.error(\"   技术日志:\", error.message);\n    } else {\n      // 其他所有错误（比如我们自己抛出的那个）\n      console.warn(`⚠️ 捕获到未知逻辑错误: ${error.message}`);\n      console.warn(\"   这可能是来自一个未知文明的新协议，已记录待分析。\");\n    }\n  } finally {\n    // 无论解码成功与否，都要关闭接收频道以节省能量\n    console.log(\"...通讯频道已关闭，等待下一段信号。\");\n  }\n}\n\n// 模拟一天中接收到的几段不同信号\nconst signal1 = '{\"type\": \"greeting\", \"from\": \"半人马座α星\", \"message\": \"我们带来了和平与知识。\"}';\nconst signal2 = '{\"type\": \"warning\", \"from\": \"猎户座悬臂\", \"message\": \"检测到伽马射线暴，立刻规避！\"}';\nconst signal3 = '滋...滋滋...宇宙...风暴...干扰...'; // 损坏的信号\nconst signal4 = '{\"type\": \"trade_offer\", \"item\": \"曲率引擎图纸\"}'; // 未知协议的信号\n\ntranslateAlienSignal(signal1);\ntranslateAlienSignal(signal2);\ntranslateAlienSignal(signal3);\ntranslateAlienSignal(signal4);", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-3-1-try-catch-finally.md", "blockIndex": 4}
{"id": "js-sec-7-3-2", "title": "Error对象", "code": "// 创建一个最基本的Error对象\nconst simpleError = new Error('网络连接超时！');\n\n// Error对象有两个主要属性：name 和 message\nconsole.log('错误类型 (name):', simpleError.name);\nconsole.log('错误信息 (message):', simpleError.message);\n\n// 你也可以直接打印整个对象，但通常message更有用\n// console.log(simpleError);", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-3-2-Error对象.md", "blockIndex": 0}
{"id": "js-sec-7-3-2", "title": "Error对象", "code": "function connectToDatabase() {\n  // 模拟一个错误\n  const dbError = new Error('数据库用户认证失败');\n  dbError.name = 'DatabaseAuthError'; // 可以自定义错误名称\n\n  console.log('错误名称:', dbError.name);\n  console.log('错误消息:', dbError.message);\n  \n  // .stack 属性是调试的利器，它显示了错误发生时的函数调用路径\n  // 注意：stack的内容和格式可能因不同的浏览器或Node.js环境而异\n  console.log('--- 调用堆栈信息 (stack) ---');\n  console.log(dbError.stack);\n}\n\nconnectToDatabase();", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-3-2-Error对象.md", "blockIndex": 1}
{"id": "js-sec-7-3-2", "title": "Error对象", "code": "function calculateArea(width, height) {\n  if (typeof width !== 'number' || typeof height !== 'number') {\n    // 当参数无效时，我们“抛出”一个Error对象，中断函数执行\n    throw new Error('宽度和高度必须是数字！');\n  }\n  if (width <= 0 || height <= 0) {\n    throw new Error('宽度和高度必须是正数！');\n  }\n  return width * height;\n}\n\ntry {\n  // 我们将可能出错的代码放入 try 块中\n  const area = calculateArea(10, -5);\n  console.log('计算出的面积是:', area);\n} catch (error) {\n  // 如果 try 块中抛出了错误，代码会立即跳转到 catch 块\n  console.error('🚫 发生了一个错误！');\n  console.error('错误详情:', error.message);\n} finally {\n  // finally 块中的代码无论是否发生错误都会执行\n  console.log('--- 计算结束 ---');\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-3-2-Error对象.md", "blockIndex": 2}
{"id": "js-sec-7-3-2", "title": "Error对象", "code": "console.log(\"=== 错误用法 ===\");\n// ❌ 直接抛出一个字符串\ntry {\n  const data = '{\"name\": \"Alice\"'; // 这是一个不完整的JSON字符串\n  JSON.parse(data);\n} catch (e) {\n  // 假设我们不知道JSON.parse会抛出Error对象，而是自己抛出一个字符串\n  throw \"解析用户数据失败\"; \n}\n// 注意：在现代JS环境中，上面的throw会直接导致程序崩溃并报错。\n// 为了演示捕获，我们把它包在另一个try...catch中。\ntry {\n  try { throw \"解析用户数据失败\"; } catch (e) { throw e; }\n} catch (e) {\n  console.log(\"捕获到的东西:\", e);\n  console.log(\"是Error对象吗?\", e instanceof Error);\n  console.log(\"有.message属性吗?\", e.message); // undefined\n  console.log(\"有.stack属性吗?\", e.stack);   // undefined\n  // 解释：直接抛出字符串，会丢失错误类型、堆栈等重要调试信息。\n  // 捕获到的'e'只是一个普通的字符串，而不是一个带有上下文信息的对象。\n}\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 抛出 new Error() 的实例\ntry {\n  const data = '{\"name\": \"Alice\"';\n  JSON.parse(data);\n} catch (e) {\n  // 将原始错误包装在一个新的、更具描述性的Error对象中\n  throw new Error(\"解析用户数据失败，请检查数据格式。\");\n}\n// 同样，为了演示捕获，我们把它包起来\ntry {\n  try { throw new Error(\"解析用户数据失败\"); } catch (e) { throw e; }\n} catch (e) {\n  console.log(\"捕获到的东西是一个对象\");\n  console.log(\"是Error对象吗?\", e instanceof Error);\n  console.log(\"有.message属性吗?\", e.message);\n  console.log(\"还有堆栈信息:\", e.stack ? '是的，内容很长' : '没有');\n  // 解释：抛出Error对象是标准做法。捕获到的'e'是一个真正的Error实例，\n  // 包含了name, message, stack等标准属性，这对于日志记录和调试至关重要。\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-3-2-Error对象.md", "blockIndex": 3}
{"id": "js-sec-7-3-2", "title": "Error对象", "code": "// --- 定义飞船专用的自定义错误类型 ---\n// 这让我们可以更精确地识别错误来源\nclass NavigationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'NavigationError';\n  }\n}\n\nclass InsufficientFuelError extends Error {\n  constructor(required, available) {\n    super(`燃料不足！需要 ${required} 单位，但只有 ${available} 单位。`);\n    this.name = 'InsufficientFuelError';\n    this.requiredFuel = required;\n    this.availableFuel = available;\n  }\n}\n\n// --- 飞船导航系统核心函数 ---\nfunction calculateJumpFuel(targetPlanet, currentFuel) {\n  console.log(`🛰️ 正在计算前往 '${targetPlanet}' 的航线...`);\n  const planetDistances = {\n    '火星': 50,\n    '木星': 200,\n    '半人马座α星': 1000,\n    '未知领域': Infinity\n  };\n\n  const requiredFuel = planetDistances[targetPlanet];\n\n  if (requiredFuel === undefined) {\n    throw new NavigationError(`错误：目标星球 '${targetPlanet}' 不在星图中！`);\n  }\n\n  if (requiredFuel > currentFuel) {\n    throw new InsufficientFuelError(requiredFuel, currentFuel);\n  }\n\n  return `✅ 计算完成！前往 ${targetPlanet} 需要 ${requiredFuel} 单位燃料。准备跳跃！`;\n}\n\n// --- 任务控制中心操作 ---\nfunction attemptJump(target, fuel) {\n  console.log(`\\n--- 尝试跳跃到: ${target}, 当前燃料: ${fuel} ---`);\n  try {\n    const result = calculateJumpFuel(target, fuel);\n    console.log(result);\n  } catch (error) {\n    // 根据错误类型，显示不同的警告信息\n    if (error instanceof NavigationError) {\n      console.error(`👨‍🚀 导航警告: ${error.message}`);\n    } else if (error instanceof InsufficientFuelError) {\n      console.error(`⛽️ 燃料警告: ${error.message}`);\n      console.error(`   我们还差 ${error.requiredFuel - error.availableFuel} 单位燃料才能到达！`);\n    } else {\n      console.error(`🚨 未知系统故障: ${error.message}`);\n    }\n  }\n}\n\n// 模拟几次太空跳跃\nattemptJump('火星', 100);       // 成功\nattemptJump('木星', 150);       // 燃料不足\nattemptJump('仙女座星系', 9999); // 目标不存在", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-3-2-Error对象.md", "blockIndex": 4}
{"id": "js-sec-7-3-3", "title": "自定义错误", "code": "// 定义一个自定义错误类\nclass MyCustomError extends Error {\n  constructor(message) {\n    super(message); // 调用父类 Error 的构造函数\n    this.name = \"MyCustomError\"; // 设置错误名称为类名\n  }\n}\n\ntry {\n  // 抛出一个我们自定义的错误实例\n  throw new MyCustomError(\"这是一个非常特殊的错误！\");\n} catch (error) {\n  console.log(`捕获到错误类型: ${error.name}`);\n  console.log(`错误信息: ${error.message}`);\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-3-3-自定义错误.md", "blockIndex": 0}
{"id": "js-sec-7-3-3", "title": "自定义错误", "code": "class ValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\nfunction validateUsername(username) {\n  if (username.length < 3) {\n    // 抛出自定义错误\n    throw new ValidationError(\"用户名长度不能小于3个字符。\");\n  }\n  return true;\n}\n\nfunction createUser(username) {\n    console.log(\"正在尝试创建用户...\");\n    validateUsername(username);\n    console.log(`用户 \"${username}\" 创建成功！`);\n}\n\ntry {\n  createUser(\"Li\"); // 使用一个不符合条件的用户名\n} catch (error) {\n  console.error(`错误名称: ${error.name}`);\n  console.error(`错误消息: ${error.message}`);\n  // 注意：error.stack 包含了从 createUser 到 validateUsername 的完整调用路径\n  console.error(\"错误堆栈信息:\");\n  console.error(error.stack);\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-3-3-自定义错误.md", "blockIndex": 1}
{"id": "js-sec-7-3-3", "title": "自定义错误", "code": "class ApiError extends Error {\n  constructor(message, errorCode, details) {\n    super(message);\n    this.name = 'ApiError';\n    this.errorCode = errorCode; // 自定义属性：错误码\n    this.details = details;     // 自定义属性：详细信息\n  }\n}\n\nfunction fetchData() {\n  // 模拟一个API请求失败的场景\n  const isSuccess = false;\n  if (!isSuccess) {\n    throw new ApiError(\n      \"无法从服务器获取用户信息\", \n      404, // 错误码\n      { userId: \"user-123\", reason: \"Not Found\" } // 详细信息\n    );\n  }\n}\n\ntry {\n  fetchData();\n} catch (error) {\n  // 检查是否是我们期望的 ApiError 类型\n  if (error instanceof ApiError) {\n    console.log(`捕获到API错误！`);\n    console.log(`消息: ${error.message}`);\n    console.log(`错误码: ${error.errorCode}`);\n    console.log(`详细信息:`, error.details);\n  } else {\n    console.log(\"捕获到未知错误:\", error);\n  }\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-3-3-自定义错误.md", "blockIndex": 2}
{"id": "js-sec-7-3-3", "title": "自定义错误", "code": "function performAction(shouldSucceed) {\n    if (!shouldSucceed) {\n        // 错误的做法是抛出一个字符串或普通对象\n        // throw \"操作失败了！\"; \n        throw { code: 500, msg: \"数据库连接中断\" };\n    }\n    return \"操作成功！\";\n}\n\nclass OperationError extends Error {\n    constructor(message, code) {\n        super(message);\n        this.name = \"OperationError\";\n        this.code = code;\n    }\n}\n\nfunction performCorrectAction(shouldSucceed) {\n    if (!shouldSucceed) {\n        // 正确的做法是抛出 Error 或其子类的实例\n        throw new OperationError(\"数据库连接中断\", 500);\n    }\n    return \"操作成功！\";\n}\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 展示常见错误\ntry {\n    performAction(false);\n} catch (e) {\n    console.error(\"捕获到的错误:\", e);\n    console.error(\"错误信息 (e.message):\", e.message); // undefined，因为普通对象没有 message 属性\n    console.error(\"堆栈信息 (e.stack):\", e.stack);   // undefined，丢失了宝贵的堆栈信息！\n    // 解释：直接抛出字符串或普通对象，会丢失标准错误对象的 name, message, stack 属性，\n    // 这使得调试变得极其困难，也无法进行基于类型的错误判断（如 instanceof）。\n}\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 展示正确做法\ntry {\n    performCorrectAction(false);\n} catch (e) {\n    console.error(\"捕获到的错误:\", e.name);\n    console.error(\"错误信息 (e.message):\", e.message); // \"数据库连接中断\"\n    console.error(\"自定义属性 (e.code):\", e.code);   // 500\n    console.error(\"堆栈信息可用 (e.stack):\", e.stack.includes(\"performCorrectAction\")); // true\n    // 解释：通过抛出 Error 子类的实例，我们保留了所有关键信息，\n    // 并且可以添加自定义数据，使得错误处理既健壮又灵活。\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-3-3-自定义错误.md", "blockIndex": 3}
{"id": "js-sec-7-3-3", "title": "自定义错误", "code": "// === 自定义错误类型定义 ===\n\n// 能源不足错误\nclass InsufficientEnergyError extends Error {\n  constructor(message, required, actual) {\n    super(message);\n    this.name = 'InsufficientEnergyError';\n    this.requiredEnergy = required;\n    this.actualEnergy = actual;\n  }\n}\n\n// 导航系统错误\nclass NavigationSystemError extends Error {\n  constructor(message, targetPlanet) {\n    super(message);\n    this.name = 'NavigationSystemError';\n    this.targetPlanet = targetPlanet;\n  }\n}\n\n// 外星生物干扰错误\nclass AlienInterferenceError extends Error {\n  constructor(message, alienRace) {\n    super(message);\n    this.name = 'AlienInterferenceError';\n    this.alienRace = alienRace;\n  }\n}\n\n// === 飞船系统函数 ===\n\nfunction engageWarpDrive(shipState) {\n  console.log(`🚀 舰长，正在尝试启动曲速引擎，目标：${shipState.targetPlanet}...`);\n\n  // 1. 检查能源\n  if (shipState.energyLevel < 100) {\n    throw new InsufficientEnergyError(\n      \"曲速核心能源不足！\",\n      100,\n      shipState.energyLevel\n    );\n  }\n  \n  // 2. 检查导航系统\n  if (!shipState.navSystemOnline) {\n    throw new NavigationSystemError(\n      \"导航计算机未上线，无法锁定目标！\",\n      shipState.targetPlanet\n    );\n  }\n\n  // 3. 检查外部环境 (随机事件)\n  if (Math.random() > 0.7) { // 30%的概率遇到外星人\n    throw new AlienInterferenceError(\n      \"警报！侦测到不明能量信号，曲速场被干扰！\",\n      \"博格人\"\n    );\n  }\n\n  console.log(`✅ 曲速引擎成功启动！正在跃迁至 ${shipState.targetPlanet}！`);\n}\n\n// === 模拟一次启动尝试 ===\n\n// 飞船当前状态\nconst explorerShipState = {\n  energyLevel: 95, // 故意设置一个不足的能源值\n  navSystemOnline: true,\n  targetPlanet: \"比邻星b\"\n};\n\ntry {\n  engageWarpDrive(explorerShipState);\n} catch (error) {\n  console.error(\"\\n--- 启动程序失败！---\");\n  // 根据不同的错误类型，执行不同的应对措施\n  if (error instanceof InsufficientEnergyError) {\n    console.error(`🔴 错误类型: ${error.name}`);\n    console.error(`💬 舰长日志: ${error.message}`);\n    console.error(`🔧 解决方案: 需要能量 ${error.requiredEnergy} 单位，当前仅剩 ${error.actualEnergy}。请立即为反应堆充能！`);\n  } else if (error instanceof NavigationSystemError) {\n    console.error(`🟡 错误类型: ${error.name}`);\n    console.error(`💬 舰长日志: ${error.message}`);\n    console.error(`🔧 解决方案: 工程师请立即重启导航系统，目标星球 ${error.targetPlanet} 的坐标需要重新校准。`);\n  } else if (error instanceof AlienInterferenceError) {\n    console.error(`🟣 错误类型: ${error.name}`);\n    console.error(`💬 舰长日志: ${error.message}`);\n    console.error(`⚔️ 紧急措施: 红色警报！升起护盾！可能是 ${error.alienRace} 的飞船！`);\n  } else {\n    // 处理其他未知错误\n    console.error(\"🚨 发生未知系统故障！\", error);\n  }\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-3-3-自定义错误.md", "blockIndex": 4}
{"id": "js-sec-7-3-4", "title": "异步错误处理", "code": "// 创建一个立即失败的 Promise 来模拟异步错误\nconst failedPromise = new Promise((resolve, reject) => {\n  // 模拟一个网络请求失败\n  setTimeout(() => {\n    reject(new Error(\"网络连接超时！\"));\n  }, 500);\n});\n\nconsole.log(\"启动异步操作...\");\n\nfailedPromise\n  .then(result => {\n    // 这部分代码不会执行，因为 Promise 失败了\n    console.log(\"成功:\", result);\n  })\n  .catch(error => {\n    // .catch() 捕获到了错误\n    console.error(\"捕获到错误:\", error.message);\n  });\n\n// 输出:\n// 启动异步操作...\n// (大约500毫秒后)\n// 捕获到错误: 网络连接超时！", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-3-4-异步错误处理.md", "blockIndex": 0}
{"id": "js-sec-7-3-4", "title": "异步错误处理", "code": "// 模拟一个可能失败的异步API调用\nfunction fetchUserData() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      // 随机决定成功或失败\n      if (Math.random() > 0.5) {\n        resolve({ id: 1, name: \"Alice\" });\n      } else {\n        reject(new Error(\"无法从服务器获取用户数据。\"));\n      }\n    }, 1000);\n  });\n}\n\n// 使用 async/await 和 try...catch 处理\nasync function displayUserData() {\n  console.log(\"正在尝试获取用户数据...\");\n  try {\n    const userData = await fetchUserData();\n    console.log(\"获取成功:\", userData);\n  } catch (error) {\n    console.error(\"在 displayUserData 中捕获到错误:\", error.message);\n  } finally {\n    console.log(\"数据获取流程结束。\");\n  }\n}\n\ndisplayUserData();\n\n// 可能的输出 1 (成功):\n// 正在尝试获取用户数据...\n// (1秒后)\n// 获取成功: { id: 1, name: 'Alice' }\n// 数据获取流程结束。\n\n// 可能的输出 2 (失败):\n// 正在尝试获取用户数据...\n// (1秒后)\n// 在 displayUserData 中捕获到错误: 无法从服务器获取用户数据。\n// 数据获取流程结束。", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-3-4-异步错误处理.md", "blockIndex": 1}
{"id": "js-sec-7-3-4", "title": "异步错误处理", "code": "const promiseSuccess = Promise.resolve(\"任务1成功\");\nconst promiseFailure = Promise.reject(new Error(\"任务2失败\"));\nconst promiseSuccess2 = Promise.resolve(\"任务3成功\");\n\nasync function runAllTasks() {\n  console.log(\"--- 使用 Promise.all ---\");\n  try {\n    const results = await Promise.all([promiseSuccess, promiseFailure, promiseSuccess2]);\n    console.log(\"所有任务都成功了:\", results); // 这行不会执行\n  } catch (error) {\n    console.error(\"Promise.all 捕获到错误:\", error.message);\n  }\n\n  console.log(\"\\n--- 使用 Promise.allSettled ---\");\n  const resultsSettled = await Promise.allSettled([promiseSuccess, promiseFailure, promiseSuccess2]);\n  console.log(\"Promise.allSettled 的结果:\");\n  resultsSettled.forEach(result => {\n    if (result.status === 'fulfilled') {\n      console.log(`  - 成功: ${result.value}`);\n    } else {\n      console.log(`  - 失败: ${result.reason.message}`);\n    }\n  });\n}\n\nrunAllTasks();\n\n// 输出:\n// --- 使用 Promise.all ---\n// Promise.all 捕获到错误: 任务2失败\n//\n// --- 使用 Promise.allSettled ---\n// Promise.allSettled 的结果:\n//   - 成功: 任务1成功\n//   - 失败: 任务2失败\n//   - 成功: 任务3成功", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-3-4-异步错误处理.md", "blockIndex": 2}
{"id": "js-sec-7-3-4", "title": "异步错误处理", "code": "function mightFail() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => reject(new Error(\"异步操作失败了！\")), 500);\n  });\n}\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误：try...catch 无法捕获到 mightFail() 内部的异步错误\n// 因为 mightFail() 立即返回一个 Promise 对象，并没有抛出同步错误。\n// 错误在未来的某个时间点（500ms后）才发生，早已跳出了 try...catch 块。\ntry {\n  mightFail(); \n  console.log(\"这个 Promise 已经启动，但错误还没发生。\");\n} catch (error) {\n  // 这段代码永远不会执行\n  console.error(\"错误用法捕获到了错误:\", error.message);\n}\n\n// 需要一个延迟来让程序等待异步错误发生，否则脚本可能在错误抛出前就结束了。\nsetTimeout(() => {\n  console.log(\"\\n=== 正确用法 ===\");\n  // ✅ 正确：使用 async/await，错误会被 try...catch 捕获\n  async function handleItRight() {\n    try {\n      await mightFail();\n    } catch (error) {\n      console.error(\"正确用法捕获到了错误:\", error.message);\n    }\n  }\n  handleItRight();\n}, 1000);\n\n// 输出:\n// === 错误用法 ===\n// 这个 Promise 已经启动，但错误还没发生。\n// (控制台可能会报告一个 UnhandledPromiseRejectionWarning)\n//\n// (1秒后)\n// === 正确用法 ===\n// 正确用法捕获到了错误: 异步操作失败了！", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-3-4-异步错误处理.md", "blockIndex": 3}
{"id": "js-sec-7-3-4", "title": "异步错误处理", "code": "// 模拟扫描一颗小行星，它可能成功也可能失败\nfunction scanAsteroid(name) {\n  console.log(`🛰️ 发送探测器前往小行星 ${name}...`);\n  return new Promise((resolve, reject) => {\n    const scanTime = Math.random() * 2000 + 500; // 随机扫描时间\n    setTimeout(() => {\n      const successChance = Math.random();\n      if (successChance > 0.4) {\n        const minerals = ['钛', '钻石', '超导矿石'][Math.floor(Math.random() * 3)];\n        resolve(`在 ${name} 发现大量 ${minerals}!`);\n      } else if (successChance > 0.2) {\n        reject(new Error(`来自 ${name} 的能量护盾干扰，扫描失败！`));\n      } else {\n        reject(new Error(`小行星带过于密集，无法接近 ${name}！`));\n      }\n    }, scanTime);\n  });\n}\n\n// 主控程序：启动星际探索任务\nasync function startExploration() {\n  console.log(\"🚀 舰长，星际矿物探测任务启动！\");\n  const asteroids = ['C-53', 'X-7', 'Z-99'];\n  const scanPromises = asteroids.map(name => scanAsteroid(name));\n\n  // 我们使用 Promise.allSettled，因为我们想知道每一颗小行星的扫描结果，\n  // 即使其中一些失败了也不想中断整个任务。\n  const results = await Promise.allSettled(scanPromises);\n\n  console.log(\"\\n--- 任务报告 ---\");\n  let successfulScans = 0;\n  \n  results.forEach((result, index) => {\n    const asteroidName = asteroids[index];\n    if (result.status === 'fulfilled') {\n      console.log(`✅ [${asteroidName}] 扫描成功: ${result.value}`);\n      successfulScans++;\n    } else {\n      console.error(`❌ [${asteroidName}] 扫描失败: ${result.reason.message}`);\n    }\n  });\n\n  console.log(\"\\n--- 任务总结 ---\");\n  if (successfulScans > 0) {\n    console.log(`🎉 任务部分成功！共在 ${successfulScans} 颗小行星上发现矿物。返航！`);\n  } else {\n    console.log(\"😭 所有扫描均失败。看来我们今天运气不佳，准备返航吧。\");\n  }\n}\n\nstartExploration();", "lang": "javascript", "source": "web-learner/public/content/js-sec-7-3-4-异步错误处理.md", "blockIndex": 4}
{"id": "js-sec-8-1-1", "title": "fetch基础", "code": "// 使用一个公开的API来获取一个待办事项\nconst apiUrl = 'https://jsonplaceholder.typicode.com/todos/1';\n\nfetch(apiUrl)\n  .then(response => response.json()) // 将响应体解析为JSON\n  .then(data => {\n    console.log(\"✅ 数据获取成功!\");\n    console.log(\"待办事项标题:\", data.title);\n    console.log(\"是否已完成:\", data.completed);\n  })\n  .catch(error => {\n    // 如果网络请求失败，会在这里捕获错误\n    console.error(\"❌ 请求失败:\", error);\n  });\n\nconsole.log(\"🚀 请求已发送，代码会继续执行，等待服务器响应...\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-1-fetch基础.md", "blockIndex": 0}
{"id": "js-sec-8-1-1", "title": "fetch基础", "code": "const apiUrl = 'https://jsonplaceholder.typicode.com/todos/1';\n\nconsole.log(\"1. 开始发起fetch请求\");\n\nconst promise = fetch(apiUrl);\nconsole.log(\"2. fetch函数已执行，返回了一个Promise:\", promise);\n\npromise.then(response => {\n  console.log(\"4. Promise解决了！收到了服务器的响应对象。\");\n  return response.json();\n}).then(data => {\n  console.log(\"5. JSON数据解析完成:\", data);\n});\n\nconsole.log(\"3. 主线程代码继续执行，不会等待网络响应。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-1-fetch基础.md", "blockIndex": 1}
{"id": "js-sec-8-1-1", "title": "fetch基础", "code": "const apiUrl = 'https://jsonplaceholder.typicode.com/todos/1';\n\nfetch(apiUrl)\n  .then(response => {\n    console.log(\"第一步：获取Response对象\");\n    console.log(\"响应状态码:\", response.status); // 比如 200\n    console.log(\"响应是否成功:\", response.ok);   // true (对于状态码 200-299)\n    \n    // 第二步：调用.json()方法，它也会返回一个Promise\n    console.log(\"准备解析响应体为JSON...\");\n    return response.json(); \n  })\n  .then(finalData => {\n    console.log(\"第二步完成：成功解析出最终的JSON数据\");\n    console.log(finalData);\n  })\n  .catch(error => {\n    console.error(\"请求过程中出现错误:\", error);\n  });", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-1-fetch基础.md", "blockIndex": 2}
{"id": "js-sec-8-1-1", "title": "fetch基础", "code": "const apiUrl = 'https://jsonplaceholder.typicode.com/todos/1';\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误：试图直接从第一个.then()中获取数据\nfetch(apiUrl)\n  .then(response => {\n    console.log(\"收到的响应:\", response);\n    // 这里的 response 是一个 Response 对象, 而不是我们想要的JSON数据\n    // response.title 是 undefined\n    console.log(\"错误的尝试:\", response.title); \n  })\n  .catch(error => console.error(error));\n// 解释：第一个 .then() 的回调函数接收的是一个 Response 对象，它包含了HTTP响应的元信息（如状态码、头部信息等），但响应体（body）需要通过异步方法（如 .json()）来读取。\n\n\nsetTimeout(() => {\n  console.log(\"\\n=========================\\n\");\n  console.log(\"=== 正确用法 ===\");\n  // ✅ 正确：使用链式调用，第二个.then()处理解析后的数据\n  fetch(apiUrl)\n    .then(response => {\n      // 第一步：检查响应是否成功，并返回解析body的Promise\n      if (!response.ok) {\n        throw new Error('网络响应不佳');\n      }\n      return response.json();\n    })\n    .then(data => {\n      // 第二步：在这里操作最终的JSON数据\n      console.log(\"正确的做法:\", data.title);\n    })\n    .catch(error => {\n      console.error(\"处理请求时发生错误:\", error);\n    });\n  // 解释：这是一个两步过程。第一个 .then() 处理HTTP响应本身，并启动内容解析。第二个 .then() 等待解析完成并接收最终的数据。\n}, 1000); // 使用setTimeout确保两个示例的输出分开", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-1-fetch基础.md", "blockIndex": 3}
{"id": "js-sec-8-1-1", "title": "fetch基础", "code": "// 飞船的AI翻译模块\nasync function translateAlienMessage(alienText) {\n  console.log(`👽 接收到外星信息: \"${alienText}\"`);\n  console.log(\"🛰️ 连接到莎士比亚翻译星际网络...\");\n\n  // 使用一个公开的翻译API\n  const apiUrl = `https://api.funtranslations.com/translate/shakespeare.json?text=${encodeURIComponent(alienText)}`;\n\n  try {\n    // 第一步：发送请求\n    const response = await fetch(apiUrl);\n\n    // 检查AI是否能成功连接到网络\n    if (!response.ok) {\n      // API有请求频率限制，如果失败，我们模拟一个有趣的错误信息\n      throw new Error(`信号干扰！翻译网络返回错误码: ${response.status}`);\n    }\n\n    // 第二步：解析返回的翻译数据\n    const translationData = await response.json();\n\n    // 有时API会返回错误信息，即使状态码是200\n    if (translationData.error) {\n        console.error(\"🤖 AI翻译核心错误:\", translationData.error.message);\n        console.log(\"看来这个API今天有点'闹脾气'，我们稍后再试。\");\n        return;\n    }\n\n    const translatedText = translationData.contents.translated;\n\n    console.log(\"✅ 翻译成功!\");\n    console.log(\"📜 莎士比亚风格译文:\", `\"${translatedText}\"`);\n    console.log(\"\\n----------------------------------\\n\");\n\n  } catch (error) {\n    console.error(\"💥 糟糕！与翻译网络的连接丢失了！\", error.message);\n    console.log(\"可能是太阳耀斑影响了通讯，也可能是我忘了续费API服务... 🤔\");\n  }\n}\n\n// 让我们来翻译几句从石碑上抄下来的外星语\ntranslateAlienMessage(\"Hello, how are you?\");\n// 注意：这个API有每小时5次的调用限制，如果短时间内多次运行，可能会看到错误信息。\n// 这也正好演示了错误处理的重要性！", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-1-fetch基础.md", "blockIndex": 4}
{"id": "js-sec-8-1-2", "title": "请求配置", "code": "// 场景：预测一个名字的可能年龄\nconst nameToPredict = 'alice';\nconst apiUrl = `https://api.agify.io?name=${nameToPredict}`;\n\n// 写法1: 不带配置对象（默认GET）\nfetch(apiUrl)\n  .then(response => response.json())\n  .then(data => {\n    console.log(`[默认GET] 预测 '${nameToPredict}' 的年龄是:`, data.age);\n  });\n\n// 写法2: 明确使用配置对象指定GET方法\nfetch(apiUrl, { method: 'GET' })\n  .then(response => response.json())\n  .then(data => {\n    console.log(`[配置GET] 预测 '${nameToPredict}' 的年龄是:`, data.age);\n  });\n// 输出：\n// [默认GET] 预测 'alice' 的年龄是: 32\n// [配置GET] 预测 'alice' 的年龄是: 32", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-2-请求配置.md", "blockIndex": 0}
{"id": "js-sec-8-1-2", "title": "请求配置", "code": "// 使用一个能回显请求信息的公开服务(httpbin.org)来演示\nasync function postDataExample() {\n  const userData = {\n    username: 'AstroExplorer',\n    level: 12,\n    mission: 'Collect star dust'\n  };\n\n  const response = await fetch('https://httpbin.org/post', {\n    method: 'POST', // 明确指定方法为 POST\n    // body 需要是字符串。通常我们将JS对象转为JSON字符串\n    body: JSON.stringify(userData) \n  });\n\n  const result = await response.json();\n  \n  console.log('服务器收到的数据是:');\n  // result.data 是服务器解析后收到的原始body字符串\n  console.log(result.data); \n  \n  console.log('服务器解析后的JSON对象是:');\n  // result.json 是服务器将收到的JSON字符串转回对象后的结果\n  console.log(result.json);\n}\n\npostDataExample();\n// 输出：\n// 服务器收到的数据是:\n// {\"username\":\"AstroExplorer\",\"level\":12,\"mission\":\"Collect star dust\"}\n// 服务器解析后的JSON对象是:\n// { username: 'AstroExplorer', level: 12, mission: 'Collect star dust' }", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-2-请求配置.md", "blockIndex": 1}
{"id": "js-sec-8-1-2", "title": "请求配置", "code": "// 使用 httpbin.org/headers 来查看服务器收到的请求头\nasync function headersExample() {\n  const customHeaders = {\n    // 告诉服务器，我们发送的body内容是JSON格式\n    'Content-Type': 'application/json',\n    // 附加一个自定义的请求头，比如API密钥或认证令牌\n    'Authorization': 'Bearer my-secret-token-12345',\n    'X-Client-Version': '1.0.5'\n  };\n\n  const response = await fetch('https://httpbin.org/headers', {\n    method: 'GET', // headers可以用于任何类型的请求\n    headers: customHeaders\n  });\n\n  const result = await response.json();\n\n  console.log('服务器确认收到的请求头信息:');\n  console.log('Authorization:', result.headers.Authorization);\n  console.log('Content-Type:', result.headers['Content-Type']);\n  console.log('X-Client-Version:', result.headers['X-Client-Version']);\n}\n\nheadersExample();\n// 输出：\n// 服务器确认收到的请求头信息:\n// Authorization: Bearer my-secret-token-12345\n// Content-Type: application/json\n// X-Client-Version: 1.0.5", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-2-请求配置.md", "blockIndex": 2}
{"id": "js-sec-8-1-2", "title": "请求配置", "code": "// 场景：向服务器注册一个新用户\nasync function userRegistration() {\n  const newUser = { name: 'eva', role: 'pilot' };\n  const apiUrl = 'https://httpbin.org/post';\n\n  console.log(\"=== 错误用法 ===\");\n  // ❌ 错误: 直接将JS对象作为body，并且没有设置Content-Type\n  // 浏览器会尝试将对象转换为字符串\"[object Object]\"，服务器无法正确解析。\n  try {\n    const badResponse = await fetch(apiUrl, {\n      method: 'POST',\n      body: newUser \n    });\n    const badResult = await badResponse.json();\n    console.log('服务器收到的错误数据:', badResult.data);\n  } catch (error) {\n    console.error('请求失败:', error);\n  }\n\n  console.log(\"\\n=== 正确用法 ===\");\n  // ✅ 正确: 使用JSON.stringify转换对象，并设置正确的请求头\n  const goodResponse = await fetch(apiUrl, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(newUser)\n  });\n  const goodResult = await goodResponse.json();\n  console.log('服务器收到的正确数据:', goodResult.data);\n  console.log('服务器解析后的JSON:', goodResult.json);\n}\n\nuserRegistration();\n// 输出：\n// === 错误用法 ===\n// 服务器收到的错误数据: [object Object]\n//\n// === 正确用法 ===\n// 服务器收到的正确数据: {\"name\":\"eva\",\"role\":\"pilot\"}\n// 服务器解析后的JSON: { name: 'eva', role: 'pilot' }", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-2-请求配置.md", "blockIndex": 3}
{"id": "js-sec-8-1-2", "title": "请求配置", "code": "// 模拟我们的高科技翻译服务器 (使用httpbin.org)\nconst translationServer = {\n  quick: (word) => `https://httpbin.org/get?word=${word}`,\n  deep: 'https://httpbin.org/post'\n};\n\n// 我们的翻译器主函数\nasync function translateGlonk(text, context = null) {\n  console.log(`--- 正在翻译: \"${text}\" ---`);\n\n  if (!context) {\n    // 模式1: 快速翻译 (GET)\n    console.log(\"模式: 快速翻译 (GET)\");\n    const response = await fetch(translationServer.quick(text));\n    const result = await response.json();\n    console.log(`[翻译结果]: 服务器收到了词汇 '${result.args.word}'。初步翻译: '问候' 或 '危险'？`);\n  } else {\n    // 模式2: 深度分析 (POST)\n    console.log(\"模式: 深度分析 (POST)\");\n    const requestPayload = {\n      sentence: text,\n      enviromental_context: context\n    };\n    \n    const response = await fetch(translationServer.deep, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Translator-Model': 'Glonk-v3.5-alpha'\n      },\n      body: JSON.stringify(requestPayload)\n    });\n    const result = await response.json();\n    console.log(`[翻译结果]: 服务器收到深度分析请求。`);\n    console.log(`   - 句子: ${result.json.sentence}`);\n    console.log(`   - 环境: 大气成分 ${result.json.enviromental_context.atmosphere}, 重力 ${result.json.enviromental_context.gravity}G`);\n    console.log(`   - 分析结论: 这句话表达了对当前'${result.json.enviromental_context.atmosphere}'大气的赞美！`);\n  }\n  console.log(\"--- 翻译结束 ---\\n\");\n}\n\n// 开始我们的冒险！\nasync function startAdventure() {\n  // 遇到一个简单的词汇\n  await translateGlonk(\"Zorp!\");\n\n  // 遇到一句复杂的句子，同时扫描环境数据\n  const enviromentData = {\n    atmosphere: 'Methane-rich',\n    gravity: 1.7\n  };\n  await translateGlonk(\"Glarth Voo Snizzle\", enviromentData);\n}\n\nstartAdventure();", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-2-请求配置.md", "blockIndex": 4}
{"id": "js-sec-8-1-3", "title": "响应处理", "code": "// 使用一个公共的API来获取一个帖子的信息\nfetch('https://jsonplaceholder.typicode.com/posts/1')\n  .then(response => {\n    // 我们得到的'response'是一个Response对象，而不是直接的数据\n    console.log(\"收到的包裹（Response对象）:\", response);\n    // 这个对象有很多属性，比如status表示HTTP状态码\n    console.log(\"包裹状态（status）:\", response.status); // 200表示成功\n  });", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-3-响应处理.md", "blockIndex": 0}
{"id": "js-sec-8-1-3", "title": "响应处理", "code": "// 使用公共API获取用户信息\nfetch('https://jsonplaceholder.typicode.com/users/1')\n  .then(response => {\n    console.log(\"收到响应，准备解析JSON数据...\");\n    // .json()方法返回一个Promise，解析完成后会得到真正的JavaScript对象\n    return response.json(); \n  })\n  .then(userData => {\n    // 这里我们才真正拿到了数据\n    console.log(\"成功解析出用户数据:\", userData);\n    console.log(`用户名: ${userData.name}, 邮箱: ${userData.email}`);\n  })\n  .catch(error => console.error(\"处理过程中发生错误:\", error));", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-3-响应处理.md", "blockIndex": 1}
{"id": "js-sec-8-1-3", "title": "响应处理", "code": "// 故意请求一个不存在的资源，来触发404错误\nfetch('https://jsonplaceholder.typicode.com/posts/99999999')\n  .then(response => {\n    console.log(\"收到响应!\");\n    console.log(\"请求是否成功 (response.ok):\", response.ok); // false\n    console.log(\"HTTP状态码 (response.status):\", response.status); // 404\n\n    // 如果请求不成功，我们应该处理这个错误\n    if (!response.ok) {\n      // 抛出一个错误，这样就会被下面的.catch捕获\n      throw new Error(`网络错误! 状态码: ${response.status}`);\n    }\n    return response.json();\n  })\n  .then(data => {\n    // 因为上面抛出了错误，所以这一步不会执行\n    console.log(\"成功获取数据:\", data);\n  })\n  .catch(error => {\n    // .catch会捕获到我们手动抛出的错误\n    console.error(\"捕获到错误:\", error.message);\n  });", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-3-响应处理.md", "blockIndex": 2}
{"id": "js-sec-8-1-3", "title": "响应处理", "code": "// 模拟一个返回JSON的fetch请求\nfunction mockFetch(url) {\n    return Promise.resolve(new Response(JSON.stringify({ message: \"你好，宇宙！\" }), {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' }\n    }));\n}\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误：直接访问 response.body 或者将整个 response 对象当作数据\nmockFetch('/api/greeting')\n  .then(response => {\n    console.log(\"试图直接使用response对象:\", response);\n    // response.body 是一个 ReadableStream，而不是我们想要的JSON数据\n    console.log(\"直接访问response.body:\", response.body); \n    // 下一步会得到 undefined 或者报错，因为没有正确解析和传递数据\n    return response; \n  })\n  .then(data => {\n    // 这里的 data 仍然是 Response 对象，而不是解析后的JSON\n    console.log(\"错误地认为data是JSON:\", data.message); // 输出 undefined\n  });\n\nsetTimeout(() => {\n    console.log(\"\\n=== 正确用法 ===\");\n    // ✅ 正确：使用 .json() 方法解析响应体，并链接Promise\n    mockFetch('/api/greeting')\n      .then(response => {\n        // 首先检查响应是否成功\n        if (!response.ok) {\n          throw new Error('网络响应不佳');\n        }\n        // 调用 .json() 返回一个解析JSON的Promise\n        return response.json();\n      })\n      .then(data => {\n        // 在这个 .then() 中，data 才是我们需要的JavaScript对象\n        console.log(\"成功解析JSON数据:\", data);\n        console.log(\"收到的消息:\", data.message); // 输出 \"你好，宇宙！\"\n      })\n      .catch(error => console.error(error));\n}, 100); // 使用setTimeout确保输出顺序清晰", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-3-响应处理.md", "blockIndex": 3}
{"id": "js-sec-8-1-3", "title": "响应处理", "code": "// 模拟一个星际通用翻译数据库的API\nfunction fetchAlienDictionary(word) {\n  console.log(`[发送请求] 正在查询外星词语 '${word}'...`);\n  const dictionary = {\n    'Grok': '深刻理解',\n    'Zorp': '攻击',\n    'Flibbertigibbet': '一个喋喋不休的人',\n    'Klaatu': '和平',\n    'Barada': '警告',\n    'Nikto': '中立'\n  };\n\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      if (dictionary[word]) {\n        const responseBody = JSON.stringify({ word: word, translation: dictionary[word] });\n        const response = new Response(responseBody, {\n          status: 200,\n          headers: { 'Content-Type': 'application/json' }\n        });\n        resolve(response);\n      } else {\n        const response = new Response(JSON.stringify({ error: \"词语未找到\" }), {\n          status: 404,\n          headers: { 'Content-Type': 'application/json' }\n        });\n        resolve(response);\n      }\n    }, 500 + Math.random() * 500); // 模拟网络延迟\n  });\n}\n\n// 主翻译程序\nasync function translateAlienMessage(message) {\n  console.log(`--- 开始翻译任务: \"${message}\" ---`);\n  const words = message.split(' ');\n  let translatedMessage = '';\n\n  for (const word of words) {\n    try {\n      // 1. 发起请求\n      const response = await fetchAlienDictionary(word);\n\n      // 2. 检查响应状态\n      console.log(`[收到响应] 词语'${word}'查询状态: ${response.status}`);\n      if (!response.ok) {\n        // 如果查询失败，直接使用原始词语并加上标记\n        translatedMessage += `[无法翻译:${word}] `;\n        continue; // 继续处理下一个词语\n      }\n\n      // 3. 解析响应体\n      const data = await response.json();\n      translatedMessage += data.translation + ' ';\n\n    } catch (error) {\n      console.error(`翻译'${word}'时发生意外错误:`, error);\n      translatedMessage += `[错误] `;\n    }\n  }\n\n  console.log(`\\n--- 翻译完成 ---`);\n  console.log(`👽 外星原文: ${message}`);\n  console.log(`🌍 地球译文: ${translatedMessage.trim()}`);\n}\n\n// 执行翻译任务\ntranslateAlienMessage('Klaatu Barada Nikto Zorp');", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-3-响应处理.md", "blockIndex": 4}
{"id": "js-sec-8-1-4", "title": "错误处理", "code": "// 尝试解析一个格式错误的JSON字符串\ntry {\n  console.log(\"尝试解析JSON...\");\n  const invalidJson = '{\"name\": \"Alice\", \"age\": 30,}'; // 注意末尾多余的逗号，这是无效的JSON\n  const user = JSON.parse(invalidJson);\n  console.log(\"解析成功:\", user); // 这行代码不会被执行\n} catch (error) {\n  // 如果try块中发生错误，代码会跳转到这里\n  console.error(\"捕获到错误！程序不会崩溃。\");\n  console.error(\"错误详情:\", error.message);\n}\n\nconsole.log(\"即使发生了错误，程序依然可以继续执行到这里。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-4-错误处理.md", "blockIndex": 0}
{"id": "js-sec-8-1-4", "title": "错误处理", "code": "function connectToDatabase(status) {\n  console.log(\"正在尝试连接数据库...\");\n  if (status === 'fail') {\n    throw new Error(\"数据库连接失败！\");\n  }\n  console.log(\"数据库连接成功！\");\n}\n\n// 场景一：连接成功\ntry {\n  connectToDatabase('success');\n  console.log(\"数据操作完成。\");\n} catch (error) {\n  console.error(\"捕获到错误:\", error.message);\n} finally {\n  console.log(\"--- 无论成功与否，关闭数据库连接。---\\n\");\n}\n\n\n// 场景二：连接失败\ntry {\n  connectToDatabase('fail');\n  console.log(\"这行不会被执行...\");\n} catch (error) {\n  console.error(\"捕获到错误:\", error.message);\n} finally {\n  // 即使发生错误，finally块依然会执行\n  console.log(\"--- 无论成功与否，关闭数据库连接。---\");\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-4-错误处理.md", "blockIndex": 1}
{"id": "js-sec-8-1-4", "title": "错误处理", "code": "function calculateCircleArea(radius) {\n  if (typeof radius !== 'number' || radius < 0) {\n    // 如果半径不是一个正数，就抛出一个自定义错误\n    throw new Error(\"无效的半径值！半径必须是一个非负数。\");\n  }\n  return Math.PI * radius * radius;\n}\n\ntry {\n  // 尝试使用无效参数调用函数\n  console.log(\"尝试计算面积，使用半径: -5\");\n  const area = calculateCircleArea(-5);\n  console.log(\"计算的面积是:\", area);\n} catch (error) {\n  console.error(\"计算失败，原因:\", error.message);\n}\n\ntry {\n  // 尝试使用有效参数调用函数\n  console.log(\"\\n尝试计算面积，使用半径: 10\");\n  const area = calculateCircleArea(10);\n  console.log(\"计算的面积是:\", area.toFixed(2));\n} catch (error) {\n  console.error(\"计算失败，原因:\", error.message);\n}", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-4-错误处理.md", "blockIndex": 2}
{"id": "js-sec-8-1-4", "title": "错误处理", "code": "// 假设这是一个从服务器获取用户数据的函数，但可能失败\nfunction fetchUserData(userId) {\n  if (userId <= 0) {\n    throw new Error(\"用户ID必须是正数！\");\n  }\n  // 模拟成功获取数据\n  return { id: userId, name: \"CaptainCode\" };\n}\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 直接调用，不处理潜在的错误\n// 下面的调用会抛出错误，导致程序崩溃，\"程序结束\" 这句话永远不会被打印出来。\ntry {\n    console.log(\"正在获取用户 -1 的数据...\");\n    const user = fetchUserData(-1); \n    console.log(\"用户信息:\", user);\n} catch (e) {\n    console.error(\"由于未捕获的错误，脚本在这里就停止了！\");\n    console.error(e.message);\n}\n// console.log(\"程序结束\"); // 如果没有try...catch，这行不会执行\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 使用 try...catch 优雅地处理错误\ntry {\n  console.log(\"正在获取用户 -1 的数据...\");\n  const user = fetchUserData(-1);\n  console.log(\"用户信息:\", user);\n} catch (error) {\n  console.error(\"获取用户数据失败，但程序可以继续运行。\");\n  console.error(\"失败原因:\", error.message);\n  console.log(\"可以执行备用逻辑，比如显示默认用户信息。\");\n}\nconsole.log(\"程序优雅地处理了错误，并继续执行到了末尾。\");\n", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-4-错误处理.md", "blockIndex": 3}
{"id": "js-sec-8-1-4", "title": "错误处理", "code": "// 定义一些自定义的错误类型，让问题更明确\nclass InvalidCoordinatesError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"InvalidCoordinatesError\";\n  }\n}\n\nclass InsufficientEnergyError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"InsufficientEnergyError\";\n  }\n}\n\n// 跃迁引擎函数\nfunction activateWarpDrive(destination, energyLevel) {\n  console.log(`\\n🚀 舰长，收到指令！目标：${destination}，当前能量：${energyLevel}%`);\n  \n  if (!destination || typeof destination !== 'string') {\n    throw new InvalidCoordinatesError(\"跃迁坐标无效！导航系统无法锁定目标。\");\n  }\n  \n  if (energyLevel < 80) {\n    throw new InsufficientEnergyError(`能量严重不足！跃迁需要至少80%，当前仅有${energyLevel}%。`);\n  }\n  \n  // 如果一切正常\n  return `✅ 跃迁引擎启动成功！正在前往 ${destination} 星系... 祝您旅途愉快！`;\n}\n\n// --- 任务开始 ---\n\n// 尝试1: 忘记输入坐标\ntry {\n  const result = activateWarpDrive(null, 95);\n  console.log(result);\n} catch (error) {\n  console.error(`🚨 警报! ${error.name}: ${error.message}`);\n  console.log(\"导航官：舰长，请提供明确的跃迁目标！\");\n}\n\n// 尝试2: 能量不足\ntry {\n  const result = activateWarpDrive(\"仙女座星系\", 50);\n  console.log(result);\n} catch (error) {\n  console.error(`🚨 警报! ${error.name}: ${error.message}`);\n  console.log(\"轮机长：舰长，我们需要更多时间为引擎充能！\");\n}\n\n// 尝试3: 一切顺利！\ntry {\n  const result = activateWarpDrive(\"创作者星云\", 100);\n  console.log(result);\n} catch (error) {\n  console.error(`🚨 警报! ${error.name}: ${error.message}`);\n  console.log(\"系统日志：出现未知跃迁故障。\");\n}\n", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-4-错误处理.md", "blockIndex": 4}
{"id": "js-sec-8-1-5", "title": "请求拦截", "code": "// 模拟一个网络请求函数\nfunction fakeApiCall(url, options) {\n  console.log(`[API] 正在向 ${url} 发送请求...`);\n  return Promise.resolve({ success: true, data: `来自 ${url} 的数据` });\n}\n\n// 创建一个带有请求拦截功能的 fetch 包装器\nfunction createFetchWithInterceptor(apiCall) {\n  const interceptor = (url, options) => {\n    // 这是我们的拦截器：在请求发送前，打印日志\n    console.log(`[拦截器] 准备发送请求到: ${url}`);\n    // 拦截器处理完后，调用原始的 API 函数\n    return apiCall(url, options);\n  };\n  return interceptor;\n}\n\nconst myFetch = createFetchWithInterceptor(fakeApiCall);\n\n// 使用我们带有拦截功能的 fetch\nmyFetch('https://api.example.com/data', { method: 'GET' })\n  .then(response => {\n    console.log('[客户端] 收到响应:', response);\n  });", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-5-请求拦截.md", "blockIndex": 0}
{"id": "js-sec-8-1-5", "title": "请求拦截", "code": "// 模拟一个需要认证的 API\nasync function fakeSecureApiCall(url, options) {\n  console.log(`[API] 正在向 ${url} 发送请求，配置为:`, options);\n  if (options.headers && options.headers['Authorization'] === 'Bearer secret-token') {\n    return { status: 200, data: '机密数据获取成功！' };\n  } else {\n    return { status: 401, error: '未授权访问' };\n  }\n}\n\n// 创建一个可以修改请求的拦截器系统\nclass ApiClient {\n  constructor() {\n    this.requestInterceptor = null;\n  }\n\n  // 设置请求拦截器\n  useRequestInterceptor(interceptor) {\n    this.requestInterceptor = interceptor;\n  }\n\n  async fetch(url, options = {}) {\n    let modifiedOptions = options;\n    if (this.requestInterceptor) {\n      // 如果有拦截器，用它来处理（可能修改）配置\n      console.log('[系统] 请求已进入拦截器...');\n      modifiedOptions = this.requestInterceptor(modifiedOptions);\n    }\n    return fakeSecureApiCall(url, modifiedOptions);\n  }\n}\n\nconst client = new ApiClient();\n\n// 定义一个拦截器，为所有请求添加 Authorization 头\nclient.useRequestInterceptor((options) => {\n  const token = 'secret-token';\n  const modifiedOptions = {\n    ...options,\n    headers: {\n      ...options.headers,\n      'Authorization': `Bearer ${token}`\n    }\n  };\n  console.log('[拦截器] 已自动添加认证Token！');\n  return modifiedOptions; // 必须返回修改后的配置\n});\n\n// 发起请求，无需手动添加 Token\nclient.fetch('https://api.secret.com/user')\n  .then(response => console.log('[客户端] 响应:', response));", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-5-请求拦截.md", "blockIndex": 1}
{"id": "js-sec-8-1-5", "title": "请求拦截", "code": "// 模拟一个可能成功也可能失败的 API\nasync function fakeApiCall(url) {\n  console.log(`[API] 正在向 ${url} 发送请求...`);\n  // 模拟一个会话过期的场景\n  if (url.includes('expired')) {\n    return { status: 401, error: '会话已过期，请重新登录' };\n  }\n  return { status: 200, data: '用户个人资料' };\n}\n\n// 创建一个同时支持请求和响应拦截的系统\nclass ApiClient {\n  constructor() {\n    this.responseInterceptor = null;\n  }\n\n  useResponseInterceptor(interceptor) {\n    this.responseInterceptor = interceptor;\n  }\n\n  async fetch(url, options = {}) {\n    let response = await fakeApiCall(url, options);\n    \n    if (this.responseInterceptor) {\n      console.log('[系统] 响应已进入拦截器...');\n      // 响应拦截器可以处理或转换响应\n      response = this.responseInterceptor(response);\n    }\n    return response;\n  }\n}\n\nconst client = new ApiClient();\n\n// 定义一个响应拦截器，专门处理 401 错误\nclient.useResponseInterceptor((response) => {\n  if (response.status === 401) {\n    console.error('[拦截器] 检测到未授权(401)！正在模拟跳转到登录页...');\n    // 在真实应用中，这里会执行 window.location.href = '/login'\n    // 这里我们返回一个更友好的错误信息\n    return { status: 'processed_error', message: '请登录后再试' };\n  }\n  // 如果不是 401，原样返回响应\n  return response;\n});\n\n// 场景1: 请求一个会过期的资源\nclient.fetch('https://api.example.com/profile?session=expired')\n  .then(result => console.log('[客户端] 收到处理后的结果:', result));\n\n// 场景2: 请求一个正常的资源\nclient.fetch('https://api.example.com/profile?session=valid')\n  .then(result => console.log('\\n[客户端] 收到正常结果:', result));", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-5-请求拦截.md", "blockIndex": 2}
{"id": "js-sec-8-1-5", "title": "请求拦截", "code": "// 模拟 API 调用\nasync function apiCall(url, options) {\n  if (!options) {\n    throw new Error(\"[API] 错误：请求配置 (options) 未定义！\");\n  }\n  console.log(\"[API] 收到请求配置:\", options);\n  return { success: true };\n}\n\n// 带有拦截器的客户端\nclass ApiClient {\n  constructor() {\n    this.requestInterceptor = null;\n  }\n  use(interceptor) {\n    this.requestInterceptor = interceptor;\n  }\n  async fetch(url, options = {}) {\n    let processedOptions = options;\n    if (this.requestInterceptor) {\n      processedOptions = this.requestInterceptor(options);\n    }\n    // 如果 processedOptions 是 undefined，这里会报错\n    return apiCall(url, processedOptions);\n  }\n}\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 拦截器没有返回任何东西 (隐式返回 undefined)\nconst badClient = new ApiClient();\nbadClient.use((options) => {\n  console.log(\"[错误拦截器] 正在处理请求...\");\n  options.headers = { 'X-Powered-By': 'Magic' };\n  // 忘记 return options;\n});\n\nbadClient.fetch('https://example.com/data', {})\n  .catch(error => console.error(error.message));\n// 解释: 这个拦截器修改了 options 对象，但没有返回它。\n// ApiClient 的 fetch 方法接收到的 `processedOptions` 将是 `undefined`，\n// 导致传递给 `apiCall` 的是 `undefined`，从而引发错误。\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 拦截器总是返回处理后的配置对象\nconst goodClient = new ApiClient();\ngoodClient.use((options) => {\n  console.log(\"[正确拦截器] 正在处理请求...\");\n  const newOptions = { ...options, headers: { 'X-Powered-By': 'JavaScript' } };\n  return newOptions; // 必须返回配置对象\n});\n\ngoodClient.fetch('https://example.com/data', {})\n  .then(response => console.log(\"[客户端] 成功!\", response))\n  .catch(error => console.error(error.message));\n// 解释: 正确的拦截器接收配置，进行修改，然后返回修改后的新配置对象。\n// 这确保了数据流的连续性，`apiCall` 能接收到有效的配置。", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-5-请求拦截.md", "blockIndex": 3}
{"id": "js-sec-8-1-5", "title": "请求拦截", "code": "// 模拟一个星际通讯网络\nasync function sendIntergalacticMessage(planet, message) {\n  console.log(`[网络层] 正在向 ${planet} 传输消息...`);\n  console.log(`[网络层] 传输内容:`, message);\n\n  if (!message.headers || message.headers['X-Encryption-Protocol'] !== 'AES-256') {\n    return { status: 'failed', reason: '传输失败：未加密的信道！' };\n  }\n  if (planet === 'Zorg-Prime' && !message.body.includes('glorp')) {\n     return { status: 'failed', reason: '传输失败：Zorg人无法理解该消息！' };\n  }\n  \n  return { status: 'ok', confirmation: `消息已成功抵达 ${planet}` };\n}\n\n// 我们的星际通讯系统\nclass GalacticComms {\n  constructor() {\n    this.requestInterceptors = [];\n  }\n\n  // 添加一个拦截器\n  addInterceptor(interceptor) {\n    this.requestInterceptors.push(interceptor);\n  }\n\n  // 发送消息\n  async sendMessage(planet, text) {\n    console.log(`\\n--- 准备向 ${planet} 发送新消息 ---`);\n    let message = {\n      body: text,\n      headers: {}\n    };\n\n    // 依次通过所有拦截器\n    for (const interceptor of this.requestInterceptors) {\n      message = interceptor(planet, message);\n    }\n\n    return sendIntergalacticMessage(planet, message);\n  }\n}\n\n// 创建通讯系统实例\nconst comms = new GalacticComms();\n\n// 1. 安装“加密协议”拦截器\ncomms.addInterceptor((planet, message) => {\n  console.log('[拦截器 1 - 加密] 正在为消息添加 AES-256 加密协议...');\n  const encryptedMessage = {\n    ...message,\n    headers: {\n      ...message.headers,\n      'X-Encryption-Protocol': 'AES-256'\n    }\n  };\n  return encryptedMessage;\n});\n\n// 2. 安装“通用翻译器”拦截器\ncomms.addInterceptor((planet, message) => {\n  if (planet === 'Zorg-Prime') {\n    console.log('[拦截器 2 - 翻译] 检测到目标是Zorg-Prime，启动通用翻译器...');\n    const translatedBody = message.body.replace('Hello', 'Glorp Zorp');\n    return { ...message, body: translatedBody };\n  }\n  // 如果不是发往Zorg-Prime，则不作任何翻译\n  console.log('[拦截器 2 - 翻译] 非Zorg目标，无需翻译。');\n  return message;\n});\n\n// 使用通讯系统发送消息\nasync function runMissions() {\n  // 任务1: 向火星发送问候 (无需翻译)\n  const marsResponse = await comms.sendMessage('Mars', 'Hello, Mars!');\n  console.log('[舰长日志] 火星任务结果:', marsResponse);\n\n  // 任务2: 向Zorg-Prime发送问候 (需要自动翻译)\n  const zorgResponse = await comms.sendMessage('Zorg-Prime', 'Hello, great leader!');\n  console.log('[舰长日志] Zorg-Prime任务结果:', zorgResponse);\n}\n\nrunMissions();", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-1-5-请求拦截.md", "blockIndex": 4}
{"id": "js-sec-8-2-1", "title": "Cookie", "code": "// 在浏览器的Console中运行此代码\n\n// 设置一个最简单的cookie\n// 格式是 \"key=value\"\ndocument.cookie = \"username=CodeMaster\";\n\n// 读取cookie\n// document.cookie会返回当前网站所有可访问的cookie，以分号分隔的字符串\nconsole.log(\"当前网站的Cookie是:\", document.cookie);\n\n// 清理我们设置的cookie，以便下次演示\n// 将过期时间设置为一个过去的时间点即可删除\ndocument.cookie = \"username=; expires=Thu, 01 Jan 1970 00:00:00 GMT\";\nconsole.log(\"清理后的Cookie是:\", document.cookie);", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-2-1-Cookie.md", "blockIndex": 0}
{"id": "js-sec-8-2-1", "title": "Cookie", "code": "// 在浏览器的Console中运行此代码\n\n// --- 使用 expires 设置过期时间 ---\n// 创建一个表示一天后的日期对象\nconst d = new Date();\nd.setTime(d.getTime() + (24 * 60 * 60 * 1000)); // 24小时\nconst expires = \"expires=\" + d.toUTCString();\n\n// 设置一个将在24小时后过期的cookie\ndocument.cookie = \"user_preference=dark_mode; \" + expires;\nconsole.log(\"设置了带 expires 的Cookie:\", document.cookie);\n\n\n// --- 使用 max-age 设置有效期（单位：秒） ---\n// 设置一个将在1小时（3600秒）后过期的cookie\n// max-age比expires更现代，优先级也更高\ndocument.cookie = \"session_id=xyz123; max-age=3600\";\nconsole.log(\"设置了带 max-age 的Cookie:\", document.cookie);\n\n// 你可以在浏览器的 Application -> Cookies 面板中看到它们的过期时间", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-2-1-Cookie.md", "blockIndex": 1}
{"id": "js-sec-8-2-1", "title": "Cookie", "code": "// 在浏览器的Console中运行此代码\n\n// 先设置几个不同的cookie，模拟真实环境\ndocument.cookie = \"username=HeroCoder\";\ndocument.cookie = \"level=99\";\ndocument.cookie = \"theme=space\";\n\nfunction getCookie(name) {\n  // 1. 获取所有cookie字符串\n  const allCookies = document.cookie;\n  console.log(\"获取到的完整Cookie字符串:\", allCookies);\n\n  // 2. 按分号和空格分割成数组\n  const cookiePairs = allCookies.split('; ');\n\n  // 3. 遍历数组寻找目标cookie\n  for (let i = 0; i < cookiePairs.length; i++) {\n    const pair = cookiePairs[i].split('=');\n    const key = pair[0];\n    const value = pair[1];\n    if (key === name) {\n      // 找到了！返回解码后的值\n      return decodeURIComponent(value);\n    }\n  }\n  // 没找到\n  return null;\n}\n\n// 测试我们的函数\nconst user = getCookie(\"username\");\nconst userLevel = getCookie(\"level\");\n\nconsole.log(`欢迎回来, ${user}! 你的等级是 ${userLevel}。`);\n\n// 清理本次演示设置的cookies\ndocument.cookie = \"username=; expires=Thu, 01 Jan 1970 00:00:00 GMT\";\ndocument.cookie = \"level=; expires=Thu, 01 Jan 1970 00:00:00 GMT\";\ndocument.cookie = \"theme=; expires=Thu, 01 Jan 1970 00:00:00 GMT\";", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-2-1-Cookie.md", "blockIndex": 2}
{"id": "js-sec-8-2-1", "title": "Cookie", "code": "// 在浏览器的Console中运行此代码\n\n// 准备一个包含特殊字符的数据\nconst userProfile = {\n  name: \"Dr. Evil; Jr.\",\n  city: \"New York\"\n};\nconst profileString = JSON.stringify(userProfile);\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 直接将包含特殊字符的字符串作为cookie值\ndocument.cookie = `profile=${profileString}`;\n\n// 读取时，因为分号的存在，cookie字符串被意外截断\nconsole.log(\"直接存储后读取的Cookie字符串:\", document.cookie);\n// 尝试解析，很可能会失败或得到不完整的数据\nconst brokenValue = document.cookie.split('=')[1];\nconsole.log(\"解析出的错误值:\", brokenValue); // 输出 \"{\"name\":\"Dr. Evil\"\nconsole.error(\"❌ 错误：值被分号截断了！\");\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 使用 encodeURIComponent 对值进行编码\nconst encodedProfileString = encodeURIComponent(profileString);\ndocument.cookie = `profile=${encodedProfileString}`;\n\nconsole.log(\"编码后存储的Cookie字符串:\", document.cookie);\n\n// 读取时，先获取到完整编码后的值，再用 decodeURIComponent 解码\nfunction getEncodedCookie(name) {\n  const match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));\n  if (match) {\n    return decodeURIComponent(match[2]);\n  }\n  return null;\n}\nconst correctValue = getEncodedCookie(\"profile\");\nconsole.log(\"正确解码后的值:\", correctValue);\nconst parsedProfile = JSON.parse(correctValue);\nconsole.log(`✅ 正确：成功获取到用户 ${parsedProfile.name} 的信息，他来自 ${parsedProfile.city}`);\n\n// 清理cookie\ndocument.cookie = \"profile=; expires=Thu, 01 Jan 1970 00:00:00 GMT\";", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-2-1-Cookie.md", "blockIndex": 3}
{"id": "js-sec-8-2-1", "title": "Cookie", "code": "// 在浏览器的Console中运行此代码\n\n// --- 宠物状态管理工具 ---\nconst petManager = {\n  // 从Cookie加载宠物状态\n  loadStatus: function() {\n    const petCookie = this.getCookie('virtualPet');\n    if (petCookie) {\n      console.log(\"找到了之前的宠物记录！正在唤醒它...\");\n      return JSON.parse(petCookie);\n    } else {\n      console.log(\"你好，新主人！请为你的宠物取个名字吧。\");\n      return { name: '蛋仔', hunger: 50, happiness: 50 };\n    }\n  },\n  // 将宠物状态保存到Cookie，有效期为7天\n  saveStatus: function(pet) {\n    const petString = JSON.stringify(pet);\n    const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toUTCString();\n    document.cookie = `virtualPet=${encodeURIComponent(petString)}; expires=${expires}; path=/`;\n    console.log(`[系统消息] ${pet.name} 的状态已保存到Cookie。`);\n  },\n  // 读取特定cookie的辅助函数\n  getCookie: function(name) {\n    const value = `; ${document.cookie}`;\n    const parts = value.split(`; ${name}=`);\n    if (parts.length === 2) return decodeURIComponent(parts.pop().split(';').shift());\n  }\n};\n\n// --- 宠物互动函数 ---\nfunction feed(pet) {\n  console.log(`你喂了 ${pet.name} 一块美味的饼干！🍪`);\n  pet.hunger = Math.max(0, pet.hunger - 15);\n  pet.happiness += 5;\n  displayStatus(pet);\n  petManager.saveStatus(pet);\n}\n\nfunction play(pet) {\n  console.log(`你和 ${pet.name} 玩了抛球游戏！🎾`);\n  pet.hunger += 10;\n  pet.happiness = Math.min(100, pet.happiness + 15);\n  displayStatus(pet);\n  petManager.saveStatus(pet);\n}\n\nfunction displayStatus(pet) {\n  console.log(`--- ${pet.name}的当前状态 ---`);\n  console.log(`❤️ 快乐值: ${pet.happiness}/100`);\n  console.log(`🍔 饥饿度: ${pet.hunger}/100`);\n  if (pet.happiness > 80) console.log(`${pet.name} 看上去非常开心！😄`);\n  if (pet.hunger > 70) console.log(`${pet.name} 的肚子在咕咕叫，它好像饿了...😟`);\n}\n\n// --- 游戏开始 ---\nconsole.log(\"--- 欢迎来到虚拟宠物世界！ ---\");\nlet myPet = petManager.loadStatus();\ndisplayStatus(myPet);\n\nconsole.log(\"\\n--- 让我们和宠物互动一下 ---\");\n// 模拟互动\nfeed(myPet);\nplay(myPet);\n\nconsole.log(\"\\n💡 提示：现在刷新页面，然后重新运行这段代码，你会发现宠物的状态被记住了！\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-2-1-Cookie.md", "blockIndex": 4}
{"id": "js-sec-8-2-2", "title": "LocalStorage", "code": "// 清理一下，确保我们从一个干净的状态开始\nlocalStorage.clear();\n\nconsole.log(\"--- 存储前 ---\");\n// 尝试获取一个还不存在的数据，会返回 null\nconst myNameBefore = localStorage.getItem('username');\nconsole.log(\"我的名字是:\", myNameBefore); // 输出: null\n\nconsole.log(\"\\n--- 存储后 ---\");\n// 使用 setItem 存储数据，键是 'username'，值是 'CodeMaster'\nlocalStorage.setItem('username', 'CodeMaster');\n\n// 再次获取数据\nconst myNameAfter = localStorage.getItem('username');\nconsole.log(\"我的名字是:\", myNameAfter); // 输出: CodeMaster", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-2-2-LocalStorage.md", "blockIndex": 0}
{"id": "js-sec-8-2-2", "title": "LocalStorage", "code": "// 模拟第一次访问：存储用户偏好\n// 假设这是用户第一次访问我们的网站\nlocalStorage.setItem('theme', 'dark');\nconsole.log(\"用户首次访问，设置主题为 'dark'\");\n\n// 模拟用户关闭浏览器后再次打开\n// 在这个独立的代码块中，我们直接尝试获取数据\n// 如果你刷新页面或关闭再打开，这个值依然存在\nconst savedTheme = localStorage.getItem('theme');\nconsole.log(`欢迎回来！你之前保存的主题是: ${savedTheme}`); // 输出: dark", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-2-2-LocalStorage.md", "blockIndex": 1}
{"id": "js-sec-8-2-2", "title": "LocalStorage", "code": "// 存储不同类型的数据\nlocalStorage.setItem('userAge', 25); // 数字 25\nlocalStorage.setItem('isVip', true); // 布尔值 true\nlocalStorage.setItem('userInfo', { name: 'Alice', level: 99 }); // 对象\n\n// 取出数据，并检查它们的类型\nconst age = localStorage.getItem('userAge');\nconst vipStatus = localStorage.getItem('isVip');\nconst user = localStorage.getItem('userInfo');\n\nconsole.log(`获取到的年龄: ${age}, 类型是: ${typeof age}`); // 输出: \"25\", 类型是: string\nconsole.log(`获取到的VIP状态: ${vipStatus}, 类型是: ${typeof vipStatus}`); // 输出: \"true\", 类型是: string\nconsole.log(`获取到的用户信息: ${user}, 类型是: ${typeof user}`); // 输出: \"[object Object]\", 类型是: string", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-2-2-LocalStorage.md", "blockIndex": 2}
{"id": "js-sec-8-2-2", "title": "LocalStorage", "code": "// 1. 清空所有存储，以防之前有残留数据\nlocalStorage.clear();\nconsole.log(\"LocalStorage 已清空。\");\n\n// 2. 创建 (Create) / 更新 (Update) 数据\n// setItem 如果键不存在则创建，如果存在则更新\nlocalStorage.setItem('player', 'Zelda');\nlocalStorage.setItem('score', '100');\nconsole.log(\"创建数据: player='Zelda', score='100'\");\n\n// 3. 读取 (Read) 数据\nconst currentPlayer = localStorage.getItem('player');\nconsole.log(`读取玩家: ${currentPlayer}`);\n\n// 4. 删除 (Delete) 单个数据\nlocalStorage.removeItem('score');\nconsole.log(\"删除了 'score'。\");\n\n// 5. 验证删除\nconst currentScore = localStorage.getItem('score');\nconsole.log(`再次读取分数: ${currentScore}`); // 输出: null\n\n// 6. 清空所有数据\nlocalStorage.setItem('tempData1', 'abc');\nlocalStorage.setItem('tempData2', '123');\nconsole.log(\"添加了一些临时数据...\");\nlocalStorage.clear();\nconsole.log(\"执行 clear() 后，所有数据均被删除。\");\nconst temp1 = localStorage.getItem('tempData1');\nconsole.log(`获取临时数据1: ${temp1}`); // 输出: null", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-2-2-LocalStorage.md", "blockIndex": 3}
{"id": "js-sec-8-2-2", "title": "LocalStorage", "code": "// 准备一个玩家对象\nconst playerProfile = {\n  name: \"Link\",\n  level: 10,\n  inventory: [\"Sword\", \"Shield\", \"Potion\"]\n};\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 直接存储对象\nlocalStorage.setItem('playerWrong', playerProfile);\nconst wrongData = localStorage.getItem('playerWrong');\nconsole.log(\"直接存储对象后取出的值:\", wrongData); // 输出: [object Object]\nconsole.log(\"数据类型:\", typeof wrongData); // 输出: string\n// 解释: 对象被转换成了字符串 \"[object Object]\"，所有有用的信息都丢失了。\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 使用 JSON.stringify() 将对象转换为 JSON 字符串\nconst playerProfileString = JSON.stringify(playerProfile);\nlocalStorage.setItem('playerCorrect', playerProfileString);\nconsole.log(\"用JSON.stringify转换后的字符串:\", playerProfileString);\n\n// 从 LocalStorage 取出字符串\nconst correctDataString = localStorage.getItem('playerCorrect');\n// 使用 JSON.parse() 将字符串解析回原始对象\nconst correctDataObject = JSON.parse(correctDataString);\nconsole.log(\"用JSON.parse解析回的对象:\", correctDataObject);\nconsole.log(\"玩家名字:\", correctDataObject.name); // 输出: Link\nconsole.log(\"玩家等级:\", correctDataObject.level); // 输出: 10\n// 解释: 通过序列化和反序列化，我们完美地保存和恢复了整个对象结构。", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-2-2-LocalStorage.md", "blockIndex": 4}
{"id": "js-sec-8-2-2", "title": "LocalStorage", "code": "// 虚拟宠物状态管理器\nfunction virtualPetGame() {\n  const PET_STORAGE_KEY = 'myVirtualPet';\n\n  // 1. 尝试从 LocalStorage 加载宠物数据\n  let pet;\n  const savedPetData = localStorage.getItem(PET_STORAGE_KEY);\n\n  if (savedPetData) {\n    pet = JSON.parse(savedPetData);\n    console.log(`🌟 欢迎回来！找到了你上次照顾的宠物: ${pet.name}！`);\n  } else {\n    // 如果没有找到数据，就创建一只新宠物\n    pet = {\n      name: \"皮卡丘\",\n      hunger: 50, // 0-100, 越低越好\n      happiness: 50, // 0-100, 越高越好\n    };\n    console.log(`🐾 欢迎新主人！你领养了一只叫 ${pet.name} 的新宠物！`);\n  }\n\n  // 显示宠物当前状态的函数\n  function showStatus() {\n    console.log(`--- ${pet.name} 的状态 ---`);\n    console.log(`🍔 饥饿度: ${pet.hunger}/100`);\n    console.log(`😊 快乐度: ${pet.happiness}/100`);\n    if (pet.hunger > 70) console.log(\"（咕噜咕噜... 我好饿呀！）\");\n    if (pet.happiness < 30) console.log(\"（呜... 感觉有点孤单...）\");\n    console.log(\"----------------------\");\n  }\n\n  // 喂食函数\n  function feed() {\n    console.log(\"🍖 你给它吃了一个美味的树果...\");\n    pet.hunger = Math.max(0, pet.hunger - 20); // 饥饿度降低\n    pet.happiness = Math.min(100, pet.happiness + 5); // 快乐度稍微增加\n  }\n\n  // 玩耍函数\n  function play() {\n    console.log(\"🎾 你和它玩了扔球游戏...\");\n    pet.hunger = Math.min(100, pet.hunger + 10); // 玩耍会消耗体力，增加饥饿度\n    pet.happiness = Math.min(100, pet.happiness + 25); // 快乐度大幅增加\n  }\n\n  // 保存进度的函数\n  function saveProgress() {\n    localStorage.setItem(PET_STORAGE_KEY, JSON.stringify(pet));\n    console.log(\"💾 游戏进度已保存！下次见！\");\n  }\n\n  // --- 模拟游戏流程 ---\n  console.log(\"\\n--- 游戏开始 ---\");\n  showStatus();\n\n  console.log(\"\\n--- 互动时间 ---\");\n  feed();\n  play();\n  \n  console.log(\"\\n--- 互动后状态 ---\");\n  showStatus();\n\n  console.log(\"\\n--- 游戏结束，保存进度 ---\");\n  saveProgress();\n  console.log(\"提示：再次运行此代码块，你会看到宠物状态被成功加载了！\");\n}\n\n// 运行游戏\nvirtualPetGame();", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-2-2-LocalStorage.md", "blockIndex": 5}
{"id": "js-sec-8-2-3", "title": "SessionStorage", "code": "// 清理一下，确保从一个干净的状态开始\nsessionStorage.clear();\n\nconsole.log(\"--- 初始状态 ---\");\n// 尝试读取一个不存在的键，会返回 null\nconst initialPlayer = sessionStorage.getItem('currentPlayer');\nconsole.log(\"当前玩家是:\", initialPlayer); // 输出: null\n\nconsole.log(\"\\n--- 存储数据 ---\");\n// 使用 setItem(key, value) 存储数据\nsessionStorage.setItem('currentPlayer', 'Mage_Alex');\nconsole.log(\"已将玩家 'Mage_Alex' 存入 SessionStorage。\");\n\nconsole.log(\"\\n--- 读取数据 ---\");\n// 使用 getItem(key) 读取数据\nconst savedPlayer = sessionStorage.getItem('currentPlayer');\nconsole.log(\"从 SessionStorage 中读取到的玩家是:\", savedPlayer); // 输出: Mage_Alex\n\n// 提示：你可以刷新一下页面，然后再次运行这段代码，会发现'Mage_Alex'还在。\n// 但如果你关闭这个浏览器标签页再重新打开，它就消失了。", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-2-3-SessionStorage.md", "blockIndex": 0}
{"id": "js-sec-8-2-3", "title": "SessionStorage", "code": "// 1. 设置一个值\nsessionStorage.setItem('session-status', 'Active');\nconsole.log(`当前会话状态: ${sessionStorage.getItem('session-status')}`);\nconsole.log(\"✅ 数据已存储。请刷新此页面，再次查看控制台。\");\nconsole.log(\"你会发现 'Active' 这条信息依然存在。\");\n\n// 2. 移除一个值\nsessionStorage.removeItem('session-status');\nconsole.log(`移除后，再次读取会话状态: ${sessionStorage.getItem('session-status')}`); // 输出: null\n\n// 3. 清空所有\nsessionStorage.setItem('temp_data_1', '123');\nsessionStorage.setItem('temp_data_2', 'abc');\nconsole.log(`清空前，项目数量: ${sessionStorage.length}`); // 输出: 2\nsessionStorage.clear();\nconsole.log(`清空后，项目数量: ${sessionStorage.length}`); // 输出: 0\nconsole.log(\"❌ 现在关闭这个浏览器标签页再重新打开，所有 sessionStorage 数据都会消失。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-2-3-SessionStorage.md", "blockIndex": 1}
{"id": "js-sec-8-2-3", "title": "SessionStorage", "code": "console.log(\"--- 存储不同类型的数据 ---\");\n\n// 存储数字 100\nsessionStorage.setItem('playerScore', 100);\nconst score = sessionStorage.getItem('playerScore');\nconsole.log(`分数: ${score}, 类型: ${typeof score}`); // 输出: 分数: 100, 类型: string\n\n// 存储布尔值 true\nsessionStorage.setItem('isGameOver', true);\nconst gameOver = sessionStorage.getItem('isGameOver');\nconsole.log(`游戏结束: ${gameOver}, 类型: ${typeof gameOver}`); // 输出: 游戏结束: true, 类型: string\n\n// 存储一个对象\nconst player = { name: 'Knight_Leo', level: 5 };\nsessionStorage.setItem('playerObject', player);\nconst playerObjStr = sessionStorage.getItem('playerObject');\nconsole.log(`玩家对象: ${playerObjStr}, 类型: ${typeof playerObjStr}`); // 输出: 玩家对象: [object Object], 类型: string\nconsole.warn(\"⚠️ 注意：直接存储对象会得到 '[object Object]' 字符串，这通常不是我们想要的！\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-2-3-SessionStorage.md", "blockIndex": 2}
{"id": "js-sec-8-2-3", "title": "SessionStorage", "code": "// 定义一个玩家状态对象\nconst playerState = {\n  name: 'Wizard_Gandalf',\n  hp: 85,\n  inventory: ['staff', 'spellbook']\n};\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 直接存储对象\nsessionStorage.setItem('playerStateWrong', playerState);\nconst wrongData = sessionStorage.getItem('playerStateWrong');\nconsole.log(\"错误读取的数据:\", wrongData); // 输出: \"[object Object]\"\nconsole.log(\"尝试访问属性:\", wrongData.name); // 输出: undefined\nconsole.log(\"原因：对象被自动转换成了无用的 '[object Object]' 字符串，丢失了所有内部信息。\");\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 使用 JSON.stringify() 转换对象为字符串再存储\nsessionStorage.setItem('playerStateCorrect', JSON.stringify(playerState));\n\n// 从 sessionStorage 读取字符串\nconst correctDataString = sessionStorage.getItem('playerStateCorrect');\n// 使用 JSON.parse() 将字符串转换回对象\nconst correctData = JSON.parse(correctDataString);\n\nconsole.log(\"正确读取的数据:\", correctData);\nconsole.log(\"成功访问属性:\", correctData.name); // 输出: \"Wizard_Gandalf\"\nconsole.log(\"成功访问数组属性:\", correctData.inventory); // 输出: ['staff', 'spellbook']\nconsole.log(\"原因：通过 JSON 格式，我们完整地保留了对象的结构和数据。\");", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-2-3-SessionStorage.md", "blockIndex": 3}
{"id": "js-sec-8-2-3", "title": "SessionStorage", "code": "// 游戏逻辑封装在一个函数中，方便管理\nfunction caveAdventure() {\n  // 1. 初始化或从 SessionStorage 加载游戏状态\n  function loadGame() {\n    const savedState = sessionStorage.getItem('caveAdventureState');\n    if (savedState) {\n      console.log(\"✨ 欢迎回来，勇敢的探险家！正在从上次的存档点继续...\");\n      return JSON.parse(savedState);\n    } else {\n      console.log(\"🌟 一个新的探险开始了！你站在一个黑暗的洞穴入口。\");\n      return {\n        position: 'Entrance',\n        hp: 100,\n        inventory: [],\n        log: ['你进入了洞穴。']\n      };\n    }\n  }\n\n  let gameState = loadGame();\n\n  // 2. 保存游戏状态到 SessionStorage\n  function saveGame() {\n    sessionStorage.setItem('caveAdventureState', JSON.stringify(gameState));\n    console.log(\"💾 [游戏状态已自动保存至 SessionStorage]\");\n  }\n\n  // 3. 游戏动作函数\n  function move(direction) {\n    let message = '';\n    if (gameState.position === 'Entrance' && direction === 'forward') {\n      gameState.position = 'Hall';\n      message = '你向前走，进入了一个宽敞的大厅。';\n    } else if (gameState.position === 'Hall' && direction === 'left') {\n      gameState.position = 'Treasure Room';\n      message = '你向左拐，发现了一个装满金币的宝箱！';\n      gameState.inventory.push('Gold Coins');\n    } else if (gameState.position === 'Hall' && direction === 'right') {\n      gameState.position = 'Trap Room';\n      message = '你向右走，不小心踩到了陷阱！HP -20';\n      gameState.hp -= 20;\n    } else {\n      message = '这个方向没有路可走。';\n    }\n    gameState.log.push(message);\n    saveGame();\n    printStatus();\n  }\n  \n  // 4. 打印当前状态\n  function printStatus() {\n    console.log(\"--------------------------------\");\n    console.log(`当前位置: ${gameState.position}`);\n    console.log(`❤️  生命值: ${gameState.hp}`);\n    console.log(`🎒 背包: [${gameState.inventory.join(', ')}]`);\n    console.log(`📜 日志: ${gameState.log[gameState.log.length - 1]}`); // 只显示最新日志\n    console.log(\"--------------------------------\");\n  }\n  \n  // --- 模拟玩家操作 ---\n  console.log(\"--- 游戏开始 ---\");\n  printStatus();\n  \n  console.log(\"\\n// 玩家选择向前走...\");\n  move('forward');\n\n  console.log(\"\\n// 玩家选择向左走...\");\n  move('left');\n\n  console.log(\"\\n🚨 噢不！手滑刷新了页面！别担心，游戏进度还在。\");\n  console.log(\"（再次运行此代码块即可模拟刷新后的加载效果）\");\n}\n\n// 运行游戏\ncaveAdventure();", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-2-3-SessionStorage.md", "blockIndex": 4}
{"id": "js-sec-8-2-4", "title": "IndexedDB基础", "code": "// Level 1: 打开或创建一个名为 'MyTestDatabase' 的数据库\n// indexedDB.open(databaseName, version)\n// 版本号必须是整数\nconst request = indexedDB.open('MyTestDatabase', 1);\n\n// 当数据库打开失败时触发\nrequest.onerror = function(event) {\n  console.error(\"数据库打开失败:\", event.target.error);\n};\n\n// 当数据库成功打开时触发\nrequest.onsuccess = function(event) {\n  const db = event.target.result;\n  console.log(\"数据库打开成功!\", db);\n  // 使用完毕后，关闭数据库连接\n  db.close();\n};\n\n// 当数据库需要升级版本时触发（首次创建时也会触发）\nrequest.onupgradeneeded = function(event) {\n  const db = event.target.result;\n  console.log(\"数据库版本升级或首次创建。\", db);\n};", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-2-4-IndexedDB基础.md", "blockIndex": 0}
{"id": "js-sec-8-2-4", "title": "IndexedDB基础", "code": "// Level 2, Feature 1: 创建一个对象存储\nconst dbName = 'MyGameDB';\nconst dbVersion = 1;\n\nconst request = indexedDB.open(dbName, dbVersion);\n\nrequest.onerror = (event) => {\n  console.error(`打开数据库 '${dbName}' 失败:`, event.target.error);\n};\n\nrequest.onsuccess = (event) => {\n  console.log(`成功打开数据库 '${dbName}' 版本 ${dbVersion}`);\n  const db = event.target.result;\n  db.close(); // 完成操作后关闭\n};\n\n// onupgradeneeded 是创建和修改数据库结构的唯一地方\nrequest.onupgradeneeded = (event) => {\n  console.log(\"数据库需要升级，正在创建对象存储...\");\n  const db = event.target.result;\n\n  // 创建一个名为 'players' 的对象存储\n  // keyPath 指定了对象中哪个属性是主键\n  if (!db.objectStoreNames.contains('players')) {\n    const objectStore = db.createObjectStore('players', { keyPath: 'id' });\n    console.log(\"对象存储 'players' 创建成功！\");\n\n    // 可以在这里创建索引，用于未来高效查询\n    // objectStore.createIndex('name', 'name', { unique: false });\n    // console.log(\"为 'name' 字段创建索引成功！\");\n  }\n};", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-2-4-IndexedDB基础.md", "blockIndex": 1}
{"id": "js-sec-8-2-4", "title": "IndexedDB基础", "code": "// Level 2, Feature 2: 在事务中添加数据\nconst dbName = 'MyGameDB_L2_F2'; // 使用新库名避免与上例冲突\nconst dbVersion = 1;\n\nconst request = indexedDB.open(dbName, dbVersion);\n\nrequest.onupgradeneeded = (event) => {\n  const db = event.target.result;\n  if (!db.objectStoreNames.contains('players')) {\n    db.createObjectStore('players', { keyPath: 'id' });\n  }\n};\n\nrequest.onsuccess = (event) => {\n  console.log(\"数据库已准备好，开始事务...\");\n  const db = event.target.result;\n\n  // 1. 创建一个事务\n  // 参数1: 要操作的对象存储名数组\n  // 参数2: 模式 ('readonly' 或 'readwrite')\n  const transaction = db.transaction(['players'], 'readwrite');\n\n  // 2. 获取对象存储\n  const playersStore = transaction.objectStore('players');\n\n  // 3. 创建要添加的数据\n  const newPlayer = { id: 'player001', name: 'Pikachu', level: 5 };\n\n  // 4. 添加数据\n  const addRequest = playersStore.add(newPlayer);\n\n  addRequest.onsuccess = () => {\n    console.log(`玩家 '${newPlayer.name}' 已成功添加到 'players' 仓库！`);\n  };\n\n  addRequest.onerror = (e) => {\n    console.error(`添加玩家失败:`, e.target.error);\n  };\n\n  // 事务完成后关闭数据库\n  transaction.oncomplete = () => {\n    console.log(\"所有添加操作的事务已完成。\");\n    db.close();\n  };\n};\n\nrequest.onerror = (event) => {\n  console.error(\"数据库打开失败:\", event.target.error);\n};", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-2-4-IndexedDB基础.md", "blockIndex": 2}
{"id": "js-sec-8-2-4", "title": "IndexedDB基础", "code": "// Level 3: 对比异步操作的时机\nconst dbName = 'MyMistakeDB';\nconst dbVersion = 1;\n\nconsole.log(\"=== 错误用法 ===\");\n// ❌ 错误：在 open() 请求之后立即尝试使用数据库\ntry {\n  const request = indexedDB.open(dbName, 1);\n  // 此时 request 刚刚发出，数据库连接还未建立成功\n  // db 变量是 undefined，因为 onsuccess 回调还没执行\n  const db = request.result; \n  const transaction = db.transaction(['users'], 'readwrite'); // 这行会立即抛出错误\n  console.log(\"错误代码中的事务:\", transaction);\n} catch (error) {\n  console.error(\"❌ 错误用法捕获到异常:\", error.message);\n  console.log(\"解释：不能在 onsuccess 事件触发前访问 request.result。IndexedDB 操作是异步的，必须在回调函数中处理。\");\n}\n\n\nconsole.log(\"\\n=== 正确用法 ===\");\n// ✅ 正确：所有数据库操作都在 onsuccess 事件回调函数中进行\nconst correctRequest = indexedDB.open(dbName, 1);\n\ncorrectRequest.onupgradeneeded = event => {\n  const db = event.target.result;\n  if (!db.objectStoreNames.contains('users')) {\n    db.createObjectStore('users', { keyPath: 'id' });\n  }\n};\n\ncorrectRequest.onerror = event => {\n  console.error(\"✅ 正确用法中的数据库错误:\", event.target.error);\n};\n\ncorrectRequest.onsuccess = event => {\n  console.log(\"✅ 数据库连接成功，现在可以安全地进行操作了。\");\n  const db = event.target.result;\n  const transaction = db.transaction(['users'], 'readwrite');\n  console.log(\"✅ 成功创建事务:\", transaction);\n\n  transaction.oncomplete = () => {\n    console.log(\"✅ 事务完成，关闭数据库。\");\n    db.close();\n  };\n  \n  transaction.onerror = (e) => {\n     console.error(\"✅ 事务中发生错误:\", e.target.error);\n  }\n};", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-2-4-IndexedDB基础.md", "blockIndex": 3}
{"id": "js-sec-8-2-4", "title": "IndexedDB基础", "code": "// Level 4: 虚拟宠物养成游戏\nconst DBNAME = \"PetPalDB\";\nconst DBVERSION = 1;\nconst STORENAME = \"pets\";\n\n// --- 数据库助手函数 ---\nfunction getDB() {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DBNAME, DBVERSION);\n    request.onerror = event => reject(`数据库错误: ${event.target.error}`);\n    request.onsuccess = event => resolve(event.target.result);\n    request.onupgradeneeded = event => {\n      const db = event.target.result;\n      if (!db.objectStoreNames.contains(STORENAME)) {\n        db.createObjectStore(STORENAME, { keyPath: \"id\", autoIncrement: true });\n        console.log(\"宠物小屋（对象存储）建好啦！\");\n      }\n    };\n  });\n}\n\n// --- 宠物操作函数 ---\n\n// 创造一只新宠物\nasync function createPet(name, type) {\n  console.log(`正在创造一只新的宠物: ${name} (${type})...`);\n  const db = await getDB();\n  const transaction = db.transaction(STORENAME, \"readwrite\");\n  const store = transaction.objectStore(STORENAME);\n  const pet = { name, type, happiness: 100, hunger: 0 };\n  const request = store.add(pet);\n\n  return new Promise((resolve, reject) => {\n    request.onsuccess = event => {\n      console.log(`🎉 欢迎来到新世界, ${name}! 你的ID是 ${event.target.result}`);\n      resolve(event.target.result);\n    };\n    request.onerror = event => reject(`创造宠物失败: ${event.target.error}`);\n    transaction.oncomplete = () => db.close();\n  });\n}\n\n// 给宠物喂食\nasync function feedPet(petId) {\n  console.log(`准备给ID为 ${petId} 的宠物喂好吃的...`);\n  const db = await getDB();\n  const transaction = db.transaction(STORENAME, \"readwrite\");\n  const store = transaction.objectStore(STORENAME);\n  const getRequest = store.get(petId);\n\n  getRequest.onsuccess = () => {\n    const pet = getRequest.result;\n    if (pet) {\n      pet.hunger = Math.max(0, pet.hunger - 20); // 减少饥饿度\n      pet.happiness += 10; // 增加开心值\n      const updateRequest = store.put(pet);\n      updateRequest.onsuccess = () => {\n        console.log(`🍖 ${pet.name} 吃得很开心！饥饿度: ${pet.hunger}, 开心值: ${pet.happiness}`);\n      };\n    } else {\n      console.log(`咦？找不到ID为 ${petId} 的宠物。`);\n    }\n  };\n  getRequest.onerror = event => console.error(`查找宠物失败: ${event.target.error}`);\n  transaction.oncomplete = () => db.close();\n}\n\n// 检查所有宠物的状态\nasync function checkAllPetsStatus() {\n  console.log(\"\\n--- 正在检查所有宠物的状态 ---\");\n  const db = await getDB();\n  const transaction = db.transaction(STORENAME, \"readonly\");\n  const store = transaction.objectStore(STORENAME);\n  const getAllRequest = store.getAll();\n\n  getAllRequest.onsuccess = () => {\n    const pets = getAllRequest.result;\n    if (pets.length > 0) {\n      pets.forEach(p => {\n        console.log(`🐾 ID: ${p.id}, 名字: ${p.name}, 类型: ${p.type}, 开心值: ${p.happiness}, 饥饿度: ${p.hunger}`);\n      });\n    } else {\n      console.log(\"你的宠物小屋还是空的，快去创造一只吧！\");\n    }\n  };\n  transaction.oncomplete = () => db.close();\n}\n\n\n// --- 模拟游戏流程 ---\nasync function gameLoop() {\n  // 为了确保每次运行都是干净的，我们先删除旧数据库\n  indexedDB.deleteDatabase(DBNAME);\n  await new Promise(resolve => setTimeout(resolve, 100)); // 等待删除操作完成\n\n  await checkAllPetsStatus(); // 初始检查，应该是空的\n  const petId = await createPet(\"闪电狗\", \"电子犬\");\n  await feedPet(petId);\n  await feedPet(petId);\n  await createPet(\"泡泡猫\", \"水系猫\");\n  await checkAllPetsStatus(); // 最终检查\n}\n\n// 启动游戏！\ngameLoop();", "lang": "javascript", "source": "web-learner/public/content/js-sec-8-2-4-IndexedDB基础.md", "blockIndex": 4}
