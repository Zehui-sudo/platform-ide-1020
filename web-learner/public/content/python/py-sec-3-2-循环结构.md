接续我们对“逻辑与控制流”的探索，在掌握了 `if` 语句的决策能力之后，现在我们将为程序赋予“毅力”与“耐性”——循环结构。

---

### 🎯 核心概念
循环结构让程序能够不知疲倦地重复执行同一段代码，从而自动化处理大量重复性任务，是构建高效、强大程序的核心基石。

### 💡 使用方式
Python 提供了两种主要的循环结构：`for` 循环和 `while` 循环。

-   **`for` 循环**: 用于**遍历**一个可迭代对象（如列表、字符串、元组）中的每一个元素。它的循环次数在开始时通常是确定的。
-   **`while` 循环**: 只要给定的条件为真（True），就会**持续执行**其下的代码块。它的循环次数是不确定的，依赖于条件的动态变化。
    **注意：** 使用 `while` 循环时，务必确保循环体内的代码会改变循环条件，使其最终变为 `False`，否则程序将陷入“无限循环”中。

### 📚 Level 1: 基础认知（30秒理解）
想象你要向你的三位朋友 `Alice`, `Bob`, `Charlie` 逐一发送问候。使用 `for` 循环可以轻松实现。

```python
# 创建一个朋友列表
friends = ["Alice", "Bob", "Charlie"]

# for 循环会依次取出列表中的每个名字，并赋值给 friend 变量
for friend in friends:
    # 针对每个朋友，执行这个打印操作
    print(f"你好，{friend}！很高兴认识你。")

# 预期输出:
# 你好，Alice！很高兴认识你。
# 你好，Bob！很高兴认识你。
# 你好，Charlie！很高兴认识你。
```

### 📈 Level 2: 核心特性（深入理解）
掌握了基础的 `for` 循环后，让我们深入探索循环的更多强大功能。

#### 特性1: 使用 `range()` 函数进行定量循环
当你需要重复执行代码固定的次数，而不是遍历某个现有列表时，`range()` 函数是你的最佳帮手。它能生成一个整数序列。

(语法: `range(start, stop, step)`. `start` 和 `step` 是可选的。)

```python
# 模拟火箭发射倒计时
print("🚀 火箭发射程序启动...")

# range(5, 0, -1) 会生成序列: 5, 4, 3, 2, 1
for i in range(5, 0, -1):
    print(f"{i}...")

print("💥 发射！")

# 预期输出:
# 🚀 火箭发射程序启动...
# 5...
# 4...
# 3...
# 2...
# 1...
# 💥 发射！
```

#### 特性2: 使用 `while` 循环处理不确定次数的循环
`while` 循环适用于那些你不知道具体要循环多少次，只知道循环应该在某个条件不再满足时停止的场景。

```python
# 模拟一个简单的猜数字游戏
import random

secret_number = random.randint(1, 10)
guess = 0 # 初始化 guess，确保循环至少执行一次

print("我心里想了一个1到10之间的数字，你来猜猜看！")

# 只要猜的数字不等于秘密数字，就一直循环
while guess != secret_number:
    guess = int(input("请输入你猜的数字: "))
    
    if guess < secret_number:
        print("太小了，再试试！")
    elif guess > secret_number:
        print("太大了，再试试！")

print(f"🎉 恭喜你，猜对了！答案就是 {secret_number}。")

# 预期输出 (一次可能的交互过程):
# 我心里想了一个1到10之间的数字，你来猜猜看！
# 请输入你猜的数字: 5
# 太小了，再试试！
# 请输入你猜的数字: 8
# 太大了，再试试！
# 请输入你猜的数字: 7
# 🎉 恭喜你，猜对了！答案就是 7。
```

#### 特性3: 使用 `enumerate()` 同时获取索引和值
在遍历列表时，有时我们不仅需要元素本身，还需要知道它在列表中的位置（索引）。`enumerate()` 函数可以优雅地解决这个问题。

```python
# 公布比赛获奖名单
winners = ["阿尔法", "贝塔", "伽玛"]

print("🏆 比赛结果公布 🏆")
# enumerate() 会将每个元素包装成 (索引, 元素) 的元组
for index, name in enumerate(winners):
    # index 从 0 开始，所以我们需要 +1 来表示名次
    print(f"第 {index + 1} 名: {name}")

# 预期输出:
# 🏆 比赛结果公布 🏆
# 第 1 名: 阿尔法
# 第 2 名: 贝塔
# 第 3 名: 伽玛
```

### 🔍 Level 3: 对比学习（避免陷阱）
一个常见的陷阱是混淆 `for` 和 `while` 的适用场景，以及不知道如何优雅地控制循环流程。

**场景**：在一个装满各种水果的篮子里，找到第一个苹果。

```python
# === 错误用法 ===
# ❌ 展示常见错误：找到目标后仍继续检查
fruits = ["香蕉", "橙子", "苹果", "草莓", "蓝莓"]

for fruit in fruits:
    print(f"正在检查: {fruit}")
    if fruit == "苹果":
        print("--> 找到了苹果！但循环仍在继续...") # 强调循环未停止

# 解释：这种写法虽然能找到目标，但效率低下。在找到目标后，循环并没有立即停止，而是遍历了所有剩余的水果，造成不必要的性能浪费。


# === 正确用法 ===
# ✅ 展示正确做法：使用 break 立即跳出循环
fruits = ["香蕉", "橙子", "苹果", "草莓", "蓝莓"]

for fruit in fruits:
    print(f"正在检查: {fruit}")
    if fruit == "苹果":
        print("--> 找到了苹果！任务完成，停止搜索。")
        break # 立即终止整个 for 循环

# 解释：`break` 语句一旦被执行，就会强制结束其所在的整个循环。
# 这种方式更高效、更直接，是控制循环流程的标准做法。
# 类似的，`continue` 用于跳过当前迭代，直接进入下一次迭代。
# 例如：if fruit == "坏掉的香蕉": continue
```

### 🚀 Level 4: 实战应用（真实场景）
**场景：** 📜 炼金术士的魔药配制清单

一位古老的炼金术士正在配置一种强大的“生命之力”魔药。他的配方清单上列出了一系列需要按顺序投入坩埚的材料。但这份古老的清单上有些材料是禁忌的，而某些关键材料一旦投入，反应就会完成。

```python
# --- 炼金术士的配方 ---
recipe = [
    "月光草", 
    "狮鹫之羽", 
    "禁忌的暗影苔", # 这是禁忌材料，需要跳过
    "独角兽的眼泪", 
    "龙之心",       # 这是核心材料，投入后反应完成
    "精灵之尘"      # 这份材料不会被投入
]

cauldron = [] # 我们的坩埚
max_ingredients = 4 # 坩埚最多只能承受4种材料

print("🔮 开始配置'生命之力'魔药...")

# 使用 for 和 enumerate 遍历配方
for step, ingredient in enumerate(recipe):
    print(f"\n步骤 {step + 1}: 准备投入 '{ingredient}'...")

    # 规则1: 如果是禁忌材料，就使用 continue 跳过
    if "禁忌" in ingredient:
        print(f"🔥 警告！'{ingredient}' 是禁忌材料，已跳过！")
        continue

    # 规则2: 如果投入的是核心材料 '龙之心'，使用 break 结束
    if ingredient == "龙之心":
        print(f"✨ '{ingredient}' 已投入！魔力开始汇聚，反应完成！")
        cauldron.append(ingredient)
        break

    # 规则3: 检查坩埚容量，如果满了也用 break 结束 (while 的另一种体现)
    if len(cauldron) >= max_ingredients:
        print("🍲 警告！坩埚已满，无法再添加更多材料！")
        break

    # 正常投入材料
    print(f"✅ '{ingredient}' 已成功投入坩埚。")
    cauldron.append(ingredient)
else:
    # for-else 结构：仅当 for 循环正常结束（没有被 break）时执行
    print("\n📜 所有配方材料已按部就班投入完毕。")

print("\n--- 最终成果 ---")
print(f"坩埚中的魔药成分: {cauldron}")

# 预期输出:
# 🔮 开始配置'生命之力'魔药...
# 
# 步骤 1: 准备投入 '月光草'...
# ✅ '月光草' 已成功投入坩埚。
# 
# 步骤 2: 准备投入 '狮鹫之羽'...
# ✅ '狮鹫之羽' 已成功投入坩埚。
# 
# 步骤 3: 准备投入 '禁忌的暗影苔'...
# 🔥 警告！'禁忌的暗影苔' 是禁忌材料，已跳过！
# 
# 步骤 4: 准备投入 '独角兽的眼泪'...
# ✅ '独角兽的眼泪' 已成功投入坩埚。
# 
# 步骤 5: 准备投入 '龙之心'...
# ✨ '龙之心' 已投入！魔力开始汇聚，反应完成！
# 
# --- 最终成果 ---
# 坩埚中的魔药成分: ['月光草', '狮鹫之羽', '独角兽的眼泪', '龙之心']
```

### 💡 记忆要点
-   **要点1**: **`for` 用于“确定”次数，`while` 用于“不确定”条件**。遍历列表用 `for`，直到用户输入正确密码为止用 `while`。
-   **要点2**: **`break` 是“刹车”，`continue` 是“跳过”**。`break` 会立即彻底地跳出整个循环；`continue` 只跳过当前这一次迭代，继续下一次。
-   **要点3**: **善用 `range()` 和 `enumerate()`**。`range()` 是 `for` 循环执行固定次数的黄金搭档，而 `enumerate()` 是在遍历时同时需要索引和值的最佳实践。