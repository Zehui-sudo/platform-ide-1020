### 🎯 核心概念
路径是命令行的“地址”，理解并熟练运用它，你才能在复杂的文件系统中精确定位，并对目标文件或目录进行操作。

### 💡 使用方式
在命令行中漫游文件系统，主要依赖两个核心命令 `pwd` 和 `cd`，并配合不同类型的路径来实现。

*   **`pwd` (Print Working Directory)**: 告诉你“你现在在哪里？”。它会打印出当前终端会话所在的完整目录路径。
*   **`cd [路径]` (Change Directory)**: 带你“去你想去的地方”。它用于切换当前的工作目录。
*   **路径的种类**:
    *   **绝对路径 (Absolute Path)**: 从系统的根目录 `/` 开始的完整路径，如同一个完整的家庭住址，无论你身在何处，都能准确找到目标。例如：`/var/log`。
    *   **相对路径 (Relative Path)**: 从你当前所在位置开始的路径，如同指路时说“往前走，第二个路口右转”，它依赖于你的当前位置。例如：`../logs`。
*   **特殊目录符号**:
    *   `/` (根目录): 文件系统的最高层级，所有目录和文件的起点。
    *   `~` (家目录): 当前登录用户的个人主目录，是存放个人文件的大本营。直接输入 `cd` 不加任何参数，默认也是回到家目录。
    *   `.` (当前目录): 代表你目前所在的目录。
    *   `..` (父目录): 代表上一级目录。
    *   `-` (上一个目录): 代表你上一次所在的目录，非常便于在两个目录间快速切换。

### 📚 Level 1: 基础认知（30秒理解）
让我们通过 `pwd` 和 `cd` 快速感受一下如何在“家”(`~`)和“系统根目录”(`/`)之间移动。

```bash
# 1. 查看你当前在哪个目录 (通常是你的家目录)
pwd
# 预期输出 (具体用户名会不同):
# /home/your_username  (注意：此路径在不同操作系统上可能不同，例如在 macOS 上通常为 /Users/your_username。)

# 2. 切换到系统的根目录
cd /

# 3. 再次确认当前位置
pwd
# 预期输出:
# /

# 4. 快速返回自己的家目录
cd ~

# 5. 确认已回到家目录
pwd
# 预期输出:
# /home/your_username
```

### 📚 Level 2: 进阶实践
假设你在一个项目目录中，需要在源码目录和文档目录之间跳转。这个场景将展示相对路径和特殊符号的威力。

```bash
# --- 准备环境 ---
# 1. 创建一个项目结构用于练习
mkdir -p project/src
mkdir -p project/docs
echo "This is a source file." > project/src/main.js
echo "This is a doc file." > project/docs/readme.md

# --- 开始漫游 ---
# 2. 进入项目源码目录
cd project/src

# 3. 确认当前位置
pwd
# 预期输出 (路径前缀会因你的当前位置而异):
# .../project/src

# 4. 从 src 目录，使用相对路径切换到 docs 目录
# '..' 指向上一级 (project), 然后进入 'docs'
cd ../docs

# 5. 确认已成功切换
pwd
# 预期输出:
# .../project/docs

# 6. 使用 'cd -' 快速切换回上一个目录 (即 src 目录)
cd -
# 预期输出 (会显示你切换回的目录):
# .../project/src

# --- 清理环境 ---
# 7. 回到初始目录并删除练习用的项目
cd ../..
rm -rf project
```

### 📚 Level 3: 深度拓展
`cd` 命令看似简单，但它背后与Shell环境变量和文件系统链接类型紧密相关。

`cd` 是一个 Shell 内建命令（Builtin），而不是一个独立的程序。为什么？因为如果它是一个外部程序，它将在一个子进程中运行，子进程改变了目录，但父进程（你的Shell）的当前目录不会受到任何影响。作为内建命令，`cd` 可以直接改变当前Shell的环境。

`cd` 的行为还与两个重要的环境变量有关：`PWD` 和 `OLDPWD`。
*   `$PWD`: 存储当前工作目录。
*   `$OLDPWD`: 存储上一个工作目录。

`cd -` 的魔法正是来源于 `OLDPWD`，它实际上等同于 `cd "$OLDPWD"`。

下面的示例将揭示**逻辑路径**与**物理路径**的区别，这在处理符号链接（Symbolic Links）时非常重要。

```bash
# --- 准备环境 ---
# 1. 在 /tmp 目录下创建一个真实的目录
mkdir -p /tmp/physical_location

# 2. 在你的家目录创建一个指向它的符号链接 (快捷方式)
# ln -s [目标] [链接名]
ln -s /tmp/physical_location my_link

# --- 探索路径 ---
# 3. 通过符号链接进入目录
cd my_link

# 4. 使用默认的 `pwd` 查看当前路径 (显示的是逻辑路径)
# Shell 记住了你是通过 my_link 进来的
pwd
# 预期输出 (具体用户名会不同):
# /home/your_username/my_link

# 5. 使用 `pwd -P` 查看物理路径 (P for Physical)
# 它会解析所有符号链接，显示最终的真实位置
pwd -P
# 预期输出:
# /tmp/physical_location

# 6. 观察 `cd ..` 的行为
# 默认情况下，它会回到逻辑上的上一级目录。这是 Bash 等主流 Shell 的默认行为，它会优先解析逻辑路径。
cd ..
pwd
# 预期输出:
# /home/your_username

# --- 清理环境 ---
# 7. 删除创建的链接和目录
rm my_link
rm -rf /tmp/physical_location
```

### 📝 总结
下表汇总了文件系统漫游的核心工具，掌握它们，你就能在命令行世界里行动自如。

| 命令/符号 | 描述 | 示例 |
| :--- | :--- | :--- |
| `pwd` | **P**rint **W**orking **D**irectory，打印当前工作目录。 | `pwd` |
| `cd [路径]` | **C**hange **D**irectory，切换到指定目录。 | `cd /var/log` |
| `/` | 根目录，文件系统的起点，也是绝对路径的标志。 | `cd /` |
| `~` | 当前用户的家目录，是个人文件的默认存放地。 | `cd ~` 或 `cd` |
| `.` | 代表当前目录。 | `ls .` |
| `..` | 代表父目录（上一级目录）。 | `cd ..` |
| `-` | 代表上一个工作目录，用于快速往返。 | `cd -` |
