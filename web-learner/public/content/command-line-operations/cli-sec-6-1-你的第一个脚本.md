好的，总建筑师。作为您的世界级技术教育者和命令行专家，我将依据这份“教学设计图”为您精心打造一篇高质量的 Markdown 教程。

---

### 章节 6.1：你的第一个脚本

🎯 **核心概念**
Shell 脚本能将一系列重复的命令行操作打包成一个可执行文件，实现一键自动化，从而极大提高工作效率并减少人为错误。

💡 **使用方式**
创建一个可执行的 Shell 脚本通常遵循以下四个核心步骤：

1.  **创建文件**: 使用文本编辑器（如 `vim`, `nano` 或 `code`）创建一个以 `.sh` 结尾的文本文件。
2.  **编写内容**: 在文件第一行写入 `#!/bin/bash` (称为 Shebang)，接着在下面编写你想要自动执行的命令。
3.  **赋予权限**: 在终端中使用 `chmod +x <脚本文件名>` 命令，给予该文件执行权限。
4.  **执行脚本**: 在终端中使用 `./<脚本文件名>` 来运行你的脚本。

📚 **Level 1: 基础认知（30秒理解）**
让我们创建一个最简单的脚本，它只做一件事：在屏幕上打印 "Hello, Automation!"。

```bash
# 步骤1 & 2: 创建并编写脚本 hello.sh
# 使用 cat 命令可以快速创建文件，你也可以用任何文本编辑器
cat > hello.sh << EOF
#!/bin/bash
# 这行是注释，不会被执行
echo "Hello, Automation!"
EOF

# 步骤3: 赋予执行权限
chmod +x hello.sh

# 步骤4: 执行脚本
./hello.sh
# 预期输出:
# Hello, Automation!
```

---

📈 **Level 2: 核心特性（深入理解）**
一个脚本的真正威力在于它能按顺序执行多个命令，并且通过注释保持清晰易读。

**特性1: Shebang (`#!`) 的重要性**
Shebang 必须是脚本的**第一行**，它像一个指令牌，告诉操作系统：“请使用 `/bin/bash` 这个程序来解释和执行我下面的代码。” 如果没有它，或者写错了位置，系统可能不知道如何正确运行脚本。

```bash
# 创建一个名为 system_check.sh 的脚本
cat > system_check.sh << EOF
#!/bin/bash
# Shebang 在第一行，正确！

echo "--- 系统状态检查开始 ---"
echo "当前登录用户是:"
whoami
echo "--- 系统状态检查结束 ---"
EOF

chmod +x system_check.sh
./system_check.sh

# 预期输出 (用户名会是你的):
# --- 系统状态检查开始 ---
# 当前登录用户是:
# your_username
# --- 系统状态检查结束 ---
```

**特性2: 命令的顺序执行**
脚本中的命令会从上到下逐行执行，就像你在终端里一个一个手动输入一样。这保证了任务的执行流程是可预测的。

```bash
# 创建一个名为 multi_step.sh 的脚本
cat > multi_step.sh << EOF
#!/bin/bash

echo "第一步: 显示当前在哪个目录。"
pwd

echo "" # 打印一个空行，为了美观

echo "第二步: 列出当前目录的文件详情。"
ls -l

echo ""

echo "第三步: 任务完成！"
EOF

chmod +x multi_step.sh
./multi_step.sh

# 预期输出 (具体文件列表会不同):
# 第一步: 显示当前在哪个目录。
# /home/your_username/some_folder
#
# 第二步: 列出当前目录的文件详情。
# total 8
# -rwxr-xr-x 1 user group 100 Jan 1 10:00 multi_step.sh
#
# 第三步: 任务完成！
```

---

🔍 **Level 3: 对比学习（避免陷阱）**
初学者最常犯的错误是忘记给脚本赋予执行权限，导致无法运行。

```bash
# === 错误用法 ===
# ❌ 创建脚本后直接尝试运行

# 1. 创建脚本
cat > mission_brief.sh << EOF
#!/bin/bash
echo "任务简报：一切正常。"
EOF

# 2. 未赋予权限，直接执行
./mission_brief.sh

# 你会看到这样的错误信息:
# bash: ./mission_brief.sh: Permission denied

# 解释为什么是错的:
# 默认情况下，新创建的文本文件只具有读写权限，操作系统为了安全，不允许你直接执行一个不被信任为“程序”的文件。
# “Permission denied” (权限被拒绝) 就是最直接的体现。

# === 正确用法 ===
# ✅ 在执行前，先使用 chmod +x 授权

# 1. 创建脚本 (内容同上)
cat > mission_brief.sh << EOF
#!/bin/bash
echo "任务简报：一切正常。"
EOF

# 2. ✨ 关键步骤：赋予执行权限 ✨
chmod +x mission_brief.sh

# 3. 现在可以成功执行了
./mission_brief.sh

# 预期输出:
# 任务简报：一切正常。

# 解释为什么这样是对的:
# `chmod +x` 命令为文件所有者添加了“执行”(eXecute)权限。这相当于你向操作系统担保：“我知道这是什么，我允许它作为程序运行。”
# 之后，使用 `./` 前缀告诉 Shell 在当前目录下查找并执行这个脚本。
```

---

🚀 **Level 4: 实战应用（真实场景）**
**场景示例：🚀 太空探险家每日报到**
你是一名驻扎在外星球的太空探险家。每天早上，你需要运行一个脚本来快速检查飞船的各项基本状态，并生成一份简报。

```bash
# 脚本名称: daily_report.sh

# 1. 创建并编写脚本
cat > daily_report.sh << 'EOF'
#!/bin/bash

# 清空屏幕，让报告更整洁
clear

# 使用 echo 和 ANSI escape codes 打印彩色标题
echo -e "\033[1;36m--- 🚀 “开拓者号”飞船每日系统自检报告 ---\033[0m"
echo ""

# 问候探险家
echo "早上好，指挥官！今天是美好的一天。"
echo ""

# 报告当前星球时间 (系统时间)
echo "📅 当前时间:"
date
echo ""

# 报告系统已运行时间
echo "⏱️ 系统已持续运行时间:"
uptime -p # -p 参数让输出更友好
echo ""

# 检查主存储单元剩余空间
echo "💾 主存储单元空间使用情况:"
df -h / | grep --color=never / # df -h 查看磁盘，grep / 只显示根目录行
echo ""

# 结束语
echo -e "\033[1;32m✅ 系统自检完成。祝您今日探索顺利！\033[0m"
EOF

# 2. 赋予执行权限
chmod +x daily_report.sh

# 3. 执行每日报到脚本！
./daily_report.sh
```

**运行脚本后的预期输出：**

```
--- 🚀 “开拓者号”飞船每日系统自检报告 ---

早上好，指挥官！今天是美好的一天。

📅 当前时间:
Sun Feb 26 09:30:00 UTC 2023

⏱️ 系统已持续运行时间:
up 2 hours, 15 minutes

💾 主存储单元空间使用情况:
/dev/vda1       100G   20G   80G  20% /

✅ 系统自检完成。祝您今日探索顺利！
```

---

💡 **记忆要点**
- **要点1: `#!/bin/bash` 是通行证**: 脚本第一行必须是 Shebang，它告诉系统该用什么“语言”（解释器）来读懂你的命令。
- **要点2: `chmod +x` 是授权书**: 文件默认不能执行。必须用 `chmod +x` 命令给它“盖章授权”，操作系统才认可它是一个可执行程序。
- **要点3: `./` 是执行咒语**: 在当前目录下运行脚本，必须用 `./脚本名` 的格式。这个 `.` 代表“当前目录”，明确告诉 Shell “就在这里找”。