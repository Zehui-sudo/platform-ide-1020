在前一节中，我们学习了数据流的精确控制（I/O 重定向）。现在，我们将探讨如何高效地将这些命令串联起来，构建强大的数据处理流水线。

---

### 🎯 核心概念
管道符 `|` 允许我们将一个命令的标准输出直接作为另一个命令的标准输入，无需借助中间文件。这使得我们可以将一系列简单的命令像积木一样拼接起来，形成复杂而强大的数据处理“流水线”，极大地提升了命令行操作的效率和灵活性。

### 💡 使用方式
管道符 `|` 的基本语法非常直观：

`command1 | command2 | command3 ...`

在这个结构中：
*   `command1` 的**标准输出 (stdout)** 会被直接传递给 `command2` 的**标准输入 (stdin)**。
*   `command2` 处理完接收到的数据后，其**标准输出 (stdout)** 又会被传递给 `command3` 的**标准输入 (stdin)**，依此类推。
*   每个命令都像一个独立的“工作站”，只负责处理从其输入端接收的数据，并将其结果输出到其输出端，而无需关心数据源自何处或去向何方。

### 📚 Level 1: 基础认知（30秒理解）
最简单、也是最常用的管道场景之一，就是将一个命令产生的冗长输出，通过 `less` 或 `more` 命令进行分页查看，避免输出内容瞬间刷过屏幕。

```bash
# 1. 演示管道的核心能力：将命令输出直接传递，无需创建临时文件。
#    这里，`for` 循环生成10行文本，其输出被直接“管道”给 `less` 命令进行分页显示。
#    (这是一个交互式命令，您可以按 '空格键' 下翻，'b' 上翻，'q' 退出 less 界面)
for i in $(seq 1 10); do echo "This is line $i."; done | less

# 2. 同样，我们可以将输出传递给 'head' 命令，只查看前3行。
for i in $(seq 1 10); do echo "This is line $i."; done | head -n 3

# 预期输出:
# This is line 1.
# This is line 2.
# This is line 3.

# --- 
# 管道同样可以用来处理已存在文件中的数据。
# 为了演示，我们先创建一个包含多行文本的临时文件。

# 3. 创建临时文件。
for i in $(seq 1 10); do echo "This is line $i."; done > long_list.txt

# 4. 使用 'cat' 将文件内容输出，然后通过管道传递给 'less'。
#    这与第一个示例的效果相同，但这次数据源是一个文件。
cat long_list.txt | less

# 5. 为了保持环境整洁，删除我们创建的测试文件。
rm long_list.txt
```